/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["resources_js_vue_node_modules_jcanvas_dist_jcanvas_js"],{

/***/ "./resources/js/vue/node_modules/jcanvas/dist/jcanvas.js":
/*!***************************************************************!*\
  !*** ./resources/js/vue/node_modules/jcanvas/dist/jcanvas.js ***!
  \***************************************************************/
/***/ (function(module) {

eval("/**\n * @license jCanvas v21.0.1\n * Copyright 2017 Caleb Evans\n * Released under the MIT license\n */\n(function (jQuery, global, factory) {\n\t'use strict';\n\n\tif ( true && typeof module.exports === 'object') {\n\t\tmodule.exports = function (jQuery, w) {\n\t\t\treturn factory(jQuery, w);\n\t\t};\n\t} else {\n\t\tfactory(jQuery, global);\n\t}\n\n// Pass this if window is not defined yet\n}(typeof window !== 'undefined' ? window.jQuery : {}, typeof window !== 'undefined' ? window : this, function ($, window) {\n'use strict';\n\nvar document = window.document,\n\tImage = window.Image,\n\tArray = window.Array,\n\tgetComputedStyle = window.getComputedStyle,\n\tMath = window.Math,\n\tNumber = window.Number,\n\tparseFloat = window.parseFloat;\n\n// Define local aliases to frequently used properties\nvar defaults,\n\t// Aliases to jQuery methods\n\textendObject = $.extend,\n\tinArray = $.inArray,\n\ttypeOf = function (operand) {\n\t\treturn Object.prototype.toString.call(operand)\n\t\t\t.slice(8, -1).toLowerCase();\n\t},\n\tisPlainObject = $.isPlainObject,\n\t// Math constants and functions\n\tPI = Math.PI,\n\tround = Math.round,\n\tabs = Math.abs,\n\tsin = Math.sin,\n\tcos = Math.cos,\n\tatan2 = Math.atan2,\n\t// The Array slice() method\n\tarraySlice = Array.prototype.slice,\n\t// jQuery's internal event normalization function\n\tjQueryEventFix = $.event.fix,\n\t// Object for storing a number of internal property maps\n\tmaps = {},\n\t// jQuery internal caches\n\tcaches = {\n\t\tdataCache: {},\n\t\tpropCache: {},\n\t\timageCache: {}\n\t},\n\t// Base transformations\n\tbaseTransforms = {\n\t\trotate: 0,\n\t\tscaleX: 1,\n\t\tscaleY: 1,\n\t\ttranslateX: 0,\n\t\ttranslateY: 0,\n\t\t// Store all previous masks\n\t\tmasks: []\n\t},\n\t// Object for storing CSS-related properties\n\tcss = {},\n\ttangibleEvents = [\n\t\t'mousedown',\n\t\t'mousemove',\n\t\t'mouseup',\n\t\t'mouseover',\n\t\t'mouseout',\n\t\t'touchstart',\n\t\t'touchmove',\n\t\t'touchend'\n\t];\n\n// Constructor for creating objects that inherit from jCanvas preferences and defaults\nfunction jCanvasObject(args) {\n\tvar params = this,\n\t\tpropName;\n\t// Copy the given parameters into new object\n\tfor (propName in args) {\n\t\t// Do not merge defaults into parameters\n\t\tif (Object.prototype.hasOwnProperty.call(args, propName)) {\n\t\t\tparams[propName] = args[propName];\n\t\t}\n\t}\n\treturn params;\n}\n\n// jCanvas object in which global settings are other data are stored\nvar jCanvas = {\n\t// Events object for storing jCanvas event initiation functions\n\tevents: {},\n\t// Object containing all jCanvas event hooks\n\teventHooks: {},\n\t// Settings for enabling future jCanvas features\n\tfuture: {}\n};\n\n// jCanvas default property values\nfunction jCanvasDefaults() {\n\textendObject(this, jCanvasDefaults.baseDefaults);\n}\njCanvasDefaults.baseDefaults = {\n\talign: 'center',\n\tarrowAngle: 90,\n\tarrowRadius: 0,\n\tautosave: true,\n\tbaseline: 'middle',\n\tbringToFront: false,\n\tccw: false,\n\tclosed: false,\n\tcompositing: 'source-over',\n\tconcavity: 0,\n\tcornerRadius: 0,\n\tcount: 1,\n\tcropFromCenter: true,\n\tcrossOrigin: null,\n\tcursors: null,\n\tdisableEvents: false,\n\tdraggable: false,\n\tdragGroups: null,\n\tgroups: null,\n\tdata: null,\n\tdx: null,\n\tdy: null,\n\tend: 360,\n\teventX: null,\n\teventY: null,\n\tfillStyle: 'transparent',\n\tfontStyle: 'normal',\n\tfontSize: '12pt',\n\tfontFamily: 'sans-serif',\n\tfromCenter: true,\n\theight: null,\n\timageSmoothing: true,\n\tinDegrees: true,\n\tintangible: false,\n\tindex: null,\n\tletterSpacing: null,\n\tlineHeight: 1,\n\tlayer: false,\n\tmask: false,\n\tmaxWidth: null,\n\tmiterLimit: 10,\n\tname: null,\n\topacity: 1,\n\tr1: null,\n\tr2: null,\n\tradius: 0,\n\trepeat: 'repeat',\n\trespectAlign: false,\n\trestrictDragToAxis: null,\n\trotate: 0,\n\trounded: false,\n\tscale: 1,\n\tscaleX: 1,\n\tscaleY: 1,\n\tshadowBlur: 0,\n\tshadowColor: 'transparent',\n\tshadowStroke: false,\n\tshadowX: 0,\n\tshadowY: 0,\n\tsHeight: null,\n\tsides: 0,\n\tsource: '',\n\tspread: 0,\n\tstart: 0,\n\tstrokeCap: 'butt',\n\tstrokeDash: null,\n\tstrokeDashOffset: 0,\n\tstrokeJoin: 'miter',\n\tstrokeStyle: 'transparent',\n\tstrokeWidth: 1,\n\tsWidth: null,\n\tsx: null,\n\tsy: null,\n\ttext: '',\n\ttranslate: 0,\n\ttranslateX: 0,\n\ttranslateY: 0,\n\ttype: null,\n\tvisible: true,\n\twidth: null,\n\tx: 0,\n\ty: 0\n};\ndefaults = new jCanvasDefaults();\njCanvasObject.prototype = defaults;\n\n/* Internal helper methods */\n\n// Determines if the given operand is a string\nfunction isString(operand) {\n\treturn (typeOf(operand) === 'string');\n}\n\n// Determines if the given operand is a function\nfunction isFunction(operand) {\n\treturn (typeOf(operand) === 'function');\n}\n\n// Determines if the given operand is numeric\nfunction isNumeric(operand) {\n\treturn !isNaN(Number(operand)) && !isNaN(parseFloat(operand));\n}\n\n// Get 2D context for the given canvas\nfunction _getContext(canvas) {\n\treturn (canvas && canvas.getContext ? canvas.getContext('2d') : null);\n}\n\n// Coerce designated number properties from strings to numbers\nfunction _coerceNumericProps(props) {\n\tvar propName, propType, propValue;\n\t// Loop through all properties in given property map\n\tfor (propName in props) {\n\t\tif (Object.prototype.hasOwnProperty.call(props, propName)) {\n\t\t\tpropValue = props[propName];\n\t\t\tpropType = typeOf(propValue);\n\t\t\t// If property is non-empty string and value is numeric\n\t\t\tif (propType === 'string' && isNumeric(propValue) && propName !== 'text') {\n\t\t\t\t// Convert value to number\n\t\t\t\tprops[propName] = parseFloat(propValue);\n\t\t\t}\n\t\t}\n\t}\n\t// Ensure value of text property is always a string\n\tif (props.text !== undefined) {\n\t\tprops.text = String(props.text);\n\t}\n}\n\n// Clone the given transformations object\nfunction _cloneTransforms(transforms) {\n\t// Clone the object itself\n\ttransforms = extendObject({}, transforms);\n\t// Clone the object's masks array\n\ttransforms.masks = transforms.masks.slice(0);\n\treturn transforms;\n}\n\n// Save canvas context and update transformation stack\nfunction _saveCanvas(ctx, data) {\n\tvar transforms;\n\tctx.save();\n\ttransforms = _cloneTransforms(data.transforms);\n\tdata.savedTransforms.push(transforms);\n}\n\n// Restore canvas context update transformation stack\nfunction _restoreCanvas(ctx, data) {\n\tif (data.savedTransforms.length === 0) {\n\t\t// Reset transformation state if it can't be restored any more\n\t\tdata.transforms = _cloneTransforms(baseTransforms);\n\t} else {\n\t\t// Restore canvas context\n\t\tctx.restore();\n\t\t// Restore current transform state to the last saved state\n\t\tdata.transforms = data.savedTransforms.pop();\n\t}\n}\n\n// Set the style with the given name\nfunction _setStyle(canvas, ctx, params, styleName) {\n\tif (params[styleName]) {\n\t\tif (isFunction(params[styleName])) {\n\t\t\t// Handle functions\n\t\t\tctx[styleName] = params[styleName].call(canvas, params);\n\t\t} else {\n\t\t\t// Handle string values\n\t\t\tctx[styleName] = params[styleName];\n\t\t}\n\t}\n}\n\n// Set canvas context properties\nfunction _setGlobalProps(canvas, ctx, params) {\n\t_setStyle(canvas, ctx, params, 'fillStyle');\n\t_setStyle(canvas, ctx, params, 'strokeStyle');\n\tctx.lineWidth = params.strokeWidth;\n\t// Optionally round corners for paths\n\tif (params.rounded) {\n\t\tctx.lineCap = ctx.lineJoin = 'round';\n\t} else {\n\t\tctx.lineCap = params.strokeCap;\n\t\tctx.lineJoin = params.strokeJoin;\n\t\tctx.miterLimit = params.miterLimit;\n\t}\n\t// Reset strokeDash if null\n\tif (!params.strokeDash) {\n\t\tparams.strokeDash = [];\n\t}\n\t// Dashed lines\n\tif (ctx.setLineDash) {\n\t\tctx.setLineDash(params.strokeDash);\n\t}\n\tctx.webkitLineDash = params.strokeDash;\n\tctx.lineDashOffset = ctx.webkitLineDashOffset = ctx.mozDashOffset = params.strokeDashOffset;\n\t// Drop shadow\n\tctx.shadowOffsetX = params.shadowX;\n\tctx.shadowOffsetY = params.shadowY;\n\tctx.shadowBlur = params.shadowBlur;\n\tctx.shadowColor = params.shadowColor;\n\t// Opacity and composite operation\n\tctx.globalAlpha = params.opacity;\n\tctx.globalCompositeOperation = params.compositing;\n\t// Support cross-browser toggling of image smoothing\n\tif (params.imageSmoothing) {\n\t\tctx.imageSmoothingEnabled = params.imageSmoothing;\n\t}\n}\n\n// Optionally enable masking support for this path\nfunction _enableMasking(ctx, data, params) {\n\tif (params.mask) {\n\t\t// If jCanvas autosave is enabled\n\t\tif (params.autosave) {\n\t\t\t// Automatically save transformation state by default\n\t\t\t_saveCanvas(ctx, data);\n\t\t}\n\t\t// Clip the current path\n\t\tctx.clip();\n\t\t// Keep track of current masks\n\t\tdata.transforms.masks.push(params._args);\n\t}\n}\n\n// Restore individual shape transformation\nfunction _restoreTransform(ctx, params) {\n\t// If shape has been transformed by jCanvas\n\tif (params._transformed) {\n\t\t// Restore canvas context\n\t\tctx.restore();\n\t}\n}\n\n// Close current canvas path\nfunction _closePath(canvas, ctx, params) {\n\tvar data;\n\n\t// Optionally close path\n\tif (params.closed) {\n\t\tctx.closePath();\n\t}\n\n\tif (params.shadowStroke && params.strokeWidth !== 0) {\n\t\t// Extend the shadow to include the stroke of a drawing\n\n\t\t// Add a stroke shadow by stroking before filling\n\t\tctx.stroke();\n\t\tctx.fill();\n\t\t// Ensure the below stroking does not inherit a shadow\n\t\tctx.shadowColor = 'transparent';\n\t\tctx.shadowBlur = 0;\n\t\t// Stroke over fill as usual\n\t\tctx.stroke();\n\n\t} else {\n\t\t// If shadowStroke is not enabled, stroke & fill as usual\n\n\t\tctx.fill();\n\t\t// Prevent extra shadow created by stroke (but only when fill is present)\n\t\tif (params.fillStyle !== 'transparent') {\n\t\t\tctx.shadowColor = 'transparent';\n\t\t}\n\t\tif (params.strokeWidth !== 0) {\n\t\t\t// Only stroke if the stroke is not 0\n\t\t\tctx.stroke();\n\t\t}\n\n\t}\n\n\t// Optionally close path\n\tif (!params.closed) {\n\t\tctx.closePath();\n\t}\n\n\t// Restore individual shape transformation\n\t_restoreTransform(ctx, params);\n\n\t// Mask shape if chosen\n\tif (params.mask) {\n\t\t// Retrieve canvas data\n\t\tdata = _getCanvasData(canvas);\n\t\t_enableMasking(ctx, data, params);\n\t}\n\n}\n\n// Transform (translate, scale, or rotate) shape\nfunction _transformShape(canvas, ctx, params, width, height) {\n\n\t// Get conversion factor for radians\n\tparams._toRad = (params.inDegrees ? (PI / 180) : 1);\n\n\tparams._transformed = true;\n\tctx.save();\n\n\t// Optionally measure (x, y) position from top-left corner\n\tif (!params.fromCenter && !params._centered && width !== undefined) {\n\t\t// Always draw from center unless otherwise specified\n\t\tif (height === undefined) {\n\t\t\theight = width;\n\t\t}\n\t\tparams.x += width / 2;\n\t\tparams.y += height / 2;\n\t\tparams._centered = true;\n\t}\n\t// Optionally rotate shape\n\tif (params.rotate) {\n\t\t_rotateCanvas(ctx, params, null);\n\t}\n\t// Optionally scale shape\n\tif (params.scale !== 1 || params.scaleX !== 1 || params.scaleY !== 1) {\n\t\t_scaleCanvas(ctx, params, null);\n\t}\n\t// Optionally translate shape\n\tif (params.translate || params.translateX || params.translateY) {\n\t\t_translateCanvas(ctx, params, null);\n\t}\n\n}\n\n/* Plugin API */\n\n// Extend jCanvas with a user-defined method\njCanvas.extend = function extend(plugin) {\n\n\t// Create plugin\n\tif (plugin.name) {\n\t\t// Merge properties with defaults\n\t\tif (plugin.props) {\n\t\t\textendObject(defaults, plugin.props);\n\t\t}\n\t\t// Define plugin method\n\t\t$.fn[plugin.name] = function self(args) {\n\t\t\tvar $canvases = this, canvas, e, ctx,\n\t\t\t\tparams;\n\n\t\t\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t\t\tcanvas = $canvases[e];\n\t\t\t\tctx = _getContext(canvas);\n\t\t\t\tif (ctx) {\n\n\t\t\t\t\tparams = new jCanvasObject(args);\n\t\t\t\t\t_addLayer(canvas, params, args, self);\n\n\t\t\t\t\t_setGlobalProps(canvas, ctx, params);\n\t\t\t\t\tplugin.fn.call(canvas, ctx, params);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $canvases;\n\t\t};\n\t\t// Add drawing type to drawing map\n\t\tif (plugin.type) {\n\t\t\tmaps.drawings[plugin.type] = plugin.name;\n\t\t}\n\t}\n\treturn $.fn[plugin.name];\n};\n\n/* Layer API */\n\n// Retrieved the stored jCanvas data for a canvas element\nfunction _getCanvasData(canvas) {\n\tvar dataCache = caches.dataCache, data;\n\tif (dataCache._canvas === canvas && dataCache._data) {\n\n\t\t// Retrieve canvas data from cache if possible\n\t\tdata = dataCache._data;\n\n\t} else {\n\n\t\t// Retrieve canvas data from jQuery's internal data storage\n\t\tdata = $.data(canvas, 'jCanvas');\n\t\tif (!data) {\n\n\t\t\t// Create canvas data object if it does not already exist\n\t\t\tdata = {\n\t\t\t\t// The associated canvas element\n\t\t\t\tcanvas: canvas,\n\t\t\t\t// Layers array\n\t\t\t\tlayers: [],\n\t\t\t\t// Layer maps\n\t\t\t\tlayer: {\n\t\t\t\t\tnames: {},\n\t\t\t\t\tgroups: {}\n\t\t\t\t},\n\t\t\t\teventHooks: {},\n\t\t\t\t// All layers that intersect with the event coordinates (regardless of visibility)\n\t\t\t\tintersecting: [],\n\t\t\t\t// The topmost layer whose area contains the event coordinates\n\t\t\t\tlastIntersected: null,\n\t\t\t\tcursor: $(canvas).css('cursor'),\n\t\t\t\t// Properties for the current drag event\n\t\t\t\tdrag: {\n\t\t\t\t\tlayer: null,\n\t\t\t\t\tdragging: false\n\t\t\t\t},\n\t\t\t\t// Data for the current event\n\t\t\t\tevent: {\n\t\t\t\t\ttype: null,\n\t\t\t\t\tx: null,\n\t\t\t\t\ty: null\n\t\t\t\t},\n\t\t\t\t// Events which already have been bound to the canvas\n\t\t\t\tevents: {},\n\t\t\t\t// The canvas's current transformation state\n\t\t\t\ttransforms: _cloneTransforms(baseTransforms),\n\t\t\t\tsavedTransforms: [],\n\t\t\t\t// Whether a layer is being animated or not\n\t\t\t\tanimating: false,\n\t\t\t\t// The layer currently being animated\n\t\t\t\tanimated: null,\n\t\t\t\t// The device pixel ratio\n\t\t\t\tpixelRatio: 1,\n\t\t\t\t// Whether pixel ratio transformations have been applied\n\t\t\t\tscaled: false,\n\t\t\t\t// Whether the canvas should be redrawn when a layer mousemove\n\t\t\t\t// event triggers (either directly, or indirectly via dragging)\n\t\t\t\tredrawOnMousemove: false\n\t\t\t};\n\t\t\t// Use jQuery to store canvas data\n\t\t\t$.data(canvas, 'jCanvas', data);\n\n\t\t}\n\t\t// Cache canvas data for faster retrieval\n\t\tdataCache._canvas = canvas;\n\t\tdataCache._data = data;\n\n\t}\n\treturn data;\n}\n\n// Initialize all of a layer's associated jCanvas events\nfunction _addLayerEvents($canvas, data, layer) {\n\tvar eventName;\n\t// Determine which jCanvas events need to be bound to this layer\n\tfor (eventName in jCanvas.events) {\n\t\tif (Object.prototype.hasOwnProperty.call(jCanvas.events, eventName)) {\n\t\t\t// If layer has callback function to complement it\n\t\t\tif (layer[eventName] || (layer.cursors && layer.cursors[eventName])) {\n\t\t\t\t// Bind event to layer\n\t\t\t\t_addExplicitLayerEvent($canvas, data, layer, eventName);\n\t\t\t}\n\t\t}\n\t}\n\tif (!data.events.mouseout) {\n\t\t$canvas.bind('mouseout.jCanvas', function () {\n\t\t\t// Retrieve the layer whose drag event was canceled\n\t\t\tvar layer = data.drag.layer, l;\n\t\t\t// If cursor mouses out of canvas while dragging\n\t\t\tif (layer) {\n\t\t\t\t// Cancel drag\n\t\t\t\tdata.drag = {};\n\t\t\t\t_triggerLayerEvent($canvas, data, layer, 'dragcancel');\n\t\t\t}\n\t\t\t// Loop through all layers\n\t\t\tfor (l = 0; l < data.layers.length; l += 1) {\n\t\t\t\tlayer = data.layers[l];\n\t\t\t\t// If layer thinks it's still being moused over\n\t\t\t\tif (layer._hovered) {\n\t\t\t\t\t// Trigger mouseout on layer\n\t\t\t\t\t$canvas.triggerLayerEvent(data.layers[l], 'mouseout');\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Redraw layers\n\t\t\t$canvas.drawLayers();\n\t\t});\n\t\t// Indicate that an event handler has been bound\n\t\tdata.events.mouseout = true;\n\t}\n}\n\n// Initialize the given event on the given layer\nfunction _addLayerEvent($canvas, data, layer, eventName) {\n\t// Use touch events if appropriate\n\t// eventName = _getMouseEventName(eventName);\n\t// Bind event to layer\n\tjCanvas.events[eventName]($canvas, data);\n\tlayer._event = true;\n}\n\n// Add a layer event that was explicitly declared in the layer's parameter map,\n// excluding events added implicitly (e.g. mousemove event required by draggable\n// layers)\nfunction _addExplicitLayerEvent($canvas, data, layer, eventName) {\n\t_addLayerEvent($canvas, data, layer, eventName);\n\tif (eventName === 'mouseover' || eventName === 'mouseout' || eventName === 'mousemove') {\n\t\tdata.redrawOnMousemove = true;\n\t}\n}\n\n// Enable drag support for this layer\nfunction _enableDrag($canvas, data, layer) {\n\tvar dragHelperEvents, eventName, i;\n\t// Only make layer draggable if necessary\n\tif (layer.draggable || layer.cursors) {\n\n\t\t// Organize helper events which enable drag support\n\t\tdragHelperEvents = ['mousedown', 'mousemove', 'mouseup'];\n\n\t\t// Bind each helper event to the canvas\n\t\tfor (i = 0; i < dragHelperEvents.length; i += 1) {\n\t\t\t// Use touch events if appropriate\n\t\t\teventName = dragHelperEvents[i];\n\t\t\t// Bind event\n\t\t\t_addLayerEvent($canvas, data, layer, eventName);\n\t\t}\n\t\t// Indicate that this layer has events bound to it\n\t\tlayer._event = true;\n\n\t}\n}\n\n// Update a layer property map if property is changed\nfunction _updateLayerName($canvas, data, layer, props) {\n\tvar nameMap = data.layer.names;\n\n\t// If layer name is being added, not changed\n\tif (!props) {\n\n\t\tprops = layer;\n\n\t} else {\n\n\t\t// Remove old layer name entry because layer name has changed\n\t\tif (props.name !== undefined && isString(layer.name) && layer.name !== props.name) {\n\t\t\tdelete nameMap[layer.name];\n\t\t}\n\n\t}\n\n\t// Add new entry to layer name map with new name\n\tif (isString(props.name)) {\n\t\tnameMap[props.name] = layer;\n\t}\n}\n\n// Create or update the data map for the given layer and group type\nfunction _updateLayerGroups($canvas, data, layer, props) {\n\tvar groupMap = data.layer.groups,\n\t\tgroup, groupName, g,\n\t\tindex, l;\n\n\t// If group name is not changing\n\tif (!props) {\n\n\t\tprops = layer;\n\n\t} else {\n\n\t\t// Remove layer from all of its associated groups\n\t\tif (props.groups !== undefined && layer.groups !== null) {\n\t\t\tfor (g = 0; g < layer.groups.length; g += 1) {\n\t\t\t\tgroupName = layer.groups[g];\n\t\t\t\tgroup = groupMap[groupName];\n\t\t\t\tif (group) {\n\t\t\t\t\t// Remove layer from its old layer group entry\n\t\t\t\t\tfor (l = 0; l < group.length; l += 1) {\n\t\t\t\t\t\tif (group[l] === layer) {\n\t\t\t\t\t\t\t// Keep track of the layer's initial index\n\t\t\t\t\t\t\tindex = l;\n\t\t\t\t\t\t\t// Remove layer once found\n\t\t\t\t\t\t\tgroup.splice(l, 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Remove layer group entry if group is empty\n\t\t\t\t\tif (group.length === 0) {\n\t\t\t\t\t\tdelete groupMap[groupName];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// Add layer to new group if a new group name is given\n\tif (props.groups !== undefined && props.groups !== null) {\n\n\t\tfor (g = 0; g < props.groups.length; g += 1) {\n\n\t\t\tgroupName = props.groups[g];\n\n\t\t\tgroup = groupMap[groupName];\n\t\t\tif (!group) {\n\t\t\t\t// Create new group entry if it doesn't exist\n\t\t\t\tgroup = groupMap[groupName] = [];\n\t\t\t\tgroup.name = groupName;\n\t\t\t}\n\t\t\tif (index === undefined) {\n\t\t\t\t// Add layer to end of group unless otherwise stated\n\t\t\t\tindex = group.length;\n\t\t\t}\n\t\t\t// Add layer to its new layer group\n\t\t\tgroup.splice(index, 0, layer);\n\n\t\t}\n\n\t}\n}\n\n// Get event hooks object for the first selected canvas\n$.fn.getEventHooks = function getEventHooks() {\n\tvar $canvases = this, canvas, data,\n\t\teventHooks = {};\n\n\tif ($canvases.length !== 0) {\n\t\tcanvas = $canvases[0];\n\t\tdata = _getCanvasData(canvas);\n\t\teventHooks = data.eventHooks;\n\t}\n\treturn eventHooks;\n};\n\n// Set event hooks for the selected canvases\n$.fn.setEventHooks = function setEventHooks(eventHooks) {\n\tvar $canvases = this, e,\n\t\tdata;\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tdata = _getCanvasData($canvases[e]);\n\t\textendObject(data.eventHooks, eventHooks);\n\t}\n\treturn $canvases;\n};\n\n// Get jCanvas layers array\n$.fn.getLayers = function getLayers(callback) {\n\tvar $canvases = this, canvas, data,\n\t\tlayers, layer, l,\n\t\tmatching = [];\n\n\tif ($canvases.length !== 0) {\n\n\t\tcanvas = $canvases[0];\n\t\tdata = _getCanvasData(canvas);\n\t\t// Retrieve layers array for this canvas\n\t\tlayers = data.layers;\n\n\t\t// If a callback function is given\n\t\tif (isFunction(callback)) {\n\n\t\t\t// Filter the layers array using the callback\n\t\t\tfor (l = 0; l < layers.length; l += 1) {\n\t\t\t\tlayer = layers[l];\n\t\t\t\tif (callback.call(canvas, layer)) {\n\t\t\t\t\t// Add layer to array of matching layers if test passes\n\t\t\t\t\tmatching.push(layer);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\t// Otherwise, get all layers\n\n\t\t\tmatching = layers;\n\n\t\t}\n\n\t}\n\treturn matching;\n};\n\n// Get a single jCanvas layer object\n$.fn.getLayer = function getLayer(layerId) {\n\tvar $canvases = this, canvas,\n\t\tdata, layers, layer, l,\n\t\tidType;\n\n\tif ($canvases.length !== 0) {\n\n\t\tcanvas = $canvases[0];\n\t\tdata = _getCanvasData(canvas);\n\t\tlayers = data.layers;\n\t\tidType = typeOf(layerId);\n\n\t\tif (layerId && layerId.layer) {\n\n\t\t\t// Return the actual layer object if given\n\t\t\tlayer = layerId;\n\n\t\t} else if (idType === 'number') {\n\n\t\t\t// Retrieve the layer using the given index\n\n\t\t\t// Allow for negative indices\n\t\t\tif (layerId < 0) {\n\t\t\t\tlayerId = layers.length + layerId;\n\t\t\t}\n\t\t\t// Get layer with the given index\n\t\t\tlayer = layers[layerId];\n\n\t\t} else if (idType === 'regexp') {\n\n\t\t\t// Get layer with the name that matches the given regex\n\t\t\tfor (l = 0; l < layers.length; l += 1) {\n\t\t\t\t// Check if layer matches name\n\t\t\t\tif (isString(layers[l].name) && layers[l].name.match(layerId)) {\n\t\t\t\t\tlayer = layers[l];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Get layer with the given name\n\t\t\tlayer = data.layer.names[layerId];\n\n\t\t}\n\n\t}\n\treturn layer;\n};\n\n// Get all layers in the given group\n$.fn.getLayerGroup = function getLayerGroup(groupId) {\n\tvar $canvases = this, canvas, data,\n\t\tgroups, groupName, group,\n\t\tidType = typeOf(groupId);\n\n\tif ($canvases.length !== 0) {\n\n\t\tcanvas = $canvases[0];\n\n\t\tif (idType === 'array') {\n\n\t\t\t// Return layer group if given\n\t\t\tgroup = groupId;\n\n\t\t} else if (idType === 'regexp') {\n\n\t\t\t// Get canvas data\n\t\t\tdata = _getCanvasData(canvas);\n\t\t\tgroups = data.layer.groups;\n\t\t\t// Loop through all layers groups for this canvas\n\t\t\tfor (groupName in groups) {\n\t\t\t\t// Find a group whose name matches the given regex\n\t\t\t\tif (groupName.match(groupId)) {\n\t\t\t\t\tgroup = groups[groupName];\n\t\t\t\t\t// Stop after finding the first matching group\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Find layer group with the given group name\n\t\t\tdata = _getCanvasData(canvas);\n\t\t\tgroup = data.layer.groups[groupId];\n\t\t}\n\n\t}\n\treturn group;\n};\n\n// Get index of layer in layers array\n$.fn.getLayerIndex = function getLayerIndex(layerId) {\n\tvar $canvases = this,\n\t\tlayers = $canvases.getLayers(),\n\t\tlayer = $canvases.getLayer(layerId);\n\n\treturn inArray(layer, layers);\n};\n\n// Set properties of a layer\n$.fn.setLayer = function setLayer(layerId, props) {\n\tvar $canvases = this, $canvas, e,\n\t\tdata, layer,\n\t\tpropName, propValue, propType;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t$canvas = $($canvases[e]);\n\t\tdata = _getCanvasData($canvases[e]);\n\n\t\tlayer = $($canvases[e]).getLayer(layerId);\n\t\tif (layer) {\n\n\t\t\t// Update layer property maps\n\t\t\t_updateLayerName($canvas, data, layer, props);\n\t\t\t_updateLayerGroups($canvas, data, layer, props);\n\n\t\t\t_coerceNumericProps(props);\n\n\t\t\t// Merge properties with layer\n\t\t\tfor (propName in props) {\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(props, propName)) {\n\t\t\t\t\tpropValue = props[propName];\n\t\t\t\t\tpropType = typeOf(propValue);\n\t\t\t\t\tif (propType === 'object' && isPlainObject(propValue)) {\n\t\t\t\t\t\t// Clone objects\n\t\t\t\t\t\tlayer[propName] = extendObject({}, propValue);\n\t\t\t\t\t\t_coerceNumericProps(layer[propName]);\n\t\t\t\t\t} else if (propType === 'array') {\n\t\t\t\t\t\t// Clone arrays\n\t\t\t\t\t\tlayer[propName] = propValue.slice(0);\n\t\t\t\t\t} else if (propType === 'string') {\n\t\t\t\t\t\tif (propValue.indexOf('+=') === 0) {\n\t\t\t\t\t\t\t// Increment numbers prefixed with +=\n\t\t\t\t\t\t\tlayer[propName] += parseFloat(propValue.substr(2));\n\t\t\t\t\t\t} else if (propValue.indexOf('-=') === 0) {\n\t\t\t\t\t\t\t// Decrement numbers prefixed with -=\n\t\t\t\t\t\t\tlayer[propName] -= parseFloat(propValue.substr(2));\n\t\t\t\t\t\t} else if (!isNaN(propValue) && isNumeric(propValue) && propName !== 'text') {\n\t\t\t\t\t\t\t// Convert numeric values as strings to numbers\n\t\t\t\t\t\t\tlayer[propName] = parseFloat(propValue);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Otherwise, set given string value\n\t\t\t\t\t\t\tlayer[propName] = propValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Otherwise, set given value\n\t\t\t\t\t\tlayer[propName] = propValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update layer events\n\t\t\t_addLayerEvents($canvas, data, layer);\n\t\t\t_enableDrag($canvas, data, layer);\n\n\t\t\t// If layer's properties were changed\n\t\t\tif ($.isEmptyObject(props) === false) {\n\t\t\t\t_triggerLayerEvent($canvas, data, layer, 'change', props);\n\t\t\t}\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Set properties of all layers (optionally filtered by a callback)\n$.fn.setLayers = function setLayers(props, callback) {\n\tvar $canvases = this, $canvas, e,\n\t\tlayers, l;\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t$canvas = $($canvases[e]);\n\n\t\tlayers = $canvas.getLayers(callback);\n\t\t// Loop through all layers\n\t\tfor (l = 0; l < layers.length; l += 1) {\n\t\t\t// Set properties of each layer\n\t\t\t$canvas.setLayer(layers[l], props);\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Set properties of all layers in the given group\n$.fn.setLayerGroup = function setLayerGroup(groupId, props) {\n\tvar $canvases = this, $canvas, e,\n\t\tgroup, l;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t// Get layer group\n\t\t$canvas = $($canvases[e]);\n\n\t\tgroup = $canvas.getLayerGroup(groupId);\n\t\t// If group exists\n\t\tif (group) {\n\n\t\t\t// Loop through layers in group\n\t\t\tfor (l = 0; l < group.length; l += 1) {\n\t\t\t\t// Merge given properties with layer\n\t\t\t\t$canvas.setLayer(group[l], props);\n\t\t\t}\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Move a layer to the given index in the layers array\n$.fn.moveLayer = function moveLayer(layerId, index) {\n\tvar $canvases = this, $canvas, e,\n\t\tdata, layers, layer;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t$canvas = $($canvases[e]);\n\t\tdata = _getCanvasData($canvases[e]);\n\n\t\t// Retrieve layers array and desired layer\n\t\tlayers = data.layers;\n\t\tlayer = $canvas.getLayer(layerId);\n\t\tif (layer) {\n\n\t\t\t// Ensure layer index is accurate\n\t\t\tlayer.index = inArray(layer, layers);\n\n\t\t\t// Remove layer from its current placement\n\t\t\tlayers.splice(layer.index, 1);\n\t\t\t// Add layer in its new placement\n\t\t\tlayers.splice(index, 0, layer);\n\n\t\t\t// Handle negative indices\n\t\t\tif (index < 0) {\n\t\t\t\tindex = layers.length + index;\n\t\t\t}\n\t\t\t// Update layer's stored index\n\t\t\tlayer.index = index;\n\n\t\t\t_triggerLayerEvent($canvas, data, layer, 'move');\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Remove a jCanvas layer\n$.fn.removeLayer = function removeLayer(layerId) {\n\tvar $canvases = this, $canvas, e, data,\n\t\tlayers, layer;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t$canvas = $($canvases[e]);\n\t\tdata = _getCanvasData($canvases[e]);\n\n\t\t// Retrieve layers array and desired layer\n\t\tlayers = $canvas.getLayers();\n\t\tlayer = $canvas.getLayer(layerId);\n\t\t// Remove layer if found\n\t\tif (layer) {\n\n\t\t\t// Ensure layer index is accurate\n\t\t\tlayer.index = inArray(layer, layers);\n\t\t\t// Remove layer and allow it to be re-added later\n\t\t\tlayers.splice(layer.index, 1);\n\t\t\tdelete layer._layer;\n\n\t\t\t// Update layer name map\n\t\t\t_updateLayerName($canvas, data, layer, {\n\t\t\t\tname: null\n\t\t\t});\n\t\t\t// Update layer group map\n\t\t\t_updateLayerGroups($canvas, data, layer, {\n\t\t\t\tgroups: null\n\t\t\t});\n\n\t\t\t// Trigger 'remove' event\n\t\t\t_triggerLayerEvent($canvas, data, layer, 'remove');\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Remove all layers\n$.fn.removeLayers = function removeLayers(callback) {\n\tvar $canvases = this, $canvas, e,\n\t\tdata, layers, layer, l;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t$canvas = $($canvases[e]);\n\t\tdata = _getCanvasData($canvases[e]);\n\t\tlayers = $canvas.getLayers(callback).slice(0);\n\t\t// Remove all layers individually\n\t\tfor (l = 0; l < layers.length; l += 1) {\n\t\t\tlayer = layers[l];\n\t\t\t$canvas.removeLayer(layer);\n\t\t}\n\t\t// Update layer maps\n\t\tdata.layer.names = {};\n\t\tdata.layer.groups = {};\n\t}\n\treturn $canvases;\n};\n\n// Remove all layers in the group with the given ID\n$.fn.removeLayerGroup = function removeLayerGroup(groupId) {\n\tvar $canvases = this, $canvas, e, group, l;\n\n\tif (groupId !== undefined) {\n\t\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t\t$canvas = $($canvases[e]);\n\n\t\t\tgroup = $canvas.getLayerGroup(groupId);\n\t\t\t// Remove layer group using given group name\n\t\t\tif (group) {\n\n\t\t\t\t// Clone groups array\n\t\t\t\tgroup = group.slice(0);\n\n\t\t\t\t// Loop through layers in group\n\t\t\t\tfor (l = 0; l < group.length; l += 1) {\n\t\t\t\t\t$canvas.removeLayer(group[l]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Add an existing layer to a layer group\n$.fn.addLayerToGroup = function addLayerToGroup(layerId, groupName) {\n\tvar $canvases = this, $canvas, e,\n\t\tlayer, groups = [groupName];\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t$canvas = $($canvases[e]);\n\t\tlayer = $canvas.getLayer(layerId);\n\n\t\t// If layer is not already in group\n\t\tif (layer.groups) {\n\t\t\t// Clone groups list\n\t\t\tgroups = layer.groups.slice(0);\n\t\t\t// If layer is not already in group\n\t\t\tif (inArray(groupName, layer.groups) === -1) {\n\t\t\t\t// Add layer to group\n\t\t\t\tgroups.push(groupName);\n\t\t\t}\n\t\t}\n\t\t// Update layer group maps\n\t\t$canvas.setLayer(layer, {\n\t\t\tgroups: groups\n\t\t});\n\n\t}\n\treturn $canvases;\n};\n\n// Remove an existing layer from a layer group\n$.fn.removeLayerFromGroup = function removeLayerFromGroup(layerId, groupName) {\n\tvar $canvases = this, $canvas, e,\n\t\tlayer, groups = [],\n\t\tindex;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t$canvas = $($canvases[e]);\n\t\tlayer = $canvas.getLayer(layerId);\n\n\t\tif (layer.groups) {\n\n\t\t\t// Find index of layer in group\n\t\t\tindex = inArray(groupName, layer.groups);\n\n\t\t\t// If layer is in group\n\t\t\tif (index !== -1) {\n\n\t\t\t\t// Clone groups list\n\t\t\t\tgroups = layer.groups.slice(0);\n\n\t\t\t\t// Remove layer from group\n\t\t\t\tgroups.splice(index, 1);\n\n\t\t\t\t// Update layer group maps\n\t\t\t\t$canvas.setLayer(layer, {\n\t\t\t\t\tgroups: groups\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\treturn $canvases;\n};\n\n// Get topmost layer that intersects with event coordinates\nfunction _getIntersectingLayer(data) {\n\tvar layer, i,\n\t\tmask, m;\n\n\t// Store the topmost layer\n\tlayer = null;\n\n\t// Get the topmost layer whose visible area intersects event coordinates\n\tfor (i = data.intersecting.length - 1; i >= 0; i -= 1) {\n\n\t\t// Get current layer\n\t\tlayer = data.intersecting[i];\n\n\t\t// If layer has previous masks\n\t\tif (layer._masks) {\n\n\t\t\t// Search previous masks to ensure\n\t\t\t// layer is visible at event coordinates\n\t\t\tfor (m = layer._masks.length - 1; m >= 0; m -= 1) {\n\t\t\t\tmask = layer._masks[m];\n\t\t\t\t// If mask does not intersect event coordinates\n\t\t\t\tif (!mask.intersects) {\n\t\t\t\t\t// Indicate that the mask does not\n\t\t\t\t\t// intersect event coordinates\n\t\t\t\t\tlayer.intersects = false;\n\t\t\t\t\t// Stop searching previous masks\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// If event coordinates intersect all previous masks\n\t\t\t// and layer is not intangible\n\t\t\tif (layer.intersects && !layer.intangible) {\n\t\t\t\t// Stop searching for topmost layer\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t}\n\t// If resulting layer is intangible\n\tif (layer && layer.intangible) {\n\t\t// Cursor does not intersect this layer\n\t\tlayer = null;\n\t}\n\treturn layer;\n}\n\n// Draw individual layer (internal)\nfunction _drawLayer($canvas, ctx, layer, nextLayerIndex) {\n\tif (layer && layer.visible && layer._method) {\n\t\tif (nextLayerIndex) {\n\t\t\tlayer._next = nextLayerIndex;\n\t\t} else {\n\t\t\tlayer._next = null;\n\t\t}\n\t\t// If layer is an object, call its respective method\n\t\tif (layer._method) {\n\t\t\tlayer._method.call($canvas, layer);\n\t\t}\n\t}\n}\n\n// Handle dragging of the currently-dragged layer\nfunction _handleLayerDrag($canvas, data, eventType) {\n\tvar layers, layer, l,\n\t\tdrag, dragGroups,\n\t\tgroup, groupName, g,\n\t\tnewX, newY;\n\n\tdrag = data.drag;\n\tlayer = drag.layer;\n\tdragGroups = (layer && layer.dragGroups) || [];\n\tlayers = data.layers;\n\n\tif (eventType === 'mousemove' || eventType === 'touchmove') {\n\t\t// Detect when user is currently dragging layer\n\n\t\tif (!drag.dragging) {\n\t\t\t// Detect when user starts dragging layer\n\n\t\t\t// Signify that a layer on the canvas is being dragged\n\t\t\tdrag.dragging = true;\n\t\t\tlayer.dragging = true;\n\n\t\t\t// Optionally bring layer to front when drag starts\n\t\t\tif (layer.bringToFront) {\n\t\t\t\t// Remove layer from its original position\n\t\t\t\tlayers.splice(layer.index, 1);\n\t\t\t\t// Bring layer to front\n\t\t\t\t// push() returns the new array length\n\t\t\t\tlayer.index = layers.push(layer);\n\t\t\t}\n\n\t\t\t// Set drag properties for this layer\n\t\t\tlayer._startX = layer.x;\n\t\t\tlayer._startY = layer.y;\n\t\t\tlayer._endX = layer._eventX;\n\t\t\tlayer._endY = layer._eventY;\n\n\t\t\t// Trigger dragstart event\n\t\t\t_triggerLayerEvent($canvas, data, layer, 'dragstart');\n\n\t\t}\n\n\t\tif (drag.dragging) {\n\n\t\t\t// Calculate position after drag\n\t\t\tnewX = layer._eventX - (layer._endX - layer._startX);\n\t\t\tnewY = layer._eventY - (layer._endY - layer._startY);\n\t\t\tif (layer.updateDragX) {\n\t\t\t\tnewX = layer.updateDragX.call($canvas[0], layer, newX);\n\t\t\t}\n\t\t\tif (layer.updateDragY) {\n\t\t\t\tnewY = layer.updateDragY.call($canvas[0], layer, newY);\n\t\t\t}\n\t\t\tlayer.dx = newX - layer.x;\n\t\t\tlayer.dy = newY - layer.y;\n\t\t\tif (layer.restrictDragToAxis !== 'y') {\n\t\t\t\tlayer.x = newX;\n\t\t\t}\n\t\t\tif (layer.restrictDragToAxis !== 'x') {\n\t\t\t\tlayer.y = newY;\n\t\t\t}\n\n\t\t\t// Trigger drag event\n\t\t\t_triggerLayerEvent($canvas, data, layer, 'drag');\n\n\t\t\t// Move groups with layer on drag\n\t\t\tfor (g = 0; g < dragGroups.length; g += 1) {\n\n\t\t\t\tgroupName = dragGroups[g];\n\t\t\t\tgroup = data.layer.groups[groupName];\n\t\t\t\tif (layer.groups && group) {\n\n\t\t\t\t\tfor (l = 0; l < group.length; l += 1) {\n\t\t\t\t\t\tif (group[l] !== layer) {\n\t\t\t\t\t\t\tif (layer.restrictDragToAxis !== 'y' && group[l].restrictDragToAxis !== 'y') {\n\t\t\t\t\t\t\t\tgroup[l].x += layer.dx;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (layer.restrictDragToAxis !== 'x' && group[l].restrictDragToAxis !== 'x') {\n\t\t\t\t\t\t\t\tgroup[l].y += layer.dy;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else if (eventType === 'mouseup' || eventType === 'touchend') {\n\t\t// Detect when user stops dragging layer\n\n\t\tif (drag.dragging) {\n\t\t\tlayer.dragging = false;\n\t\t\tdrag.dragging = false;\n\t\t\tdata.redrawOnMousemove = data.originalRedrawOnMousemove;\n\t\t\t// Trigger dragstop event\n\t\t\t_triggerLayerEvent($canvas, data, layer, 'dragstop');\n\t\t}\n\n\t\t// Cancel dragging\n\t\tdata.drag = {};\n\n\t}\n}\n\n\n// List of CSS3 cursors that need to be prefixed\ncss.cursors = ['grab', 'grabbing', 'zoom-in', 'zoom-out'];\n\n// Function to detect vendor prefix\n// Modified version of David Walsh's implementation\n// https://davidwalsh.name/vendor-prefix\ncss.prefix = (function () {\n\tvar styles = getComputedStyle(document.documentElement, ''),\n\t\tpre = (arraySlice\n\t\t\t.call(styles)\n\t\t\t.join('')\n\t\t\t.match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])\n\t\t)[1];\n\treturn '-' + pre + '-';\n})();\n\n// Set cursor on canvas\nfunction _setCursor($canvas, layer, eventType) {\n\tvar cursor;\n\tif (layer.cursors) {\n\t\t// Retrieve cursor from cursors object if it exists\n\t\tcursor = layer.cursors[eventType];\n\t}\n\t// Prefix any CSS3 cursor\n\tif ($.inArray(cursor, css.cursors) !== -1) {\n\t\tcursor = css.prefix + cursor;\n\t}\n\t// If cursor is defined\n\tif (cursor) {\n\t\t// Set canvas cursor\n\t\t$canvas.css({\n\t\t\tcursor: cursor\n\t\t});\n\t}\n}\n\n// Reset cursor on canvas\nfunction _resetCursor($canvas, data) {\n\t$canvas.css({\n\t\tcursor: data.cursor\n\t});\n}\n\n// Run the given event callback with the given arguments\nfunction _runEventCallback($canvas, layer, eventType, callbacks, arg) {\n\t// Prevent callback from firing recursively\n\tif (callbacks[eventType] && layer._running && !layer._running[eventType]) {\n\t\t// Signify the start of callback execution for this event\n\t\tlayer._running[eventType] = true;\n\t\t// Run event callback with the given arguments\n\t\tcallbacks[eventType].call($canvas[0], layer, arg);\n\t\t// Signify the end of callback execution for this event\n\t\tlayer._running[eventType] = false;\n\t}\n}\n\n// Determine if the given layer can \"legally\" fire the given event\nfunction _layerCanFireEvent(layer, eventType) {\n\t// If events are disable and if\n\t// layer is tangible or event is not tangible\n\treturn (!layer.disableEvents &&\n\t\t(!layer.intangible || $.inArray(eventType, tangibleEvents) === -1));\n}\n\n// Trigger the given event on the given layer\nfunction _triggerLayerEvent($canvas, data, layer, eventType, arg) {\n\t// If layer can legally fire this event type\n\tif (_layerCanFireEvent(layer, eventType)) {\n\n\t\t// Do not set a custom cursor on layer mouseout\n\t\tif (eventType !== 'mouseout') {\n\t\t\t// Update cursor if one is defined for this event\n\t\t\t_setCursor($canvas, layer, eventType);\n\t\t}\n\n\t\t// Trigger the user-defined event callback\n\t\t_runEventCallback($canvas, layer, eventType, layer, arg);\n\t\t// Trigger the canvas-bound event hook\n\t\t_runEventCallback($canvas, layer, eventType, data.eventHooks, arg);\n\t\t// Trigger the global event hook\n\t\t_runEventCallback($canvas, layer, eventType, jCanvas.eventHooks, arg);\n\n\t}\n}\n\n// Manually trigger a layer event\n$.fn.triggerLayerEvent = function (layer, eventType) {\n\tvar $canvases = this, $canvas, e,\n\t\tdata;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t$canvas = $($canvases[e]);\n\t\tdata = _getCanvasData($canvases[e]);\n\t\tlayer = $canvas.getLayer(layer);\n\t\tif (layer) {\n\t\t\t_triggerLayerEvent($canvas, data, layer, eventType);\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Draw layer with the given ID\n$.fn.drawLayer = function drawLayer(layerId) {\n\tvar $canvases = this, e, ctx,\n\t\t$canvas, layer;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t$canvas = $($canvases[e]);\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\t\t\tlayer = $canvas.getLayer(layerId);\n\t\t\t_drawLayer($canvas, ctx, layer);\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Draw all layers (or, if given, only layers starting at an index)\n$.fn.drawLayers = function drawLayers(args) {\n\tvar $canvases = this, $canvas, e, ctx,\n\t\t// Internal parameters for redrawing the canvas\n\t\tparams = args || {},\n\t\t// Other variables\n\t\tlayers, layer, lastLayer, l, index, lastIndex,\n\t\tdata, eventCache, eventType, isImageLayer;\n\n\t// The layer index from which to start redrawing the canvas\n\tindex = params.index;\n\tif (!index) {\n\t\tindex = 0;\n\t}\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t$canvas = $($canvases[e]);\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tdata = _getCanvasData($canvases[e]);\n\n\t\t\t// Clear canvas first unless otherwise directed\n\t\t\tif (params.clear !== false) {\n\t\t\t\t$canvas.clearCanvas();\n\t\t\t}\n\n\t\t\t// If a completion callback was provided, save it to the canvas data\n\t\t\t// store so that the function can be passed to drawLayers() again\n\t\t\t// after any image layers have loaded\n\t\t\tif (params.complete) {\n\t\t\t\tdata.drawLayersComplete = params.complete;\n\t\t\t}\n\n\t\t\t// Cache the layers array\n\t\t\tlayers = data.layers;\n\n\t\t\t// Draw layers from first to last (bottom to top)\n\t\t\tfor (l = index; l < layers.length; l += 1) {\n\t\t\t\tlayer = layers[l];\n\n\t\t\t\t// Ensure layer index is up-to-date\n\t\t\t\tlayer.index = l;\n\n\t\t\t\t// Prevent any one event from firing excessively\n\t\t\t\tif (params.resetFire) {\n\t\t\t\t\tlayer._fired = false;\n\t\t\t\t}\n\t\t\t\t// Draw layer\n\t\t\t\t_drawLayer($canvas, ctx, layer, l + 1);\n\t\t\t\t// Store list of previous masks for each layer\n\t\t\t\tlayer._masks = data.transforms.masks.slice(0);\n\n\t\t\t\t// Allow image layers to load before drawing successive layers\n\t\t\t\tif (layer._method === $.fn.drawImage && layer.visible) {\n\t\t\t\t\tisImageLayer = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// If layer is an image layer\n\t\t\tif (isImageLayer) {\n\t\t\t\t// Stop and wait for drawImage() to resume drawLayers()\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Store the latest\n\t\t\tlastIndex = l;\n\n\t\t\t// Run completion callback (if provided) once all layers have drawn\n\t\t\tif (params.complete) {\n\t\t\t\tparams.complete.call($canvases[e]);\n\t\t\t\tdelete data.drawLayersComplete;\n\t\t\t}\n\n\t\t\t// Get first layer that intersects with event coordinates\n\t\t\tlayer = _getIntersectingLayer(data);\n\n\t\t\teventCache = data.event;\n\t\t\teventType = eventCache.type;\n\n\t\t\t// If jCanvas has detected a dragstart\n\t\t\tif (data.drag.layer) {\n\t\t\t\t// Handle dragging of layer\n\t\t\t\t_handleLayerDrag($canvas, data, eventType);\n\t\t\t}\n\n\t\t\t// Manage mouseout event\n\t\t\tlastLayer = data.lastIntersected;\n\t\t\tif (lastLayer !== null && layer !== lastLayer && lastLayer._hovered && !lastLayer._fired && !data.drag.dragging) {\n\n\t\t\t\tdata.lastIntersected = null;\n\t\t\t\tlastLayer._fired = true;\n\t\t\t\tlastLayer._hovered = false;\n\t\t\t\t_triggerLayerEvent($canvas, data, lastLayer, 'mouseout');\n\t\t\t\t_resetCursor($canvas, data);\n\n\t\t\t}\n\n\t\t\tif (layer) {\n\n\t\t\t\t// Use mouse event callbacks if no touch event callbacks are given\n\t\t\t\tif (!layer[eventType]) {\n\t\t\t\t\teventType = _getMouseEventName(eventType);\n\t\t\t\t}\n\n\t\t\t\t// Check events for intersecting layer\n\t\t\t\tif (layer._event && layer.intersects) {\n\n\t\t\t\t\tdata.lastIntersected = layer;\n\n\t\t\t\t\t// Detect mouseover events\n\t\t\t\t\tif ((layer.mouseover || layer.mouseout || layer.cursors) && !data.drag.dragging) {\n\n\t\t\t\t\t\tif (!layer._hovered && !layer._fired) {\n\n\t\t\t\t\t\t\t// Prevent events from firing excessively\n\t\t\t\t\t\t\tlayer._fired = true;\n\t\t\t\t\t\t\tlayer._hovered = true;\n\t\t\t\t\t\t\t_triggerLayerEvent($canvas, data, layer, 'mouseover');\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Detect any other mouse event\n\t\t\t\t\tif (!layer._fired) {\n\n\t\t\t\t\t\t// Prevent event from firing twice unintentionally\n\t\t\t\t\t\tlayer._fired = true;\n\t\t\t\t\t\teventCache.type = null;\n\n\t\t\t\t\t\t_triggerLayerEvent($canvas, data, layer, eventType);\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Use the mousedown event to start drag\n\t\t\t\t\tif (layer.draggable && !layer.disableEvents && (eventType === 'mousedown' || eventType === 'touchstart')) {\n\n\t\t\t\t\t\t// Keep track of drag state\n\t\t\t\t\t\tdata.drag.layer = layer;\n\t\t\t\t\t\tdata.originalRedrawOnMousemove = data.redrawOnMousemove;\n\t\t\t\t\t\tdata.redrawOnMousemove = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// If cursor is not intersecting with any layer\n\t\t\tif (layer === null && !data.drag.dragging) {\n\t\t\t\t// Reset cursor to previous state\n\t\t\t\t_resetCursor($canvas, data);\n\t\t\t}\n\n\t\t\t// If the last layer has been drawn\n\t\t\tif (lastIndex === layers.length) {\n\n\t\t\t\t// Reset list of intersecting layers\n\t\t\t\tdata.intersecting.length = 0;\n\t\t\t\t// Reset transformation stack\n\t\t\t\tdata.transforms = _cloneTransforms(baseTransforms);\n\t\t\t\tdata.savedTransforms.length = 0;\n\n\t\t\t}\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Add a jCanvas layer (internal)\nfunction _addLayer(canvas, params, args, method) {\n\tvar $canvas, data,\n\t\tlayers, layer = (params._layer ? args : params);\n\n\t// Store arguments object for later use\n\tparams._args = args;\n\n\t// Convert all draggable drawings into jCanvas layers\n\tif (params.draggable || params.dragGroups) {\n\t\tparams.layer = true;\n\t\tparams.draggable = true;\n\t}\n\n\t// Determine the layer's type using the available information\n\tif (!params._method) {\n\t\tif (method) {\n\t\t\tparams._method = method;\n\t\t} else if (params.method) {\n\t\t\tparams._method = $.fn[params.method];\n\t\t} else if (params.type) {\n\t\t\tparams._method = $.fn[maps.drawings[params.type]];\n\t\t}\n\t}\n\n\t// If layer hasn't been added yet\n\tif (params.layer && !params._layer) {\n\t\t// Add layer to canvas\n\n\t\t$canvas = $(canvas);\n\n\t\tdata = _getCanvasData(canvas);\n\t\tlayers = data.layers;\n\n\t\t// Do not add duplicate layers of same name\n\t\tif (layer.name === null || (isString(layer.name) && data.layer.names[layer.name] === undefined)) {\n\n\t\t\t// Convert number properties to numbers\n\t\t\t_coerceNumericProps(params);\n\n\t\t\t// Ensure layers are unique across canvases by cloning them\n\t\t\tlayer = new jCanvasObject(params);\n\t\t\tlayer.canvas = canvas;\n\t\t\t// Indicate that this is a layer for future checks\n\t\t\tlayer.layer = true;\n\t\t\tlayer._layer = true;\n\t\t\tlayer._running = {};\n\t\t\t// If layer stores user-defined data\n\t\t\tif (layer.data !== null) {\n\t\t\t\t// Clone object\n\t\t\t\tlayer.data = extendObject({}, layer.data);\n\t\t\t} else {\n\t\t\t\t// Otherwise, create data object\n\t\t\t\tlayer.data = {};\n\t\t\t}\n\t\t\t// If layer stores a list of associated groups\n\t\t\tif (layer.groups !== null) {\n\t\t\t\t// Clone list\n\t\t\t\tlayer.groups = layer.groups.slice(0);\n\t\t\t} else {\n\t\t\t\t// Otherwise, create empty list\n\t\t\t\tlayer.groups = [];\n\t\t\t}\n\n\t\t\t// Update layer group maps\n\t\t\t_updateLayerName($canvas, data, layer);\n\t\t\t_updateLayerGroups($canvas, data, layer);\n\n\t\t\t// Check for any associated jCanvas events and enable them\n\t\t\t_addLayerEvents($canvas, data, layer);\n\n\t\t\t// Optionally enable drag-and-drop support and cursor support\n\t\t\t_enableDrag($canvas, data, layer);\n\n\t\t\t// Copy _event property to parameters object\n\t\t\tparams._event = layer._event;\n\n\t\t\t// Calculate width/height for text layers\n\t\t\tif (layer._method === $.fn.drawText) {\n\t\t\t\t$canvas.measureText(layer);\n\t\t\t}\n\n\t\t\t// Add layer to end of array if no index is specified\n\t\t\tif (layer.index === null) {\n\t\t\t\tlayer.index = layers.length;\n\t\t\t}\n\n\t\t\t// Add layer to layers array at specified index\n\t\t\tlayers.splice(layer.index, 0, layer);\n\n\t\t\t// Store layer on parameters object\n\t\t\tparams._args = layer;\n\n\t\t\t// Trigger an 'add' event\n\t\t\t_triggerLayerEvent($canvas, data, layer, 'add');\n\n\t\t}\n\n\t} else if (!params.layer) {\n\t\t_coerceNumericProps(params);\n\t}\n\n\treturn layer;\n}\n\n// Add a jCanvas layer\n$.fn.addLayer = function addLayer(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\tparams.layer = true;\n\t\t\t_addLayer($canvases[e], params, args);\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n/* Animation API */\n\n// Define properties used in both CSS and jCanvas\ncss.props = [\n\t'width',\n\t'height',\n\t'opacity',\n\t'lineHeight'\n];\ncss.propsObj = {};\n\n// Hide/show jCanvas/CSS properties so they can be animated using jQuery\nfunction _showProps(obj) {\n\tvar cssProp, p;\n\tfor (p = 0; p < css.props.length; p += 1) {\n\t\tcssProp = css.props[p];\n\t\tobj[cssProp] = obj['_' + cssProp];\n\t}\n}\nfunction _hideProps(obj, reset) {\n\tvar cssProp, p;\n\tfor (p = 0; p < css.props.length; p += 1) {\n\t\tcssProp = css.props[p];\n\t\t// Hide property using same name with leading underscore\n\t\tif (obj[cssProp] !== undefined) {\n\t\t\tobj['_' + cssProp] = obj[cssProp];\n\t\t\tcss.propsObj[cssProp] = true;\n\t\t\tif (reset) {\n\t\t\t\tdelete obj[cssProp];\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Evaluate property values that are functions\nfunction _parseEndValues(canvas, layer, endValues) {\n\tvar propName, propValue,\n\t\tsubPropName, subPropValue;\n\t// Loop through all properties in map of end values\n\tfor (propName in endValues) {\n\t\tif (Object.prototype.hasOwnProperty.call(endValues, propName)) {\n\t\t\tpropValue = endValues[propName];\n\t\t\t// If end value is function\n\t\t\tif (isFunction(propValue)) {\n\t\t\t\t// Call function and use its value as the end value\n\t\t\t\tendValues[propName] = propValue.call(canvas, layer, propName);\n\t\t\t}\n\t\t\t// If end value is an object\n\t\t\tif (typeOf(propValue) === 'object' && isPlainObject(propValue)) {\n\t\t\t\t// Prepare to animate properties in object\n\t\t\t\tfor (subPropName in propValue) {\n\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(propValue, subPropName)) {\n\t\t\t\t\t\tsubPropValue = propValue[subPropName];\n\t\t\t\t\t\t// Store property's start value at top-level of layer\n\t\t\t\t\t\tif (layer[propName] !== undefined) {\n\t\t\t\t\t\t\tlayer[propName + '.' + subPropName] = layer[propName][subPropName];\n\t\t\t\t\t\t\t// Store property's end value at top-level of end values map\n\t\t\t\t\t\t\tendValues[propName + '.' + subPropName] = subPropValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Delete sub-property of object as it's no longer needed\n\t\t\t\tdelete endValues[propName];\n\t\t\t}\n\t\t}\n\t}\n\treturn endValues;\n}\n\n// Remove sub-property aliases from layer object\nfunction _removeSubPropAliases(layer) {\n\tvar propName;\n\tfor (propName in layer) {\n\t\tif (Object.prototype.hasOwnProperty.call(layer, propName)) {\n\t\t\tif (propName.indexOf('.') !== -1) {\n\t\t\t\tdelete layer[propName];\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Convert a color value to an array of RGB values\nfunction _colorToRgbArray(color) {\n\tvar originalColor, elem,\n\t\trgb = [],\n\t\tmultiple = 1;\n\n\t// Deal with complete transparency\n\tif (color === 'transparent') {\n\t\tcolor = 'rgba(0, 0, 0, 0)';\n\t} else if (color.match(/^([a-z]+|#[0-9a-f]+)$/gi)) {\n\t\t// Deal with hexadecimal colors and color names\n\t\telem = document.head;\n\t\toriginalColor = elem.style.color;\n\t\telem.style.color = color;\n\t\tcolor = $.css(elem, 'color');\n\t\telem.style.color = originalColor;\n\t}\n\t// Parse RGB string\n\tif (color.match(/^rgb/gi)) {\n\t\trgb = color.match(/(\\d+(\\.\\d+)?)/gi);\n\t\t// Deal with RGB percentages\n\t\tif (color.match(/%/gi)) {\n\t\t\tmultiple = 2.55;\n\t\t}\n\t\trgb[0] *= multiple;\n\t\trgb[1] *= multiple;\n\t\trgb[2] *= multiple;\n\t\t// Ad alpha channel if given\n\t\tif (rgb[3] !== undefined) {\n\t\t\trgb[3] = parseFloat(rgb[3]);\n\t\t} else {\n\t\t\trgb[3] = 1;\n\t\t}\n\t}\n\treturn rgb;\n}\n\n// Animate a hex or RGB color\nfunction _animateColor(fx) {\n\tvar n = 3,\n\t\ti;\n\t// Only parse start and end colors once\n\tif (typeOf(fx.start) !== 'array') {\n\t\tfx.start = _colorToRgbArray(fx.start);\n\t\tfx.end = _colorToRgbArray(fx.end);\n\t}\n\tfx.now = [];\n\n\t// If colors are RGBA, animate transparency\n\tif (fx.start[3] !== 1 || fx.end[3] !== 1) {\n\t\tn = 4;\n\t}\n\n\t// Calculate current frame for red, green, blue, and alpha\n\tfor (i = 0; i < n; i += 1) {\n\t\tfx.now[i] = fx.start[i] + ((fx.end[i] - fx.start[i]) * fx.pos);\n\t\t// Only the red, green, and blue values must be integers\n\t\tif (i < 3) {\n\t\t\tfx.now[i] = round(fx.now[i]);\n\t\t}\n\t}\n\tif (fx.start[3] !== 1 || fx.end[3] !== 1) {\n\t\t// Only use RGBA if RGBA colors are given\n\t\tfx.now = 'rgba(' + fx.now.join(',') + ')';\n\t} else {\n\t\t// Otherwise, animate as solid colors\n\t\tfx.now.slice(0, 3);\n\t\tfx.now = 'rgb(' + fx.now.join(',') + ')';\n\t}\n\t// Animate colors for both canvas layers and DOM elements\n\tif (fx.elem.nodeName) {\n\t\tfx.elem.style[fx.prop] = fx.now;\n\t} else {\n\t\tfx.elem[fx.prop] = fx.now;\n\t}\n}\n\n// Animate jCanvas layer\n$.fn.animateLayer = function animateLayer() {\n\tvar $canvases = this, $canvas, e, ctx,\n\t\targs = arraySlice.call(arguments, 0),\n\t\tdata, layer, props;\n\n\t// Deal with all cases of argument placement\n\t/*\n\t\t0. layer name/index\n\t\t1. properties\n\t\t2. duration/options\n\t\t3. easing\n\t\t4. complete function\n\t\t5. step function\n\t*/\n\n\tif (typeOf(args[2]) === 'object') {\n\n\t\t// Accept an options object for animation\n\t\targs.splice(2, 0, args[2].duration || null);\n\t\targs.splice(3, 0, args[3].easing || null);\n\t\targs.splice(4, 0, args[4].complete || null);\n\t\targs.splice(5, 0, args[5].step || null);\n\n\t} else {\n\n\t\tif (args[2] === undefined) {\n\t\t\t// If object is the last argument\n\t\t\targs.splice(2, 0, null);\n\t\t\targs.splice(3, 0, null);\n\t\t\targs.splice(4, 0, null);\n\t\t} else if (isFunction(args[2])) {\n\t\t\t// If callback comes after object\n\t\t\targs.splice(2, 0, null);\n\t\t\targs.splice(3, 0, null);\n\t\t}\n\t\tif (args[3] === undefined) {\n\t\t\t// If duration is the last argument\n\t\t\targs[3] = null;\n\t\t\targs.splice(4, 0, null);\n\t\t} else if (isFunction(args[3])) {\n\t\t\t// If callback comes after duration\n\t\t\targs.splice(3, 0, null);\n\t\t}\n\n\t}\n\n\t// Run callback function when animation completes\n\tfunction complete($canvas, data, layer) {\n\n\t\treturn function () {\n\n\t\t\t_showProps(layer);\n\t\t\t_removeSubPropAliases(layer);\n\n\t\t\t// Prevent multiple redraw loops\n\t\t\tif (!data.animating || data.animated === layer) {\n\t\t\t\t// Redraw layers on last frame\n\t\t\t\t$canvas.drawLayers();\n\t\t\t}\n\n\t\t\t// Signify the end of an animation loop\n\t\t\tlayer._animating = false;\n\t\t\tdata.animating = false;\n\t\t\tdata.animated = null;\n\n\t\t\t// If callback is defined\n\t\t\tif (args[4]) {\n\t\t\t\t// Run callback at the end of the animation\n\t\t\t\targs[4].call($canvas[0], layer);\n\t\t\t}\n\n\t\t\t_triggerLayerEvent($canvas, data, layer, 'animateend');\n\n\t\t};\n\n\t}\n\n\t// Redraw layers on every frame of the animation\n\tfunction step($canvas, data, layer) {\n\n\t\treturn function (now, fx) {\n\t\t\tvar parts, propName, subPropName,\n\t\t\t\thidden = false;\n\n\t\t\t// If animated property has been hidden\n\t\t\tif (fx.prop[0] === '_') {\n\t\t\t\thidden = true;\n\t\t\t\t// Unhide property temporarily\n\t\t\t\tfx.prop = fx.prop.replace('_', '');\n\t\t\t\tlayer[fx.prop] = layer['_' + fx.prop];\n\t\t\t}\n\n\t\t\t// If animating property of sub-object\n\t\t\tif (fx.prop.indexOf('.') !== -1) {\n\t\t\t\tparts = fx.prop.split('.');\n\t\t\t\tpropName = parts[0];\n\t\t\t\tsubPropName = parts[1];\n\t\t\t\tif (layer[propName]) {\n\t\t\t\t\tlayer[propName][subPropName] = fx.now;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Throttle animation to improve efficiency\n\t\t\tif (layer._pos !== fx.pos) {\n\n\t\t\t\tlayer._pos = fx.pos;\n\n\t\t\t\t// Signify the start of an animation loop\n\t\t\t\tif (!layer._animating && !data.animating) {\n\t\t\t\t\tlayer._animating = true;\n\t\t\t\t\tdata.animating = true;\n\t\t\t\t\tdata.animated = layer;\n\t\t\t\t}\n\n\t\t\t\t// Prevent multiple redraw loops\n\t\t\t\tif (!data.animating || data.animated === layer) {\n\t\t\t\t\t// Redraw layers for every frame\n\t\t\t\t\t$canvas.drawLayers();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// If callback is defined\n\t\t\tif (args[5]) {\n\t\t\t\t// Run callback for each step of animation\n\t\t\t\targs[5].call($canvas[0], now, fx, layer);\n\t\t\t}\n\n\t\t\t_triggerLayerEvent($canvas, data, layer, 'animate', fx);\n\n\t\t\t// If property should be hidden during animation\n\t\t\tif (hidden) {\n\t\t\t\t// Hide property again\n\t\t\t\tfx.prop = '_' + fx.prop;\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t$canvas = $($canvases[e]);\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tdata = _getCanvasData($canvases[e]);\n\n\t\t\t// If a layer object was passed, use it the layer to be animated\n\t\t\tlayer = $canvas.getLayer(args[0]);\n\n\t\t\t// Ignore layers that are functions\n\t\t\tif (layer && layer._method !== $.fn.draw) {\n\n\t\t\t\t// Do not modify original object\n\t\t\t\tprops = extendObject({}, args[1]);\n\n\t\t\t\tprops = _parseEndValues($canvases[e], layer, props);\n\n\t\t\t\t// Bypass jQuery CSS Hooks for CSS properties (width, opacity, etc.)\n\t\t\t\t_hideProps(props, true);\n\t\t\t\t_hideProps(layer);\n\n\t\t\t\t// Fix for jQuery's vendor prefixing support, which affects how width/height/opacity are animated\n\t\t\t\tlayer.style = css.propsObj;\n\n\t\t\t\t// Animate layer\n\t\t\t\t$(layer).animate(props, {\n\t\t\t\t\tduration: args[2],\n\t\t\t\t\teasing: ($.easing[args[3]] ? args[3] : null),\n\t\t\t\t\t// When animation completes\n\t\t\t\t\tcomplete: complete($canvas, data, layer),\n\t\t\t\t\t// Redraw canvas for every animation frame\n\t\t\t\t\tstep: step($canvas, data, layer)\n\t\t\t\t});\n\t\t\t\t_triggerLayerEvent($canvas, data, layer, 'animatestart');\n\t\t\t}\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Animate all layers in a layer group\n$.fn.animateLayerGroup = function animateLayerGroup(groupId) {\n\tvar $canvases = this, $canvas, e,\n\t\targs = arraySlice.call(arguments, 0),\n\t\tgroup, l;\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t$canvas = $($canvases[e]);\n\t\tgroup = $canvas.getLayerGroup(groupId);\n\t\tif (group) {\n\n\t\t\t// Animate all layers in the group\n\t\t\tfor (l = 0; l < group.length; l += 1) {\n\n\t\t\t\t// Replace first argument with layer\n\t\t\t\targs[0] = group[l];\n\t\t\t\t$canvas.animateLayer.apply($canvas, args);\n\n\t\t\t}\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Delay layer animation by a given number of milliseconds\n$.fn.delayLayer = function delayLayer(layerId, duration) {\n\tvar $canvases = this, $canvas, e,\n\t\tdata, layer;\n\tduration = duration || 0;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t$canvas = $($canvases[e]);\n\t\tdata = _getCanvasData($canvases[e]);\n\t\tlayer = $canvas.getLayer(layerId);\n\t\t// If layer exists\n\t\tif (layer) {\n\t\t\t// Delay animation\n\t\t\t$(layer).delay(duration);\n\t\t\t_triggerLayerEvent($canvas, data, layer, 'delay');\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Delay animation all layers in a layer group\n$.fn.delayLayerGroup = function delayLayerGroup(groupId, duration) {\n\tvar $canvases = this, $canvas, e,\n\t\tgroup, layer, l;\n\tduration = duration || 0;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t$canvas = $($canvases[e]);\n\n\t\tgroup = $canvas.getLayerGroup(groupId);\n\t\t// Delay all layers in the group\n\t\tif (group) {\n\n\t\t\tfor (l = 0; l < group.length; l += 1) {\n\t\t\t\t// Delay each layer in the group\n\t\t\t\tlayer = group[l];\n\t\t\t\t$canvas.delayLayer(layer, duration);\n\t\t\t}\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Stop layer animation\n$.fn.stopLayer = function stopLayer(layerId, clearQueue) {\n\tvar $canvases = this, $canvas, e,\n\t\tdata, layer;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t$canvas = $($canvases[e]);\n\t\tdata = _getCanvasData($canvases[e]);\n\t\tlayer = $canvas.getLayer(layerId);\n\t\t// If layer exists\n\t\tif (layer) {\n\t\t\t// Stop animation\n\t\t\t$(layer).stop(clearQueue);\n\t\t\t_triggerLayerEvent($canvas, data, layer, 'stop');\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Stop animation of all layers in a layer group\n$.fn.stopLayerGroup = function stopLayerGroup(groupId, clearQueue) {\n\tvar $canvases = this, $canvas, e,\n\t\tgroup, layer, l;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t$canvas = $($canvases[e]);\n\n\t\tgroup = $canvas.getLayerGroup(groupId);\n\t\t// Stop all layers in the group\n\t\tif (group) {\n\n\t\t\tfor (l = 0; l < group.length; l += 1) {\n\t\t\t\t// Stop each layer in the group\n\t\t\t\tlayer = group[l];\n\t\t\t\t$canvas.stopLayer(layer, clearQueue);\n\t\t\t}\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Enable animation for color properties\nfunction _supportColorProps(props) {\n\tvar p;\n\tfor (p = 0; p < props.length; p += 1) {\n\t\t$.fx.step[props[p]] = _animateColor;\n\t}\n}\n\n// Enable animation for color properties\n_supportColorProps([\n\t'color',\n\t'backgroundColor',\n\t'borderColor',\n\t'borderTopColor',\n\t'borderRightColor',\n\t'borderBottomColor',\n\t'borderLeftColor',\n\t'fillStyle',\n\t'outlineColor',\n\t'strokeStyle',\n\t'shadowColor'\n]);\n\n/* Event API */\n\n// Map standard mouse events to touch events\nmaps.touchEvents = {\n\t'mousedown': 'touchstart',\n\t'mouseup': 'touchend',\n\t'mousemove': 'touchmove'\n};\n// Map standard touch events to mouse events\nmaps.mouseEvents = {\n\t'touchstart': 'mousedown',\n\t'touchend': 'mouseup',\n\t'touchmove': 'mousemove'\n};\n\n// Convert mouse event name to a corresponding touch event name (if possible)\nfunction _getTouchEventName(eventName) {\n\t// Detect touch event support\n\tif (maps.touchEvents[eventName]) {\n\t\teventName = maps.touchEvents[eventName];\n\t}\n\treturn eventName;\n}\n// Convert touch event name to a corresponding mouse event name\nfunction _getMouseEventName(eventName) {\n\tif (maps.mouseEvents[eventName]) {\n\t\teventName = maps.mouseEvents[eventName];\n\t}\n\treturn eventName;\n}\n\n// Bind event to jCanvas layer using standard jQuery events\nfunction _createEvent(eventName) {\n\n\tjCanvas.events[eventName] = function ($canvas, data) {\n\t\tvar helperEventName, touchEventName, eventCache;\n\n\t\t// Retrieve canvas's event cache\n\t\teventCache = data.event;\n\n\t\t// Both mouseover/mouseout events will be managed by a single mousemove event\n\t\thelperEventName = (eventName === 'mouseover' || eventName === 'mouseout') ? 'mousemove' : eventName;\n\t\ttouchEventName = _getTouchEventName(helperEventName);\n\n\t\tfunction eventCallback(event) {\n\t\t\t// Cache current mouse position and redraw layers\n\t\t\teventCache.x = event.offsetX;\n\t\t\teventCache.y = event.offsetY;\n\t\t\teventCache.type = helperEventName;\n\t\t\teventCache.event = event;\n\t\t\t// Redraw layers on every trigger of the event; don't redraw if at\n\t\t\t// least one layer is draggable and there are no layers with\n\t\t\t// explicit mouseover/mouseout/mousemove events\n\t\t\tif (event.type !== 'mousemove' || data.redrawOnMousemove || data.drag.dragging) {\n\t\t\t\t$canvas.drawLayers({\n\t\t\t\t\tresetFire: true\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Prevent default event behavior\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\t// Ensure the event is not bound more than once\n\t\tif (!data.events[helperEventName]) {\n\t\t\t// Bind one canvas event which handles all layer events of that type\n\t\t\tif (touchEventName !== helperEventName) {\n\t\t\t\t$canvas.bind(helperEventName + '.jCanvas ' + touchEventName + '.jCanvas', eventCallback);\n\t\t\t} else {\n\t\t\t\t$canvas.bind(helperEventName + '.jCanvas', eventCallback);\n\t\t\t}\n\t\t\t// Prevent this event from being bound twice\n\t\t\tdata.events[helperEventName] = true;\n\t\t}\n\t};\n}\nfunction _createEvents(eventNames) {\n\tvar n;\n\tfor (n = 0; n < eventNames.length; n += 1) {\n\t\t_createEvent(eventNames[n]);\n\t}\n}\n// Populate jCanvas events object with some standard events\n_createEvents([\n\t'click',\n\t'dblclick',\n\t'mousedown',\n\t'mouseup',\n\t'mousemove',\n\t'mouseover',\n\t'mouseout',\n\t'touchstart',\n\t'touchmove',\n\t'touchend',\n\t'pointerdown',\n\t'pointermove',\n\t'pointerup',\n\t'contextmenu'\n]);\n\n// Check if event fires when a drawing is drawn\nfunction _detectEvents(canvas, ctx, params) {\n\tvar layer, data, eventCache, intersects,\n\t\ttransforms, x, y, angle;\n\n\t// Use the layer object stored by the given parameters object\n\tlayer = params._args;\n\t// Canvas must have event bindings\n\tif (layer) {\n\n\t\tdata = _getCanvasData(canvas);\n\t\teventCache = data.event;\n\t\tif (eventCache.x !== null && eventCache.y !== null) {\n\t\t\t// Respect user-defined pixel ratio\n\t\t\tx = eventCache.x * data.pixelRatio;\n\t\t\ty = eventCache.y * data.pixelRatio;\n\t\t\t// Determine if the given coordinates are in the current path\n\t\t\tintersects = ctx.isPointInPath(x, y) || (ctx.isPointInStroke && ctx.isPointInStroke(x, y));\n\t\t}\n\t\ttransforms = data.transforms;\n\n\t\t// Allow callback functions to retrieve the mouse coordinates\n\t\tlayer.eventX = eventCache.x;\n\t\tlayer.eventY = eventCache.y;\n\t\tlayer.event = eventCache.event;\n\n\t\t// Adjust coordinates to match current canvas transformation\n\n\t\t// Keep track of some transformation values\n\t\tangle = data.transforms.rotate;\n\t\tx = layer.eventX;\n\t\ty = layer.eventY;\n\n\t\tif (angle !== 0) {\n\t\t\t// Rotate coordinates if coordinate space has been rotated\n\t\t\tlayer._eventX = (x * cos(-angle)) - (y * sin(-angle));\n\t\t\tlayer._eventY = (y * cos(-angle)) + (x * sin(-angle));\n\t\t} else {\n\t\t\t// Otherwise, no calculations need to be made\n\t\t\tlayer._eventX = x;\n\t\t\tlayer._eventY = y;\n\t\t}\n\n\t\t// Scale coordinates\n\t\tlayer._eventX /= transforms.scaleX;\n\t\tlayer._eventY /= transforms.scaleY;\n\n\t\t// If layer intersects with cursor\n\t\tif (intersects) {\n\t\t\t// Add it to a list of layers that intersect with cursor\n\t\t\tdata.intersecting.push(layer);\n\t\t}\n\t\tlayer.intersects = Boolean(intersects);\n\t}\n}\n\n// Normalize offsetX and offsetY for all browsers\n$.event.fix = function (event) {\n\tvar offset, originalEvent, touches;\n\n\tevent = jQueryEventFix.call($.event, event);\n\toriginalEvent = event.originalEvent;\n\n\t// originalEvent does not exist for manually-triggered events\n\tif (originalEvent) {\n\n\t\ttouches = originalEvent.changedTouches;\n\n\t\t// If offsetX and offsetY are not supported, define them\n\t\tif (event.pageX !== undefined && event.offsetX === undefined) {\n\t\t\ttry {\n\t\t\t\toffset = $(event.currentTarget).offset();\n\t\t\t\tif (offset) {\n\t\t\t\t\tevent.offsetX = event.pageX - offset.left;\n\t\t\t\t\tevent.offsetY = event.pageY - offset.top;\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// Fail silently\n\t\t\t}\n\t\t} else if (touches) {\n\t\t\ttry {\n\t\t\t\t// Enable offsetX and offsetY for mobile devices\n\t\t\t\toffset = $(event.currentTarget).offset();\n\t\t\t\tif (offset) {\n\t\t\t\t\tevent.offsetX = touches[0].pageX - offset.left;\n\t\t\t\t\tevent.offsetY = touches[0].pageY - offset.top;\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// Fail silently\n\t\t\t}\n\t\t}\n\n\t}\n\treturn event;\n};\n\n/* Drawing API */\n\n// Map drawing names with their respective method names\nmaps.drawings = {\n\t'arc': 'drawArc',\n\t'bezier': 'drawBezier',\n\t'ellipse': 'drawEllipse',\n\t'function': 'draw',\n\t'image': 'drawImage',\n\t'line': 'drawLine',\n\t'path': 'drawPath',\n\t'polygon': 'drawPolygon',\n\t'slice': 'drawSlice',\n\t'quadratic': 'drawQuadratic',\n\t'rectangle': 'drawRect',\n\t'text': 'drawText',\n\t'vector': 'drawVector',\n\t'save': 'saveCanvas',\n\t'restore': 'restoreCanvas',\n\t'rotate': 'rotateCanvas',\n\t'scale': 'scaleCanvas',\n\t'translate': 'translateCanvas'\n};\n\n// Draws on canvas using a function\n$.fn.draw = function draw(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams = new jCanvasObject(args);\n\n\t// Draw using any other method\n\tif (maps.drawings[params.type] && params.type !== 'function') {\n\n\t\t$canvases[maps.drawings[params.type]](args);\n\n\t} else {\n\n\t\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t\tctx = _getContext($canvases[e]);\n\t\t\tif (ctx) {\n\n\t\t\t\tparams = new jCanvasObject(args);\n\t\t\t\t_addLayer($canvases[e], params, args, draw);\n\t\t\t\tif (params.visible) {\n\n\t\t\t\t\tif (params.fn) {\n\t\t\t\t\t\t// Call the given user-defined function\n\t\t\t\t\t\tparams.fn.call($canvases[e], ctx, params);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t}\n\treturn $canvases;\n};\n\n// Clears canvas\n$.fn.clearCanvas = function clearCanvas(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams = new jCanvasObject(args);\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tif (params.width === null || params.height === null) {\n\t\t\t\t// Clear entire canvas if width/height is not given\n\n\t\t\t\t// Reset current transformation temporarily to ensure that the entire canvas is cleared\n\t\t\t\tctx.save();\n\t\t\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\t\t\tctx.clearRect(0, 0, $canvases[e].width, $canvases[e].height);\n\t\t\t\tctx.restore();\n\n\t\t\t} else {\n\t\t\t\t// Otherwise, clear the defined section of the canvas\n\n\t\t\t\t// Transform clear rectangle\n\t\t\t\t_addLayer($canvases[e], params, args, clearCanvas);\n\t\t\t\t_transformShape($canvases[e], ctx, params, params.width, params.height);\n\t\t\t\tctx.clearRect(params.x - (params.width / 2), params.y - (params.height / 2), params.width, params.height);\n\t\t\t\t// Restore previous transformation\n\t\t\t\t_restoreTransform(ctx, params);\n\n\t\t\t}\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n/* Transformation API */\n\n// Restores canvas\n$.fn.saveCanvas = function saveCanvas(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams, data, i;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tdata = _getCanvasData($canvases[e]);\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer($canvases[e], params, args, saveCanvas);\n\n\t\t\t// Restore a number of times using the given count\n\t\t\tfor (i = 0; i < params.count; i += 1) {\n\t\t\t\t_saveCanvas(ctx, data);\n\t\t\t}\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Restores canvas\n$.fn.restoreCanvas = function restoreCanvas(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams, data, i;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tdata = _getCanvasData($canvases[e]);\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer($canvases[e], params, args, restoreCanvas);\n\n\t\t\t// Restore a number of times using the given count\n\t\t\tfor (i = 0; i < params.count; i += 1) {\n\t\t\t\t_restoreCanvas(ctx, data);\n\t\t\t}\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Rotates canvas (internal)\nfunction _rotateCanvas(ctx, params, transforms) {\n\n\t// Get conversion factor for radians\n\tparams._toRad = (params.inDegrees ? (PI / 180) : 1);\n\n\t// Rotate canvas using shape as center of rotation\n\tctx.translate(params.x, params.y);\n\tctx.rotate(params.rotate * params._toRad);\n\tctx.translate(-params.x, -params.y);\n\n\t// If transformation data was given\n\tif (transforms) {\n\t\t// Update transformation data\n\t\ttransforms.rotate += (params.rotate * params._toRad);\n\t}\n}\n\n// Scales canvas (internal)\nfunction _scaleCanvas(ctx, params, transforms) {\n\n\t// Scale both the x- and y- axis using the 'scale' property\n\tif (params.scale !== 1) {\n\t\tparams.scaleX = params.scaleY = params.scale;\n\t}\n\n\t// Scale canvas using shape as center of rotation\n\tctx.translate(params.x, params.y);\n\tctx.scale(params.scaleX, params.scaleY);\n\tctx.translate(-params.x, -params.y);\n\n\t// If transformation data was given\n\tif (transforms) {\n\t\t// Update transformation data\n\t\ttransforms.scaleX *= params.scaleX;\n\t\ttransforms.scaleY *= params.scaleY;\n\t}\n}\n\n// Translates canvas (internal)\nfunction _translateCanvas(ctx, params, transforms) {\n\n\t// Translate both the x- and y-axis using the 'translate' property\n\tif (params.translate) {\n\t\tparams.translateX = params.translateY = params.translate;\n\t}\n\n\t// Translate canvas\n\tctx.translate(params.translateX, params.translateY);\n\n\t// If transformation data was given\n\tif (transforms) {\n\t\t// Update transformation data\n\t\ttransforms.translateX += params.translateX;\n\t\ttransforms.translateY += params.translateY;\n\t}\n}\n\n// Rotates canvas\n$.fn.rotateCanvas = function rotateCanvas(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams, data;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tdata = _getCanvasData($canvases[e]);\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer($canvases[e], params, args, rotateCanvas);\n\n\t\t\t// Autosave transformation state by default\n\t\t\tif (params.autosave) {\n\t\t\t\t// Automatically save transformation state by default\n\t\t\t\t_saveCanvas(ctx, data);\n\t\t\t}\n\t\t\t_rotateCanvas(ctx, params, data.transforms);\n\t\t}\n\n\t}\n\treturn $canvases;\n};\n\n// Scales canvas\n$.fn.scaleCanvas = function scaleCanvas(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams, data;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tdata = _getCanvasData($canvases[e]);\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer($canvases[e], params, args, scaleCanvas);\n\n\t\t\t// Autosave transformation state by default\n\t\t\tif (params.autosave) {\n\t\t\t\t// Automatically save transformation state by default\n\t\t\t\t_saveCanvas(ctx, data);\n\t\t\t}\n\t\t\t_scaleCanvas(ctx, params, data.transforms);\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Translates canvas\n$.fn.translateCanvas = function translateCanvas(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams, data;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tdata = _getCanvasData($canvases[e]);\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer($canvases[e], params, args, translateCanvas);\n\n\t\t\t// Autosave transformation state by default\n\t\t\tif (params.autosave) {\n\t\t\t\t// Automatically save transformation state by default\n\t\t\t\t_saveCanvas(ctx, data);\n\t\t\t}\n\t\t\t_translateCanvas(ctx, params, data.transforms);\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n/* Shape API */\n\n// Draws rectangle\n$.fn.drawRect = function drawRect(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams,\n\t\tx1, y1,\n\t\tx2, y2,\n\t\tr, temp;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer($canvases[e], params, args, drawRect);\n\t\t\tif (params.visible) {\n\n\t\t\t\t_transformShape($canvases[e], ctx, params, params.width, params.height);\n\t\t\t\t_setGlobalProps($canvases[e], ctx, params);\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tif (params.width && params.height) {\n\t\t\t\t\tx1 = params.x - (params.width / 2);\n\t\t\t\t\ty1 = params.y - (params.height / 2);\n\t\t\t\t\tr = abs(params.cornerRadius);\n\t\t\t\t\t// If corner radius is defined and is not zero\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\t// Draw rectangle with rounded corners if cornerRadius is defined\n\n\t\t\t\t\t\tx2 = params.x + (params.width / 2);\n\t\t\t\t\t\ty2 = params.y + (params.height / 2);\n\n\t\t\t\t\t\t// Handle negative width\n\t\t\t\t\t\tif (params.width < 0) {\n\t\t\t\t\t\t\ttemp = x1;\n\t\t\t\t\t\t\tx1 = x2;\n\t\t\t\t\t\t\tx2 = temp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Handle negative height\n\t\t\t\t\t\tif (params.height < 0) {\n\t\t\t\t\t\t\ttemp = y1;\n\t\t\t\t\t\t\ty1 = y2;\n\t\t\t\t\t\t\ty2 = temp;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prevent over-rounded corners\n\t\t\t\t\t\tif ((x2 - x1) - (2 * r) < 0) {\n\t\t\t\t\t\t\tr = (x2 - x1) / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((y2 - y1) - (2 * r) < 0) {\n\t\t\t\t\t\t\tr = (y2 - y1) / 2;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Draw rectangle\n\t\t\t\t\t\tctx.moveTo(x1 + r, y1);\n\t\t\t\t\t\tctx.lineTo(x2 - r, y1);\n\t\t\t\t\t\tctx.arc(x2 - r, y1 + r, r, 3 * PI / 2, PI * 2, false);\n\t\t\t\t\t\tctx.lineTo(x2, y2 - r);\n\t\t\t\t\t\tctx.arc(x2 - r, y2 - r, r, 0, PI / 2, false);\n\t\t\t\t\t\tctx.lineTo(x1 + r, y2);\n\t\t\t\t\t\tctx.arc(x1 + r, y2 - r, r, PI / 2, PI, false);\n\t\t\t\t\t\tctx.lineTo(x1, y1 + r);\n\t\t\t\t\t\tctx.arc(x1 + r, y1 + r, r, PI, 3 * PI / 2, false);\n\t\t\t\t\t\t// Always close path\n\t\t\t\t\t\tparams.closed = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Otherwise, draw rectangle with square corners\n\t\t\t\t\t\tctx.rect(x1, y1, params.width, params.height);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Check for jCanvas events\n\t\t\t\t_detectEvents($canvases[e], ctx, params);\n\t\t\t\t// Close rectangle path\n\t\t\t\t_closePath($canvases[e], ctx, params);\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Retrieves a coterminal angle between 0 and 2pi for the given angle\nfunction _getCoterminal(angle) {\n\twhile (angle < 0) {\n\t\tangle += (2 * PI);\n\t}\n\treturn angle;\n}\n\n// Retrieves the x-coordinate for the given angle in a circle\nfunction _getArcX(params, angle) {\n\treturn params.x + (params.radius * cos(angle));\n}\n// Retrieves the y-coordinate for the given angle in a circle\nfunction _getArcY(params, angle) {\n\treturn params.y + (params.radius * sin(angle));\n}\n\n// Draws arc (internal)\nfunction _drawArc(canvas, ctx, params, path) {\n\tvar x1, y1, x2, y2,\n\t\tx3, y3, x4, y4,\n\t\toffsetX, offsetY,\n\t\tdiff;\n\n\t// Determine offset from dragging\n\tif (params === path) {\n\t\toffsetX = 0;\n\t\toffsetY = 0;\n\t} else {\n\t\toffsetX = params.x;\n\t\toffsetY = params.y;\n\t}\n\n\t// Convert default end angle to radians\n\tif (!path.inDegrees && path.end === 360) {\n\t\tpath.end = PI * 2;\n\t}\n\n\t// Convert angles to radians\n\tpath.start *= params._toRad;\n\tpath.end *= params._toRad;\n\t// Consider 0deg due north of arc\n\tpath.start -= (PI / 2);\n\tpath.end -= (PI / 2);\n\n\t// Ensure arrows are pointed correctly for CCW arcs\n\tdiff = PI / 180;\n\tif (path.ccw) {\n\t\tdiff *= -1;\n\t}\n\n\t// Calculate coordinates for start arrow\n\tx1 = _getArcX(path, path.start + diff);\n\ty1 = _getArcY(path, path.start + diff);\n\tx2 = _getArcX(path, path.start);\n\ty2 = _getArcY(path, path.start);\n\n\t_addStartArrow(\n\t\tcanvas, ctx,\n\t\tparams, path,\n\t\tx1, y1,\n\t\tx2, y2\n\t);\n\n\t// Draw arc\n\tctx.arc(path.x + offsetX, path.y + offsetY, path.radius, path.start, path.end, path.ccw);\n\n\t// Calculate coordinates for end arrow\n\tx3 = _getArcX(path, path.end + diff);\n\ty3 = _getArcY(path, path.end + diff);\n\tx4 = _getArcX(path, path.end);\n\ty4 = _getArcY(path, path.end);\n\n\t_addEndArrow(\n\t\tcanvas, ctx,\n\t\tparams, path,\n\t\tx4, y4,\n\t\tx3, y3\n\t);\n}\n\n// Draws arc or circle\n$.fn.drawArc = function drawArc(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer($canvases[e], params, args, drawArc);\n\t\t\tif (params.visible) {\n\n\t\t\t\t_transformShape($canvases[e], ctx, params, params.radius * 2);\n\t\t\t\t_setGlobalProps($canvases[e], ctx, params);\n\n\t\t\t\tctx.beginPath();\n\t\t\t\t_drawArc($canvases[e], ctx, params, params);\n\t\t\t\t// Check for jCanvas events\n\t\t\t\t_detectEvents($canvases[e], ctx, params);\n\t\t\t\t// Optionally close path\n\t\t\t\t_closePath($canvases[e], ctx, params);\n\n\t\t\t}\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Draws ellipse\n$.fn.drawEllipse = function drawEllipse(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams,\n\t\tcontrolW,\n\t\tcontrolH;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer($canvases[e], params, args, drawEllipse);\n\t\t\tif (params.visible) {\n\n\t\t\t\t_transformShape($canvases[e], ctx, params, params.width, params.height);\n\t\t\t\t_setGlobalProps($canvases[e], ctx, params);\n\n\t\t\t\t// Calculate control width and height\n\t\t\t\tcontrolW = params.width * (4 / 3);\n\t\t\t\tcontrolH = params.height;\n\n\t\t\t\t// Create ellipse using curves\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(params.x, params.y - (controlH / 2));\n\t\t\t\t// Left side\n\t\t\t\tctx.bezierCurveTo(params.x - (controlW / 2), params.y - (controlH / 2), params.x - (controlW / 2), params.y + (controlH / 2), params.x, params.y + (controlH / 2));\n\t\t\t\t// Right side\n\t\t\t\tctx.bezierCurveTo(params.x + (controlW / 2), params.y + (controlH / 2), params.x + (controlW / 2), params.y - (controlH / 2), params.x, params.y - (controlH / 2));\n\t\t\t\t// Check for jCanvas events\n\t\t\t\t_detectEvents($canvases[e], ctx, params);\n\t\t\t\t// Always close path\n\t\t\t\tparams.closed = true;\n\t\t\t\t_closePath($canvases[e], ctx, params);\n\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Draws a regular (equal-angled) polygon\n$.fn.drawPolygon = function drawPolygon(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams,\n\t\ttheta, dtheta, hdtheta,\n\t\tapothem,\n\t\tx, y, i;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer($canvases[e], params, args, drawPolygon);\n\t\t\tif (params.visible) {\n\n\t\t\t\t_transformShape($canvases[e], ctx, params, params.radius * 2);\n\t\t\t\t_setGlobalProps($canvases[e], ctx, params);\n\n\t\t\t\t// Polygon's central angle\n\t\t\t\tdtheta = (2 * PI) / params.sides;\n\t\t\t\t// Half of dtheta\n\t\t\t\thdtheta = dtheta / 2;\n\t\t\t\t// Polygon's starting angle\n\t\t\t\ttheta = hdtheta + (PI / 2);\n\t\t\t\t// Distance from polygon's center to the middle of its side\n\t\t\t\tapothem = params.radius * cos(hdtheta);\n\n\t\t\t\t// Calculate path and draw\n\t\t\t\tctx.beginPath();\n\t\t\t\tfor (i = 0; i < params.sides; i += 1) {\n\n\t\t\t\t\t// Draw side of polygon\n\t\t\t\t\tx = params.x + (params.radius * cos(theta));\n\t\t\t\t\ty = params.y + (params.radius * sin(theta));\n\n\t\t\t\t\t// Plot point on polygon\n\t\t\t\t\tctx.lineTo(x, y);\n\n\t\t\t\t\t// Project side if chosen\n\t\t\t\t\tif (params.concavity) {\n\t\t\t\t\t\t// Sides are projected from the polygon's apothem\n\t\t\t\t\t\tx = params.x + ((apothem + (-apothem * params.concavity)) * cos(theta + hdtheta));\n\t\t\t\t\t\ty = params.y + ((apothem + (-apothem * params.concavity)) * sin(theta + hdtheta));\n\t\t\t\t\t\tctx.lineTo(x, y);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Increment theta by delta theta\n\t\t\t\t\ttheta += dtheta;\n\n\t\t\t\t}\n\t\t\t\t// Check for jCanvas events\n\t\t\t\t_detectEvents($canvases[e], ctx, params);\n\t\t\t\t// Always close path\n\t\t\t\tparams.closed = true;\n\t\t\t\t_closePath($canvases[e], ctx, params);\n\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Draws pie-shaped slice\n$.fn.drawSlice = function drawSlice(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams,\n\t\tangle, dx, dy;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer($canvases[e], params, args, drawSlice);\n\t\t\tif (params.visible) {\n\n\t\t\t\t_transformShape($canvases[e], ctx, params, params.radius * 2);\n\t\t\t\t_setGlobalProps($canvases[e], ctx, params);\n\n\t\t\t\t// Perform extra calculations\n\n\t\t\t\t// Convert angles to radians\n\t\t\t\tparams.start *= params._toRad;\n\t\t\t\tparams.end *= params._toRad;\n\t\t\t\t// Consider 0deg at north of arc\n\t\t\t\tparams.start -= (PI / 2);\n\t\t\t\tparams.end -= (PI / 2);\n\n\t\t\t\t// Find positive equivalents of angles\n\t\t\t\tparams.start = _getCoterminal(params.start);\n\t\t\t\tparams.end = _getCoterminal(params.end);\n\t\t\t\t// Ensure start angle is less than end angle\n\t\t\t\tif (params.end < params.start) {\n\t\t\t\t\tparams.end += (2 * PI);\n\t\t\t\t}\n\n\t\t\t\t// Calculate angular position of slice\n\t\t\t\tangle = ((params.start + params.end) / 2);\n\n\t\t\t\t// Calculate ratios for slice's angle\n\t\t\t\tdx = (params.radius * params.spread * cos(angle));\n\t\t\t\tdy = (params.radius * params.spread * sin(angle));\n\n\t\t\t\t// Adjust position of slice\n\t\t\t\tparams.x += dx;\n\t\t\t\tparams.y += dy;\n\n\t\t\t\t// Draw slice\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(params.x, params.y, params.radius, params.start, params.end, params.ccw);\n\t\t\t\tctx.lineTo(params.x, params.y);\n\t\t\t\t// Check for jCanvas events\n\t\t\t\t_detectEvents($canvases[e], ctx, params);\n\t\t\t\t// Always close path\n\t\t\t\tparams.closed = true;\n\t\t\t\t_closePath($canvases[e], ctx, params);\n\n\t\t\t}\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n/* Path API */\n\n// Adds arrow to path using the given properties\nfunction _addArrow(canvas, ctx, params, path, x1, y1, x2, y2) {\n\tvar leftX, leftY,\n\t\trightX, rightY,\n\t\toffsetX, offsetY,\n\t\tangle;\n\n\t// If arrow radius is given and path is not closed\n\tif (path.arrowRadius && !params.closed) {\n\n\t\t// Calculate angle\n\t\tangle = atan2((y2 - y1), (x2 - x1));\n\t\t// Adjust angle correctly\n\t\tangle -= PI;\n\t\t// Calculate offset to place arrow at edge of path\n\t\toffsetX = (params.strokeWidth * cos(angle));\n\t\toffsetY = (params.strokeWidth * sin(angle));\n\n\t\t// Calculate coordinates for left half of arrow\n\t\tleftX = x2 + (path.arrowRadius * cos(angle + (path.arrowAngle / 2)));\n\t\tleftY = y2 + (path.arrowRadius * sin(angle + (path.arrowAngle / 2)));\n\t\t// Calculate coordinates for right half of arrow\n\t\trightX = x2 + (path.arrowRadius * cos(angle - (path.arrowAngle / 2)));\n\t\trightY = y2 + (path.arrowRadius * sin(angle - (path.arrowAngle / 2)));\n\n\t\t// Draw left half of arrow\n\t\tctx.moveTo(leftX - offsetX, leftY - offsetY);\n\t\tctx.lineTo(x2 - offsetX, y2 - offsetY);\n\t\t// Draw right half of arrow\n\t\tctx.lineTo(rightX - offsetX, rightY - offsetY);\n\n\t\t// Visually connect arrow to path\n\t\tctx.moveTo(x2 - offsetX, y2 - offsetY);\n\t\tctx.lineTo(x2 + offsetX, y2 + offsetY);\n\t\t// Move back to end of path\n\t\tctx.moveTo(x2, y2);\n\n\t}\n}\n\n// Optionally adds arrow to start of path\nfunction _addStartArrow(canvas, ctx, params, path, x1, y1, x2, y2) {\n\tif (!path._arrowAngleConverted) {\n\t\tpath.arrowAngle *= params._toRad;\n\t\tpath._arrowAngleConverted = true;\n\t}\n\tif (path.startArrow) {\n\t\t_addArrow(canvas, ctx, params, path, x1, y1, x2, y2);\n\t}\n}\n\n// Optionally adds arrow to end of path\nfunction _addEndArrow(canvas, ctx, params, path, x1, y1, x2, y2) {\n\tif (!path._arrowAngleConverted) {\n\t\tpath.arrowAngle *= params._toRad;\n\t\tpath._arrowAngleConverted = true;\n\t}\n\tif (path.endArrow) {\n\t\t_addArrow(canvas, ctx, params, path, x1, y1, x2, y2);\n\t}\n}\n\n// Draws line (internal)\nfunction _drawLine(canvas, ctx, params, path) {\n\tvar l,\n\t\tlx, ly;\n\tl = 2;\n\t_addStartArrow(\n\t\tcanvas, ctx,\n\t\tparams, path,\n\t\tpath.x2 + params.x,\n\t\tpath.y2 + params.y,\n\t\tpath.x1 + params.x,\n\t\tpath.y1 + params.y\n\t);\n\tif (path.x1 !== undefined && path.y1 !== undefined) {\n\t\tctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n\t}\n\twhile (true) {\n\t\t// Calculate next coordinates\n\t\tlx = path['x' + l];\n\t\tly = path['y' + l];\n\t\t// If coordinates are given\n\t\tif (lx !== undefined && ly !== undefined) {\n\t\t\t// Draw next line\n\t\t\tctx.lineTo(lx + params.x, ly + params.y);\n\t\t\tl += 1;\n\t\t} else {\n\t\t\t// Otherwise, stop drawing\n\t\t\tbreak;\n\t\t}\n\t}\n\tl -= 1;\n\t// Optionally add arrows to path\n\t_addEndArrow(\n\t\tcanvas, ctx,\n\t\tparams,\n\t\tpath,\n\t\tpath['x' + (l - 1)] + params.x,\n\t\tpath['y' + (l - 1)] + params.y,\n\t\tpath['x' + l] + params.x,\n\t\tpath['y' + l] + params.y\n\t);\n}\n\n// Draws line\n$.fn.drawLine = function drawLine(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer($canvases[e], params, args, drawLine);\n\t\t\tif (params.visible) {\n\n\t\t\t\t_transformShape($canvases[e], ctx, params);\n\t\t\t\t_setGlobalProps($canvases[e], ctx, params);\n\n\t\t\t\t// Draw each point\n\t\t\t\tctx.beginPath();\n\t\t\t\t_drawLine($canvases[e], ctx, params, params);\n\t\t\t\t// Check for jCanvas events\n\t\t\t\t_detectEvents($canvases[e], ctx, params);\n\t\t\t\t// Optionally close path\n\t\t\t\t_closePath($canvases[e], ctx, params);\n\n\t\t\t}\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Draws quadratic curve (internal)\nfunction _drawQuadratic(canvas, ctx, params, path) {\n\tvar l,\n\t\tlx, ly,\n\t\tlcx, lcy;\n\n\tl = 2;\n\n\t_addStartArrow(\n\t\tcanvas,\n\t\tctx,\n\t\tparams,\n\t\tpath,\n\t\tpath.cx1 + params.x,\n\t\tpath.cy1 + params.y,\n\t\tpath.x1 + params.x,\n\t\tpath.y1 + params.y\n\t);\n\n\tif (path.x1 !== undefined && path.y1 !== undefined) {\n\t\tctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n\t}\n\twhile (true) {\n\t\t// Calculate next coordinates\n\t\tlx = path['x' + l];\n\t\tly = path['y' + l];\n\t\tlcx = path['cx' + (l - 1)];\n\t\tlcy = path['cy' + (l - 1)];\n\t\t// If coordinates are given\n\t\tif (lx !== undefined && ly !== undefined && lcx !== undefined && lcy !== undefined) {\n\t\t\t// Draw next curve\n\t\t\tctx.quadraticCurveTo(lcx + params.x, lcy + params.y, lx + params.x, ly + params.y);\n\t\t\tl += 1;\n\t\t} else {\n\t\t\t// Otherwise, stop drawing\n\t\t\tbreak;\n\t\t}\n\t}\n\tl -= 1;\n\t_addEndArrow(\n\t\tcanvas,\n\t\tctx,\n\t\tparams,\n\t\tpath,\n\t\tpath['cx' + (l - 1)] + params.x,\n\t\tpath['cy' + (l - 1)] + params.y,\n\t\tpath['x' + l] + params.x,\n\t\tpath['y' + l] + params.y\n\t);\n}\n\n// Draws quadratic curve\n$.fn.drawQuadratic = function drawQuadratic(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer($canvases[e], params, args, drawQuadratic);\n\t\t\tif (params.visible) {\n\n\t\t\t\t_transformShape($canvases[e], ctx, params);\n\t\t\t\t_setGlobalProps($canvases[e], ctx, params);\n\n\t\t\t\t// Draw each point\n\t\t\t\tctx.beginPath();\n\t\t\t\t_drawQuadratic($canvases[e], ctx, params, params);\n\t\t\t\t// Check for jCanvas events\n\t\t\t\t_detectEvents($canvases[e], ctx, params);\n\t\t\t\t// Optionally close path\n\t\t\t\t_closePath($canvases[e], ctx, params);\n\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Draws Bezier curve (internal)\nfunction _drawBezier(canvas, ctx, params, path) {\n\tvar l, lc,\n\t\tlx, ly,\n\t\tlcx1, lcy1,\n\t\tlcx2, lcy2;\n\n\tl = 2;\n\tlc = 1;\n\n\t_addStartArrow(\n\t\tcanvas,\n\t\tctx,\n\t\tparams,\n\t\tpath,\n\t\tpath.cx1 + params.x,\n\t\tpath.cy1 + params.y,\n\t\tpath.x1 + params.x,\n\t\tpath.y1 + params.y\n\t);\n\n\tif (path.x1 !== undefined && path.y1 !== undefined) {\n\t\tctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n\t}\n\twhile (true) {\n\t\t// Calculate next coordinates\n\t\tlx = path['x' + l];\n\t\tly = path['y' + l];\n\t\tlcx1 = path['cx' + lc];\n\t\tlcy1 = path['cy' + lc];\n\t\tlcx2 = path['cx' + (lc + 1)];\n\t\tlcy2 = path['cy' + (lc + 1)];\n\t\t// If next coordinates are given\n\t\tif (lx !== undefined && ly !== undefined && lcx1 !== undefined && lcy1 !== undefined && lcx2 !== undefined && lcy2 !== undefined) {\n\t\t\t// Draw next curve\n\t\t\tctx.bezierCurveTo(lcx1 + params.x, lcy1 + params.y, lcx2 + params.x, lcy2 + params.y, lx + params.x, ly + params.y);\n\t\t\tl += 1;\n\t\t\tlc += 2;\n\t\t} else {\n\t\t\t// Otherwise, stop drawing\n\t\t\tbreak;\n\t\t}\n\t}\n\tl -= 1;\n\tlc -= 2;\n\t_addEndArrow(\n\t\tcanvas,\n\t\tctx,\n\t\tparams,\n\t\tpath,\n\t\tpath['cx' + (lc + 1)] + params.x,\n\t\tpath['cy' + (lc + 1)] + params.y,\n\t\tpath['x' + l] + params.x,\n\t\tpath['y' + l] + params.y\n\t);\n}\n\n// Draws Bezier curve\n$.fn.drawBezier = function drawBezier(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer($canvases[e], params, args, drawBezier);\n\t\t\tif (params.visible) {\n\n\t\t\t\t_transformShape($canvases[e], ctx, params);\n\t\t\t\t_setGlobalProps($canvases[e], ctx, params);\n\n\t\t\t\t// Draw each point\n\t\t\t\tctx.beginPath();\n\t\t\t\t_drawBezier($canvases[e], ctx, params, params);\n\t\t\t\t// Check for jCanvas events\n\t\t\t\t_detectEvents($canvases[e], ctx, params);\n\t\t\t\t// Optionally close path\n\t\t\t\t_closePath($canvases[e], ctx, params);\n\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Retrieves the x-coordinate for the given vector angle and length\nfunction _getVectorX(params, angle, length) {\n\tangle *= params._toRad;\n\tangle -= (PI / 2);\n\treturn (length * cos(angle));\n}\n// Retrieves the y-coordinate for the given vector angle and length\nfunction _getVectorY(params, angle, length) {\n\tangle *= params._toRad;\n\tangle -= (PI / 2);\n\treturn (length * sin(angle));\n}\n\n// Draws vector (internal) #2\nfunction _drawVector(canvas, ctx, params, path) {\n\tvar l, angle, length,\n\t\toffsetX, offsetY,\n\t\tx, y,\n\t\tx3, y3,\n\t\tx4, y4;\n\n\t// Determine offset from dragging\n\tif (params === path) {\n\t\toffsetX = 0;\n\t\toffsetY = 0;\n\t} else {\n\t\toffsetX = params.x;\n\t\toffsetY = params.y;\n\t}\n\n\tl = 1;\n\tx = x3 = x4 = path.x + offsetX;\n\ty = y3 = y4 = path.y + offsetY;\n\n\t_addStartArrow(\n\t\tcanvas, ctx,\n\t\tparams, path,\n\t\tx + _getVectorX(params, path.a1, path.l1),\n\t\ty + _getVectorY(params, path.a1, path.l1),\n\t\tx,\n\t\ty\n\t);\n\n\t// The vector starts at the given (x, y) coordinates\n\tif (path.x !== undefined && path.y !== undefined) {\n\t\tctx.moveTo(x, y);\n\t}\n\twhile (true) {\n\n\t\tangle = path['a' + l];\n\t\tlength = path['l' + l];\n\n\t\tif (angle !== undefined && length !== undefined) {\n\t\t\t// Convert the angle to radians with 0 degrees starting at north\n\t\t\t// Keep track of last two coordinates\n\t\t\tx3 = x4;\n\t\t\ty3 = y4;\n\t\t\t// Compute (x, y) coordinates from angle and length\n\t\t\tx4 += _getVectorX(params, angle, length);\n\t\t\ty4 += _getVectorY(params, angle, length);\n\t\t\tctx.lineTo(x4, y4);\n\t\t\tl += 1;\n\t\t} else {\n\t\t\t// Otherwise, stop drawing\n\t\t\tbreak;\n\t\t}\n\n\t}\n\t_addEndArrow(\n\t\tcanvas, ctx,\n\t\tparams, path,\n\t\tx3, y3,\n\t\tx4, y4\n\t);\n}\n\n// Draws vector\n$.fn.drawVector = function drawVector(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer($canvases[e], params, args, drawVector);\n\t\t\tif (params.visible) {\n\n\t\t\t\t_transformShape($canvases[e], ctx, params);\n\t\t\t\t_setGlobalProps($canvases[e], ctx, params);\n\n\t\t\t\t// Draw each point\n\t\t\t\tctx.beginPath();\n\t\t\t\t_drawVector($canvases[e], ctx, params, params);\n\t\t\t\t// Check for jCanvas events\n\t\t\t\t_detectEvents($canvases[e], ctx, params);\n\t\t\t\t// Optionally close path\n\t\t\t\t_closePath($canvases[e], ctx, params);\n\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Draws a path consisting of one or more subpaths\n$.fn.drawPath = function drawPath(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams,\n\t\tl, lp;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer($canvases[e], params, args, drawPath);\n\t\t\tif (params.visible) {\n\n\t\t\t\t_transformShape($canvases[e], ctx, params);\n\t\t\t\t_setGlobalProps($canvases[e], ctx, params);\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tl = 1;\n\t\t\t\twhile (true) {\n\t\t\t\t\tlp = params['p' + l];\n\t\t\t\t\tif (lp !== undefined) {\n\t\t\t\t\t\tlp = new jCanvasObject(lp);\n\t\t\t\t\t\tif (lp.type === 'line') {\n\t\t\t\t\t\t\t_drawLine($canvases[e], ctx, params, lp);\n\t\t\t\t\t\t} else if (lp.type === 'quadratic') {\n\t\t\t\t\t\t\t_drawQuadratic($canvases[e], ctx, params, lp);\n\t\t\t\t\t\t} else if (lp.type === 'bezier') {\n\t\t\t\t\t\t\t_drawBezier($canvases[e], ctx, params, lp);\n\t\t\t\t\t\t} else if (lp.type === 'vector') {\n\t\t\t\t\t\t\t_drawVector($canvases[e], ctx, params, lp);\n\t\t\t\t\t\t} else if (lp.type === 'arc') {\n\t\t\t\t\t\t\t_drawArc($canvases[e], ctx, params, lp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tl += 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Check for jCanvas events\n\t\t\t\t_detectEvents($canvases[e], ctx, params);\n\t\t\t\t// Optionally close path\n\t\t\t\t_closePath($canvases[e], ctx, params);\n\n\t\t\t}\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n/* Text API */\n\n// Calculates font string and set it as the canvas font\nfunction _setCanvasFont(canvas, ctx, params) {\n\t// Otherwise, use the given font attributes\n\tif (!isNaN(Number(params.fontSize))) {\n\t\t// Give font size units if it doesn't have any\n\t\tparams.fontSize += 'px';\n\t}\n\t// Set font using given font properties\n\tctx.font = params.fontStyle + ' ' + params.fontSize + ' ' + params.fontFamily;\n}\n\n// Measures canvas text\nfunction _measureText(canvas, ctx, params, lines) {\n\tvar originalSize, curWidth, l,\n\t\tpropCache = caches.propCache;\n\n\t// Used cached width/height if possible\n\tif (propCache.text === params.text && propCache.fontStyle === params.fontStyle && propCache.fontSize === params.fontSize && propCache.fontFamily === params.fontFamily && propCache.maxWidth === params.maxWidth && propCache.lineHeight === params.lineHeight) {\n\n\t\tparams.width = propCache.width;\n\t\tparams.height = propCache.height;\n\n\t} else {\n\t\t// Calculate text dimensions only once\n\n\t\t// Calculate width of first line (for comparison)\n\t\tparams.width = ctx.measureText(lines[0]).width;\n\n\t\t// Get width of longest line\n\t\tfor (l = 1; l < lines.length; l += 1) {\n\n\t\t\tcurWidth = ctx.measureText(lines[l]).width;\n\t\t\t// Ensure text's width is the width of its longest line\n\t\t\tif (curWidth > params.width) {\n\t\t\t\tparams.width = curWidth;\n\t\t\t}\n\n\t\t}\n\n\t\t// Save original font size\n\t\toriginalSize = canvas.style.fontSize;\n\t\t// Temporarily set canvas font size to retrieve size in pixels\n\t\tcanvas.style.fontSize = params.fontSize;\n\t\t// Save text width and height in parameters object\n\t\tparams.height = parseFloat($.css(canvas, 'fontSize')) * lines.length * params.lineHeight;\n\t\t// Reset font size to original size\n\t\tcanvas.style.fontSize = originalSize;\n\t}\n}\n\n// Wraps a string of text within a defined width\nfunction _wrapText(ctx, params) {\n\tvar allText = String(params.text),\n\t\t// Maximum line width (optional)\n\t\tmaxWidth = params.maxWidth,\n\t\t// Lines created by manual line breaks (\\n)\n\t\tmanualLines = allText.split('\\n'),\n\t\t// All lines created manually and by wrapping\n\t\tallLines = [],\n\t\t// Other variables\n\t\tlines, line, l,\n\t\ttext, words, w;\n\n\t// Loop through manually-broken lines\n\tfor (l = 0; l < manualLines.length; l += 1) {\n\n\t\ttext = manualLines[l];\n\t\t// Split line into list of words\n\t\twords = text.split(' ');\n\t\tlines = [];\n\t\tline = '';\n\n\t\t// If text is short enough initially\n\t\t// Or, if the text consists of only one word\n\t\tif (words.length === 1 || ctx.measureText(text).width < maxWidth) {\n\n\t\t\t// No need to wrap text\n\t\t\tlines = [text];\n\n\t\t} else {\n\n\t\t\t// Wrap lines\n\t\t\tfor (w = 0; w < words.length; w += 1) {\n\n\t\t\t\t// Once line gets too wide, push word to next line\n\t\t\t\tif (ctx.measureText(line + words[w]).width > maxWidth) {\n\t\t\t\t\t// This check prevents empty lines from being created\n\t\t\t\t\tif (line !== '') {\n\t\t\t\t\t\tlines.push(line);\n\t\t\t\t\t}\n\t\t\t\t\t// Start new line and repeat process\n\t\t\t\t\tline = '';\n\t\t\t\t}\n\t\t\t\t// Add words to line until the line is too wide\n\t\t\t\tline += words[w];\n\t\t\t\t// Do not add a space after the last word\n\t\t\t\tif (w !== (words.length - 1)) {\n\t\t\t\t\tline += ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The last word should always be pushed\n\t\t\tlines.push(line);\n\n\t\t}\n\t\t// Remove extra space at the end of each line\n\t\tallLines = allLines.concat(\n\t\t\tlines\n\t\t\t.join('\\n')\n\t\t\t.replace(/((\\n))|($)/gi, '$2')\n\t\t\t.split('\\n')\n\t\t);\n\n\t}\n\n\treturn allLines;\n}\n\n// Draws text on canvas\n$.fn.drawText = function drawText(args) {\n\tvar $canvases = this, e, ctx,\n\t\tparams, layer,\n\t\tlines, line, l,\n\t\tfontSize, constantCloseness = 500,\n\t\tnchars, chars, ch, c,\n\t\tx, y;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer($canvases[e], params, args, drawText);\n\t\t\tif (params.visible) {\n\n\t\t\t\t// Set text-specific properties\n\t\t\t\tctx.textBaseline = params.baseline;\n\t\t\t\tctx.textAlign = params.align;\n\n\t\t\t\t// Set canvas font using given properties\n\t\t\t\t_setCanvasFont($canvases[e], ctx, params);\n\n\t\t\t\tif (params.maxWidth !== null) {\n\t\t\t\t\t// Wrap text using an internal function\n\t\t\t\t\tlines = _wrapText(ctx, params);\n\t\t\t\t} else {\n\t\t\t\t\t// Convert string of text to list of lines\n\t\t\t\t\tlines = params.text\n\t\t\t\t\t.toString()\n\t\t\t\t\t.split('\\n');\n\t\t\t\t}\n\n\t\t\t\t// Calculate text's width and height\n\t\t\t\t_measureText($canvases[e], ctx, params, lines);\n\n\t\t\t\t// If text is a layer\n\t\t\t\tif (layer) {\n\t\t\t\t\t// Copy calculated width/height to layer object\n\t\t\t\t\tlayer.width = params.width;\n\t\t\t\t\tlayer.height = params.height;\n\t\t\t\t}\n\n\t\t\t\t_transformShape($canvases[e], ctx, params, params.width, params.height);\n\t\t\t\t_setGlobalProps($canvases[e], ctx, params);\n\n\t\t\t\t// Adjust text position to accomodate different horizontal alignments\n\t\t\t\tx = params.x;\n\t\t\t\tif (params.align === 'left') {\n\t\t\t\t\tif (params.respectAlign) {\n\t\t\t\t\t\t// Realign text to the left if chosen\n\t\t\t\t\t\tparams.x += params.width / 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Center text block by default\n\t\t\t\t\t\tx -= params.width / 2;\n\t\t\t\t\t}\n\t\t\t\t} else if (params.align === 'right') {\n\t\t\t\t\tif (params.respectAlign) {\n\t\t\t\t\t\t// Realign text to the right if chosen\n\t\t\t\t\t\tparams.x -= params.width / 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Center text block by default\n\t\t\t\t\t\tx += params.width / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (params.radius) {\n\n\t\t\t\t\tfontSize = parseFloat(params.fontSize);\n\n\t\t\t\t\t// Greater values move clockwise\n\t\t\t\t\tif (params.letterSpacing === null) {\n\t\t\t\t\t\tparams.letterSpacing = fontSize / constantCloseness;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Loop through each line of text\n\t\t\t\t\tfor (l = 0; l < lines.length; l += 1) {\n\t\t\t\t\t\tctx.save();\n\t\t\t\t\t\tctx.translate(params.x, params.y);\n\t\t\t\t\t\tline = lines[l];\n\t\t\t\t\t\tif (params.flipArcText) {\n\t\t\t\t\t\t\tchars = line.split('');\n\t\t\t\t\t\t\tchars.reverse();\n\t\t\t\t\t\t\tline = chars.join('');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnchars = line.length;\n\t\t\t\t\t\tctx.rotate(-(PI * params.letterSpacing * (nchars - 1)) / 2);\n\t\t\t\t\t\t// Loop through characters on each line\n\t\t\t\t\t\tfor (c = 0; c < nchars; c += 1) {\n\t\t\t\t\t\t\tch = line[c];\n\t\t\t\t\t\t\t// If character is not the first character\n\t\t\t\t\t\t\tif (c !== 0) {\n\t\t\t\t\t\t\t\t// Rotate character onto arc\n\t\t\t\t\t\t\t\tctx.rotate(PI * params.letterSpacing);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tctx.save();\n\t\t\t\t\t\t\tctx.translate(0, -params.radius);\n\t\t\t\t\t\t\tif (params.flipArcText) {\n\t\t\t\t\t\t\t\tctx.scale(-1, -1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tctx.fillText(ch, 0, 0);\n\t\t\t\t\t\t\t// Prevent extra shadow created by stroke (but only when fill is present)\n\t\t\t\t\t\t\tif (params.fillStyle !== 'transparent') {\n\t\t\t\t\t\t\t\tctx.shadowColor = 'transparent';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (params.strokeWidth !== 0) {\n\t\t\t\t\t\t\t\t// Only stroke if the stroke is not 0\n\t\t\t\t\t\t\t\tctx.strokeText(ch, 0, 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparams.radius -= fontSize;\n\t\t\t\t\t\tparams.letterSpacing += fontSize / (constantCloseness * 2 * PI);\n\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Draw each line of text separately\n\t\t\t\t\tfor (l = 0; l < lines.length; l += 1) {\n\t\t\t\t\t\tline = lines[l];\n\t\t\t\t\t\t// Add line offset to center point, but subtract some to center everything\n\t\t\t\t\t\ty = params.y + (l * params.height / lines.length) - (((lines.length - 1) * params.height / lines.length) / 2);\n\n\t\t\t\t\t\tctx.shadowColor = params.shadowColor;\n\n\t\t\t\t\t\t// Fill & stroke text\n\t\t\t\t\t\tctx.fillText(line, x, y);\n\t\t\t\t\t\t// Prevent extra shadow created by stroke (but only when fill is present)\n\t\t\t\t\t\tif (params.fillStyle !== 'transparent') {\n\t\t\t\t\t\t\tctx.shadowColor = 'transparent';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (params.strokeWidth !== 0) {\n\t\t\t\t\t\t\t// Only stroke if the stroke is not 0\n\t\t\t\t\t\t\tctx.strokeText(line, x, y);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Adjust bounding box according to text baseline\n\t\t\t\ty = 0;\n\t\t\t\tif (params.baseline === 'top') {\n\t\t\t\t\ty += params.height / 2;\n\t\t\t\t} else if (params.baseline === 'bottom') {\n\t\t\t\t\ty -= params.height / 2;\n\t\t\t\t}\n\n\t\t\t\t// Detect jCanvas events\n\t\t\t\tif (params._event) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.rect(\n\t\t\t\t\t\tparams.x - (params.width / 2),\n\t\t\t\t\t\tparams.y - (params.height / 2) + y,\n\t\t\t\t\t\tparams.width,\n\t\t\t\t\t\tparams.height\n\t\t\t\t\t);\n\t\t\t\t\t_detectEvents($canvases[e], ctx, params);\n\t\t\t\t\t// Close path and configure masking\n\t\t\t\t\tctx.closePath();\n\t\t\t\t}\n\t\t\t\t_restoreTransform(ctx, params);\n\n\t\t\t}\n\t\t}\n\t}\n\t// Cache jCanvas parameters object for efficiency\n\tcaches.propCache = params;\n\treturn $canvases;\n};\n\n// Measures text width/height using the given parameters\n$.fn.measureText = function measureText(args) {\n\tvar $canvases = this, ctx,\n\t\tparams, lines;\n\n\t// Attempt to retrieve layer\n\tparams = $canvases.getLayer(args);\n\t// If layer does not exist or if returned object is not a jCanvas layer\n\tif (!params || (params && !params._layer)) {\n\t\tparams = new jCanvasObject(args);\n\t}\n\n\tctx = _getContext($canvases[0]);\n\tif (ctx) {\n\n\t\t// Set canvas font using given properties\n\t\t_setCanvasFont($canvases[0], ctx, params);\n\t\t// Calculate width and height of text\n\t\tif (params.maxWidth !== null) {\n\t\t\tlines = _wrapText(ctx, params);\n\t\t} else {\n\t\t\tlines = params.text.split('\\n');\n\t\t}\n\t\t_measureText($canvases[0], ctx, params, lines);\n\n\n\t}\n\n\treturn params;\n};\n\n/* Image API */\n\n// Draws image on canvas\n$.fn.drawImage = function drawImage(args) {\n\tvar $canvases = this, canvas, e, ctx, data,\n\t\tparams, layer,\n\t\timg, imgCtx, source,\n\t\timageCache = caches.imageCache;\n\n\t// Draw image function\n\tfunction draw(canvas, ctx, data, params, layer) {\n\n\t\t// If width and sWidth are not defined, use image width\n\t\tif (params.width === null && params.sWidth === null) {\n\t\t\tparams.width = params.sWidth = img.width;\n\t\t}\n\t\t// If width and sHeight are not defined, use image height\n\t\tif (params.height === null && params.sHeight === null) {\n\t\t\tparams.height = params.sHeight = img.height;\n\t\t}\n\n\t\t// Ensure image layer's width and height are accurate\n\t\tif (layer) {\n\t\t\tlayer.width = params.width;\n\t\t\tlayer.height = params.height;\n\t\t}\n\n\t\t// Only crop image if all cropping properties are given\n\t\tif (params.sWidth !== null && params.sHeight !== null && params.sx !== null && params.sy !== null) {\n\n\t\t\t// If width is not defined, use the given sWidth\n\t\t\tif (params.width === null) {\n\t\t\t\tparams.width = params.sWidth;\n\t\t\t}\n\t\t\t// If height is not defined, use the given sHeight\n\t\t\tif (params.height === null) {\n\t\t\t\tparams.height = params.sHeight;\n\t\t\t}\n\n\t\t\t// Optionally crop from top-left corner of region\n\t\t\tif (params.cropFromCenter) {\n\t\t\t\tparams.sx += params.sWidth / 2;\n\t\t\t\tparams.sy += params.sHeight / 2;\n\t\t\t}\n\n\t\t\t// Ensure cropped region does not escape image boundaries\n\n\t\t\t// Top\n\t\t\tif ((params.sy - (params.sHeight / 2)) < 0) {\n\t\t\t\tparams.sy = (params.sHeight / 2);\n\t\t\t}\n\t\t\t// Bottom\n\t\t\tif ((params.sy + (params.sHeight / 2)) > img.height) {\n\t\t\t\tparams.sy = img.height - (params.sHeight / 2);\n\t\t\t}\n\t\t\t// Left\n\t\t\tif ((params.sx - (params.sWidth / 2)) < 0) {\n\t\t\t\tparams.sx = (params.sWidth / 2);\n\t\t\t}\n\t\t\t// Right\n\t\t\tif ((params.sx + (params.sWidth / 2)) > img.width) {\n\t\t\t\tparams.sx = img.width - (params.sWidth / 2);\n\t\t\t}\n\n\t\t\t_transformShape(canvas, ctx, params, params.width, params.height);\n\t\t\t_setGlobalProps(canvas, ctx, params);\n\n\t\t\t// Draw image\n\t\t\tctx.drawImage(\n\t\t\t\timg,\n\t\t\t\tparams.sx - (params.sWidth / 2),\n\t\t\t\tparams.sy - (params.sHeight / 2),\n\t\t\t\tparams.sWidth,\n\t\t\t\tparams.sHeight,\n\t\t\t\tparams.x - (params.width / 2),\n\t\t\t\tparams.y - (params.height / 2),\n\t\t\t\tparams.width,\n\t\t\t\tparams.height\n\t\t\t);\n\n\t\t} else {\n\t\t\t// Show entire image if no crop region is defined\n\n\t\t\t_transformShape(canvas, ctx, params, params.width, params.height);\n\t\t\t_setGlobalProps(canvas, ctx, params);\n\n\t\t\t// Draw image on canvas\n\t\t\tctx.drawImage(\n\t\t\t\timg,\n\t\t\t\tparams.x - (params.width / 2),\n\t\t\t\tparams.y - (params.height / 2),\n\t\t\t\tparams.width,\n\t\t\t\tparams.height\n\t\t\t);\n\n\t\t}\n\n\t\t// Draw invisible rectangle to allow for events and masking\n\t\tctx.beginPath();\n\t\tctx.rect(\n\t\t\tparams.x - (params.width / 2),\n\t\t\tparams.y - (params.height / 2),\n\t\t\tparams.width,\n\t\t\tparams.height\n\t\t);\n\t\t// Check for jCanvas events\n\t\t_detectEvents(canvas, ctx, params);\n\t\t// Close path and configure masking\n\t\tctx.closePath();\n\t\t_restoreTransform(ctx, params);\n\t\t_enableMasking(ctx, data, params);\n\t}\n\t// On load function\n\tfunction onload(canvas, ctx, data, params, layer) {\n\t\treturn function () {\n\t\t\tvar $canvas = $(canvas);\n\t\t\tdraw(canvas, ctx, data, params, layer);\n\t\t\tif (params.layer) {\n\t\t\t\t// Trigger 'load' event for layers\n\t\t\t\t_triggerLayerEvent($canvas, data, layer, 'load');\n\t\t\t} else if (params.load) {\n\t\t\t\t// Run 'load' callback for non-layers\n\t\t\t\tparams.load.call($canvas[0], layer);\n\t\t\t}\n\t\t\t// Continue drawing successive layers after this image layer has loaded\n\t\t\tif (params.layer) {\n\t\t\t\t// Store list of previous masks for each layer\n\t\t\t\tlayer._masks = data.transforms.masks.slice(0);\n\t\t\t\tif (params._next) {\n\t\t\t\t\t// Draw successive layers\n\t\t\t\t\tvar complete = data.drawLayersComplete;\n\t\t\t\t\tdelete data.drawLayersComplete;\n\t\t\t\t\t$canvas.drawLayers({\n\t\t\t\t\t\tclear: false,\n\t\t\t\t\t\tresetFire: true,\n\t\t\t\t\t\tindex: params._next,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tcanvas = $canvases[e];\n\t\tctx = _getContext($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tdata = _getCanvasData($canvases[e]);\n\t\t\tparams = new jCanvasObject(args);\n\t\t\tlayer = _addLayer($canvases[e], params, args, drawImage);\n\t\t\tif (params.visible) {\n\n\t\t\t\t// Cache the given source\n\t\t\t\tsource = params.source;\n\n\t\t\t\timgCtx = source.getContext;\n\t\t\t\tif (source.src || imgCtx) {\n\t\t\t\t\t// Use image or canvas element if given\n\t\t\t\t\timg = source;\n\t\t\t\t} else if (source) {\n\t\t\t\t\tif (imageCache[source] && imageCache[source].complete) {\n\t\t\t\t\t\t// Get the image element from the cache if possible\n\t\t\t\t\t\timg = imageCache[source];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Otherwise, get the image from the given source URL\n\t\t\t\t\t\timg = new Image();\n\t\t\t\t\t\t// If source URL is not a data URL\n\t\t\t\t\t\tif (!source.match(/^data:/i)) {\n\t\t\t\t\t\t\t// Set crossOrigin for this image\n\t\t\t\t\t\t\timg.crossOrigin = params.crossOrigin;\n\t\t\t\t\t\t}\n\t\t\t\t\t\timg.src = source;\n\t\t\t\t\t\t// Save image in cache for improved performance\n\t\t\t\t\t\timageCache[source] = img;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (img) {\n\t\t\t\t\tif (img.complete || imgCtx) {\n\t\t\t\t\t\t// Draw image if already loaded\n\t\t\t\t\t\tonload(canvas, ctx, data, params, layer)();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Otherwise, draw image when it loads\n\t\t\t\t\t\timg.onload = onload(canvas, ctx, data, params, layer);\n\t\t\t\t\t\t// Fix onload() bug in IE9\n\t\t\t\t\t\timg.src = img.src;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Creates a canvas pattern object\n$.fn.createPattern = function createPattern(args) {\n\tvar $canvases = this, ctx,\n\t\tparams,\n\t\timg, imgCtx,\n\t\tpattern, source;\n\n\t// Function to be called when pattern loads\n\tfunction onload() {\n\t\t// Create pattern\n\t\tpattern = ctx.createPattern(img, params.repeat);\n\t\t// Run callback function if defined\n\t\tif (params.load) {\n\t\t\tparams.load.call($canvases[0], pattern);\n\t\t}\n\t}\n\n\tctx = _getContext($canvases[0]);\n\tif (ctx) {\n\n\t\tparams = new jCanvasObject(args);\n\n\t\t// Cache the given source\n\t\tsource = params.source;\n\n\t\t// Draw when image is loaded (if load() callback function is defined)\n\n\t\tif (isFunction(source)) {\n\t\t\t// Draw pattern using function if given\n\n\t\t\timg = $('<canvas />')[0];\n\t\t\timg.width = params.width;\n\t\t\timg.height = params.height;\n\t\t\timgCtx = _getContext(img);\n\t\t\tsource.call(img, imgCtx);\n\t\t\tonload();\n\n\t\t} else {\n\t\t\t// Otherwise, draw pattern using source image\n\n\t\t\timgCtx = source.getContext;\n\t\t\tif (source.src || imgCtx) {\n\t\t\t\t// Use image element if given\n\t\t\t\timg = source;\n\t\t\t} else {\n\t\t\t\t// Use URL if given to get the image\n\t\t\t\timg = new Image();\n\t\t\t\t// If source URL is not a data URL\n\t\t\t\tif (!source.match(/^data:/i)) {\n\t\t\t\t\t// Set crossOrigin for this image\n\t\t\t\t\timg.crossOrigin = params.crossOrigin;\n\t\t\t\t}\n\t\t\t\timg.src = source;\n\t\t\t}\n\n\t\t\t// Create pattern if already loaded\n\t\t\tif (img.complete || imgCtx) {\n\t\t\t\tonload();\n\t\t\t} else {\n\t\t\t\timg.onload = onload;\n\t\t\t\t// Fix onload() bug in IE9\n\t\t\t\timg.src = img.src;\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tpattern = null;\n\n\t}\n\treturn pattern;\n};\n\n// Creates a canvas gradient object\n$.fn.createGradient = function createGradient(args) {\n\tvar $canvases = this, ctx,\n\t\tparams,\n\t\tgradient,\n\t\tstops = [], nstops,\n\t\tstart, end,\n\t\ti, a, n, p;\n\n\tparams = new jCanvasObject(args);\n\tctx = _getContext($canvases[0]);\n\tif (ctx) {\n\n\t\t// Gradient coordinates must be defined\n\t\tparams.x1 = params.x1 || 0;\n\t\tparams.y1 = params.y1 || 0;\n\t\tparams.x2 = params.x2 || 0;\n\t\tparams.y2 = params.y2 || 0;\n\n\t\tif (params.r1 !== null && params.r2 !== null) {\n\t\t\t// Create radial gradient if chosen\n\t\t\tgradient = ctx.createRadialGradient(params.x1, params.y1, params.r1, params.x2, params.y2, params.r2);\n\t\t} else {\n\t\t\t// Otherwise, create a linear gradient by default\n\t\t\tgradient = ctx.createLinearGradient(params.x1, params.y1, params.x2, params.y2);\n\t\t}\n\n\t\t// Count number of color stops\n\t\tfor (i = 1; params['c' + i] !== undefined; i += 1) {\n\t\t\tif (params['s' + i] !== undefined) {\n\t\t\t\tstops.push(params['s' + i]);\n\t\t\t} else {\n\t\t\t\tstops.push(null);\n\t\t\t}\n\t\t}\n\t\tnstops = stops.length;\n\n\t\t// Define start stop if not already defined\n\t\tif (stops[0] === null) {\n\t\t\tstops[0] = 0;\n\t\t}\n\t\t// Define end stop if not already defined\n\t\tif (stops[nstops - 1] === null) {\n\t\t\tstops[nstops - 1] = 1;\n\t\t}\n\n\t\t// Loop through color stops to fill in the blanks\n\t\tfor (i = 0; i < nstops; i += 1) {\n\t\t\t// A progression, in this context, is defined as all of the color stops between and including two known color stops\n\n\t\t\tif (stops[i] !== null) {\n\t\t\t\t// Start a new progression if stop is a number\n\n\t\t\t\t// Number of stops in current progression\n\t\t\t\tn = 1;\n\t\t\t\t// Current iteration in current progression\n\t\t\t\tp = 0;\n\t\t\t\tstart = stops[i];\n\n\t\t\t\t// Look ahead to find end stop\n\t\t\t\tfor (a = (i + 1); a < nstops; a += 1) {\n\t\t\t\t\tif (stops[a] !== null) {\n\t\t\t\t\t\t// If this future stop is a number, make it the end stop for this progression\n\t\t\t\t\t\tend = stops[a];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Otherwise, keep looking ahead\n\t\t\t\t\t\tn += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Ensure start stop is not greater than end stop\n\t\t\t\tif (start > end) {\n\t\t\t\t\tstops[a] = stops[i];\n\t\t\t\t}\n\n\t\t\t} else if (stops[i] === null) {\n\t\t\t\t// Calculate stop if not initially given\n\t\t\t\tp += 1;\n\t\t\t\tstops[i] = start + (p * ((end - start) / n));\n\t\t\t}\n\t\t\t// Add color stop to gradient object\n\t\t\tgradient.addColorStop(stops[i], params['c' + (i + 1)]);\n\t\t}\n\n\t} else {\n\t\tgradient = null;\n\t}\n\treturn gradient;\n};\n\n// Manipulates pixels on the canvas\n$.fn.setPixels = function setPixels(args) {\n\tvar $canvases = this,\n\t\tcanvas, e, ctx, canvasData,\n\t\tparams,\n\t\tpx,\n\t\timgData, pixelData, i, len;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\tcanvas = $canvases[e];\n\t\tctx = _getContext(canvas);\n\t\tcanvasData = _getCanvasData($canvases[e]);\n\t\tif (ctx) {\n\n\t\t\tparams = new jCanvasObject(args);\n\t\t\t_addLayer(canvas, params, args, setPixels);\n\t\t\t_transformShape($canvases[e], ctx, params, params.width, params.height);\n\n\t\t\t// Use entire canvas of x, y, width, or height is not defined\n\t\t\tif (params.width === null || params.height === null) {\n\t\t\t\tparams.width = canvas.width;\n\t\t\t\tparams.height = canvas.height;\n\t\t\t\tparams.x = params.width / 2;\n\t\t\t\tparams.y = params.height / 2;\n\t\t\t}\n\n\t\t\tif (params.width !== 0 && params.height !== 0) {\n\t\t\t\t// Only set pixels if width and height are not zero\n\n\t\t\t\timgData = ctx.getImageData(\n\t\t\t\t\t(params.x - (params.width / 2)) * canvasData.pixelRatio,\n\t\t\t\t\t(params.y - (params.height / 2)) * canvasData.pixelRatio,\n\t\t\t\t\tparams.width * canvasData.pixelRatio,\n\t\t\t\t\tparams.height * canvasData.pixelRatio\n\t\t\t\t);\n\t\t\t\tpixelData = imgData.data;\n\t\t\t\tlen = pixelData.length;\n\n\t\t\t\t// Loop through pixels with the \"each\" callback function\n\t\t\t\tif (params.each) {\n\t\t\t\t\tfor (i = 0; i < len; i += 4) {\n\t\t\t\t\t\tpx = {\n\t\t\t\t\t\t\tr: pixelData[i],\n\t\t\t\t\t\t\tg: pixelData[i + 1],\n\t\t\t\t\t\t\tb: pixelData[i + 2],\n\t\t\t\t\t\t\ta: pixelData[i + 3]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tparams.each.call(canvas, px, params);\n\t\t\t\t\t\tpixelData[i] = px.r;\n\t\t\t\t\t\tpixelData[i + 1] = px.g;\n\t\t\t\t\t\tpixelData[i + 2] = px.b;\n\t\t\t\t\t\tpixelData[i + 3] = px.a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Put pixels on canvas\n\t\t\t\tctx.putImageData(\n\t\t\t\t\timgData,\n\t\t\t\t\t(params.x - (params.width / 2)) * canvasData.pixelRatio,\n\t\t\t\t\t(params.y - (params.height / 2)) * canvasData.pixelRatio\n\t\t\t\t);\n\t\t\t\t// Restore transformation\n\t\t\t\tctx.restore();\n\n\t\t\t}\n\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Retrieves canvas image as data URL\n$.fn.getCanvasImage = function getCanvasImage(type, quality) {\n\tvar $canvases = this, canvas,\n\t\tdataURL = null;\n\tif ($canvases.length !== 0) {\n\t\tcanvas = $canvases[0];\n\t\tif (canvas.toDataURL) {\n\t\t\t// JPEG quality defaults to 1\n\t\t\tif (quality === undefined) {\n\t\t\t\tquality = 1;\n\t\t\t}\n\t\t\tdataURL = canvas.toDataURL('image/' + type, quality);\n\t\t}\n\t}\n\treturn dataURL;\n};\n\n// Scales canvas based on the device's pixel ratio\n$.fn.detectPixelRatio = function detectPixelRatio(callback) {\n\tvar $canvases = this,\n\t\tcanvas, e, ctx,\n\t\tdevicePixelRatio, backingStoreRatio, ratio,\n\t\toldWidth, oldHeight,\n\t\tdata;\n\n\tfor (e = 0; e < $canvases.length; e += 1) {\n\t\t// Get canvas and its associated data\n\t\tcanvas = $canvases[e];\n\t\tctx = _getContext(canvas);\n\t\tdata = _getCanvasData($canvases[e]);\n\n\t\t// If canvas has not already been scaled with this method\n\t\tif (!data.scaled) {\n\n\t\t\t// Determine device pixel ratios\n\t\t\tdevicePixelRatio = window.devicePixelRatio || 1;\n\t\t\tbackingStoreRatio = ctx.webkitBackingStorePixelRatio ||\n\t\t\t\tctx.mozBackingStorePixelRatio ||\n\t\t\t\tctx.msBackingStorePixelRatio ||\n\t\t\t\tctx.oBackingStorePixelRatio ||\n\t\t\t\tctx.backingStorePixelRatio || 1;\n\n\t\t\t// Calculate general ratio based on the two given ratios\n\t\t\tratio = devicePixelRatio / backingStoreRatio;\n\n\t\t\tif (ratio !== 1) {\n\t\t\t\t// Scale canvas relative to ratio\n\n\t\t\t\t// Get the current canvas dimensions for future use\n\t\t\t\toldWidth = canvas.width;\n\t\t\t\toldHeight = canvas.height;\n\n\t\t\t\t// Resize canvas relative to the determined ratio\n\t\t\t\tcanvas.width = oldWidth * ratio;\n\t\t\t\tcanvas.height = oldHeight * ratio;\n\n\t\t\t\t// Scale canvas back to original dimensions via CSS\n\t\t\t\tcanvas.style.width = oldWidth + 'px';\n\t\t\t\tcanvas.style.height = oldHeight + 'px';\n\n\t\t\t\t// Scale context to counter the manual scaling of canvas\n\t\t\t\tctx.scale(ratio, ratio);\n\n\t\t\t}\n\n\t\t\t// Set pixel ratio on canvas data object\n\t\t\tdata.pixelRatio = ratio;\n\t\t\t// Ensure that this method can only be called once for any given canvas\n\t\t\tdata.scaled = true;\n\n\t\t\t// Call the given callback function with the ratio as its only argument\n\t\t\tif (callback) {\n\t\t\t\tcallback.call(canvas, ratio);\n\t\t\t}\n\n\t\t}\n\n\t}\n\treturn $canvases;\n};\n\n// Clears the jCanvas cache\njCanvas.clearCache = function clearCache() {\n\tvar cacheName;\n\tfor (cacheName in caches) {\n\t\tif (Object.prototype.hasOwnProperty.call(caches, cacheName)) {\n\t\t\tcaches[cacheName] = {};\n\t\t}\n\t}\n};\n\n// Enable canvas feature detection with $.support\n$.support.canvas = ($('<canvas />')[0].getContext !== undefined);\n\n// Export jCanvas functions\nextendObject(jCanvas, {\n\tdefaults: defaults,\n\tsetGlobalProps: _setGlobalProps,\n\ttransformShape: _transformShape,\n\tdetectEvents: _detectEvents,\n\tclosePath: _closePath,\n\tsetCanvasFont: _setCanvasFont,\n\tmeasureText: _measureText\n});\n$.jCanvas = jCanvas;\n$.jCanvasObject = jCanvasObject;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvdnVlL25vZGVfbW9kdWxlcy9qY2FudmFzL2Rpc3QvamNhbnZhcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLEtBQTBCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxtREFBbUQ7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0wsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMseUJBQXlCOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7O0FBRUE7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxRQUFROztBQUVoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx1QkFBdUI7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGtCQUFrQjs7QUFFakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHNCQUFzQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxjQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxrQkFBa0I7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx3QkFBd0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBLGVBQWUsa0JBQWtCOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLCtCQUErQjtBQUM3QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFlBQVk7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy92dWUvbm9kZV9tb2R1bGVzL2pjYW52YXMvZGlzdC9qY2FudmFzLmpzPzg0ODgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBqQ2FudmFzIHYyMS4wLjFcbiAqIENvcHlyaWdodCAyMDE3IENhbGViIEV2YW5zXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uIChqUXVlcnksIGdsb2JhbCwgZmFjdG9yeSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChqUXVlcnksIHcpIHtcblx0XHRcdHJldHVybiBmYWN0b3J5KGpRdWVyeSwgdyk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KGpRdWVyeSwgZ2xvYmFsKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5qUXVlcnkgOiB7fSwgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiAoJCwgd2luZG93KSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcblx0SW1hZ2UgPSB3aW5kb3cuSW1hZ2UsXG5cdEFycmF5ID0gd2luZG93LkFycmF5LFxuXHRnZXRDb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUsXG5cdE1hdGggPSB3aW5kb3cuTWF0aCxcblx0TnVtYmVyID0gd2luZG93Lk51bWJlcixcblx0cGFyc2VGbG9hdCA9IHdpbmRvdy5wYXJzZUZsb2F0O1xuXG4vLyBEZWZpbmUgbG9jYWwgYWxpYXNlcyB0byBmcmVxdWVudGx5IHVzZWQgcHJvcGVydGllc1xudmFyIGRlZmF1bHRzLFxuXHQvLyBBbGlhc2VzIHRvIGpRdWVyeSBtZXRob2RzXG5cdGV4dGVuZE9iamVjdCA9ICQuZXh0ZW5kLFxuXHRpbkFycmF5ID0gJC5pbkFycmF5LFxuXHR0eXBlT2YgPSBmdW5jdGlvbiAob3BlcmFuZCkge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob3BlcmFuZClcblx0XHRcdC5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKTtcblx0fSxcblx0aXNQbGFpbk9iamVjdCA9ICQuaXNQbGFpbk9iamVjdCxcblx0Ly8gTWF0aCBjb25zdGFudHMgYW5kIGZ1bmN0aW9uc1xuXHRQSSA9IE1hdGguUEksXG5cdHJvdW5kID0gTWF0aC5yb3VuZCxcblx0YWJzID0gTWF0aC5hYnMsXG5cdHNpbiA9IE1hdGguc2luLFxuXHRjb3MgPSBNYXRoLmNvcyxcblx0YXRhbjIgPSBNYXRoLmF0YW4yLFxuXHQvLyBUaGUgQXJyYXkgc2xpY2UoKSBtZXRob2Rcblx0YXJyYXlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcblx0Ly8galF1ZXJ5J3MgaW50ZXJuYWwgZXZlbnQgbm9ybWFsaXphdGlvbiBmdW5jdGlvblxuXHRqUXVlcnlFdmVudEZpeCA9ICQuZXZlbnQuZml4LFxuXHQvLyBPYmplY3QgZm9yIHN0b3JpbmcgYSBudW1iZXIgb2YgaW50ZXJuYWwgcHJvcGVydHkgbWFwc1xuXHRtYXBzID0ge30sXG5cdC8vIGpRdWVyeSBpbnRlcm5hbCBjYWNoZXNcblx0Y2FjaGVzID0ge1xuXHRcdGRhdGFDYWNoZToge30sXG5cdFx0cHJvcENhY2hlOiB7fSxcblx0XHRpbWFnZUNhY2hlOiB7fVxuXHR9LFxuXHQvLyBCYXNlIHRyYW5zZm9ybWF0aW9uc1xuXHRiYXNlVHJhbnNmb3JtcyA9IHtcblx0XHRyb3RhdGU6IDAsXG5cdFx0c2NhbGVYOiAxLFxuXHRcdHNjYWxlWTogMSxcblx0XHR0cmFuc2xhdGVYOiAwLFxuXHRcdHRyYW5zbGF0ZVk6IDAsXG5cdFx0Ly8gU3RvcmUgYWxsIHByZXZpb3VzIG1hc2tzXG5cdFx0bWFza3M6IFtdXG5cdH0sXG5cdC8vIE9iamVjdCBmb3Igc3RvcmluZyBDU1MtcmVsYXRlZCBwcm9wZXJ0aWVzXG5cdGNzcyA9IHt9LFxuXHR0YW5naWJsZUV2ZW50cyA9IFtcblx0XHQnbW91c2Vkb3duJyxcblx0XHQnbW91c2Vtb3ZlJyxcblx0XHQnbW91c2V1cCcsXG5cdFx0J21vdXNlb3ZlcicsXG5cdFx0J21vdXNlb3V0Jyxcblx0XHQndG91Y2hzdGFydCcsXG5cdFx0J3RvdWNobW92ZScsXG5cdFx0J3RvdWNoZW5kJ1xuXHRdO1xuXG4vLyBDb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgb2JqZWN0cyB0aGF0IGluaGVyaXQgZnJvbSBqQ2FudmFzIHByZWZlcmVuY2VzIGFuZCBkZWZhdWx0c1xuZnVuY3Rpb24gakNhbnZhc09iamVjdChhcmdzKSB7XG5cdHZhciBwYXJhbXMgPSB0aGlzLFxuXHRcdHByb3BOYW1lO1xuXHQvLyBDb3B5IHRoZSBnaXZlbiBwYXJhbWV0ZXJzIGludG8gbmV3IG9iamVjdFxuXHRmb3IgKHByb3BOYW1lIGluIGFyZ3MpIHtcblx0XHQvLyBEbyBub3QgbWVyZ2UgZGVmYXVsdHMgaW50byBwYXJhbWV0ZXJzXG5cdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmdzLCBwcm9wTmFtZSkpIHtcblx0XHRcdHBhcmFtc1twcm9wTmFtZV0gPSBhcmdzW3Byb3BOYW1lXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHBhcmFtcztcbn1cblxuLy8gakNhbnZhcyBvYmplY3QgaW4gd2hpY2ggZ2xvYmFsIHNldHRpbmdzIGFyZSBvdGhlciBkYXRhIGFyZSBzdG9yZWRcbnZhciBqQ2FudmFzID0ge1xuXHQvLyBFdmVudHMgb2JqZWN0IGZvciBzdG9yaW5nIGpDYW52YXMgZXZlbnQgaW5pdGlhdGlvbiBmdW5jdGlvbnNcblx0ZXZlbnRzOiB7fSxcblx0Ly8gT2JqZWN0IGNvbnRhaW5pbmcgYWxsIGpDYW52YXMgZXZlbnQgaG9va3Ncblx0ZXZlbnRIb29rczoge30sXG5cdC8vIFNldHRpbmdzIGZvciBlbmFibGluZyBmdXR1cmUgakNhbnZhcyBmZWF0dXJlc1xuXHRmdXR1cmU6IHt9XG59O1xuXG4vLyBqQ2FudmFzIGRlZmF1bHQgcHJvcGVydHkgdmFsdWVzXG5mdW5jdGlvbiBqQ2FudmFzRGVmYXVsdHMoKSB7XG5cdGV4dGVuZE9iamVjdCh0aGlzLCBqQ2FudmFzRGVmYXVsdHMuYmFzZURlZmF1bHRzKTtcbn1cbmpDYW52YXNEZWZhdWx0cy5iYXNlRGVmYXVsdHMgPSB7XG5cdGFsaWduOiAnY2VudGVyJyxcblx0YXJyb3dBbmdsZTogOTAsXG5cdGFycm93UmFkaXVzOiAwLFxuXHRhdXRvc2F2ZTogdHJ1ZSxcblx0YmFzZWxpbmU6ICdtaWRkbGUnLFxuXHRicmluZ1RvRnJvbnQ6IGZhbHNlLFxuXHRjY3c6IGZhbHNlLFxuXHRjbG9zZWQ6IGZhbHNlLFxuXHRjb21wb3NpdGluZzogJ3NvdXJjZS1vdmVyJyxcblx0Y29uY2F2aXR5OiAwLFxuXHRjb3JuZXJSYWRpdXM6IDAsXG5cdGNvdW50OiAxLFxuXHRjcm9wRnJvbUNlbnRlcjogdHJ1ZSxcblx0Y3Jvc3NPcmlnaW46IG51bGwsXG5cdGN1cnNvcnM6IG51bGwsXG5cdGRpc2FibGVFdmVudHM6IGZhbHNlLFxuXHRkcmFnZ2FibGU6IGZhbHNlLFxuXHRkcmFnR3JvdXBzOiBudWxsLFxuXHRncm91cHM6IG51bGwsXG5cdGRhdGE6IG51bGwsXG5cdGR4OiBudWxsLFxuXHRkeTogbnVsbCxcblx0ZW5kOiAzNjAsXG5cdGV2ZW50WDogbnVsbCxcblx0ZXZlbnRZOiBudWxsLFxuXHRmaWxsU3R5bGU6ICd0cmFuc3BhcmVudCcsXG5cdGZvbnRTdHlsZTogJ25vcm1hbCcsXG5cdGZvbnRTaXplOiAnMTJwdCcsXG5cdGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcblx0ZnJvbUNlbnRlcjogdHJ1ZSxcblx0aGVpZ2h0OiBudWxsLFxuXHRpbWFnZVNtb290aGluZzogdHJ1ZSxcblx0aW5EZWdyZWVzOiB0cnVlLFxuXHRpbnRhbmdpYmxlOiBmYWxzZSxcblx0aW5kZXg6IG51bGwsXG5cdGxldHRlclNwYWNpbmc6IG51bGwsXG5cdGxpbmVIZWlnaHQ6IDEsXG5cdGxheWVyOiBmYWxzZSxcblx0bWFzazogZmFsc2UsXG5cdG1heFdpZHRoOiBudWxsLFxuXHRtaXRlckxpbWl0OiAxMCxcblx0bmFtZTogbnVsbCxcblx0b3BhY2l0eTogMSxcblx0cjE6IG51bGwsXG5cdHIyOiBudWxsLFxuXHRyYWRpdXM6IDAsXG5cdHJlcGVhdDogJ3JlcGVhdCcsXG5cdHJlc3BlY3RBbGlnbjogZmFsc2UsXG5cdHJlc3RyaWN0RHJhZ1RvQXhpczogbnVsbCxcblx0cm90YXRlOiAwLFxuXHRyb3VuZGVkOiBmYWxzZSxcblx0c2NhbGU6IDEsXG5cdHNjYWxlWDogMSxcblx0c2NhbGVZOiAxLFxuXHRzaGFkb3dCbHVyOiAwLFxuXHRzaGFkb3dDb2xvcjogJ3RyYW5zcGFyZW50Jyxcblx0c2hhZG93U3Ryb2tlOiBmYWxzZSxcblx0c2hhZG93WDogMCxcblx0c2hhZG93WTogMCxcblx0c0hlaWdodDogbnVsbCxcblx0c2lkZXM6IDAsXG5cdHNvdXJjZTogJycsXG5cdHNwcmVhZDogMCxcblx0c3RhcnQ6IDAsXG5cdHN0cm9rZUNhcDogJ2J1dHQnLFxuXHRzdHJva2VEYXNoOiBudWxsLFxuXHRzdHJva2VEYXNoT2Zmc2V0OiAwLFxuXHRzdHJva2VKb2luOiAnbWl0ZXInLFxuXHRzdHJva2VTdHlsZTogJ3RyYW5zcGFyZW50Jyxcblx0c3Ryb2tlV2lkdGg6IDEsXG5cdHNXaWR0aDogbnVsbCxcblx0c3g6IG51bGwsXG5cdHN5OiBudWxsLFxuXHR0ZXh0OiAnJyxcblx0dHJhbnNsYXRlOiAwLFxuXHR0cmFuc2xhdGVYOiAwLFxuXHR0cmFuc2xhdGVZOiAwLFxuXHR0eXBlOiBudWxsLFxuXHR2aXNpYmxlOiB0cnVlLFxuXHR3aWR0aDogbnVsbCxcblx0eDogMCxcblx0eTogMFxufTtcbmRlZmF1bHRzID0gbmV3IGpDYW52YXNEZWZhdWx0cygpO1xuakNhbnZhc09iamVjdC5wcm90b3R5cGUgPSBkZWZhdWx0cztcblxuLyogSW50ZXJuYWwgaGVscGVyIG1ldGhvZHMgKi9cblxuLy8gRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gb3BlcmFuZCBpcyBhIHN0cmluZ1xuZnVuY3Rpb24gaXNTdHJpbmcob3BlcmFuZCkge1xuXHRyZXR1cm4gKHR5cGVPZihvcGVyYW5kKSA9PT0gJ3N0cmluZycpO1xufVxuXG4vLyBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBvcGVyYW5kIGlzIGEgZnVuY3Rpb25cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob3BlcmFuZCkge1xuXHRyZXR1cm4gKHR5cGVPZihvcGVyYW5kKSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8vIERldGVybWluZXMgaWYgdGhlIGdpdmVuIG9wZXJhbmQgaXMgbnVtZXJpY1xuZnVuY3Rpb24gaXNOdW1lcmljKG9wZXJhbmQpIHtcblx0cmV0dXJuICFpc05hTihOdW1iZXIob3BlcmFuZCkpICYmICFpc05hTihwYXJzZUZsb2F0KG9wZXJhbmQpKTtcbn1cblxuLy8gR2V0IDJEIGNvbnRleHQgZm9yIHRoZSBnaXZlbiBjYW52YXNcbmZ1bmN0aW9uIF9nZXRDb250ZXh0KGNhbnZhcykge1xuXHRyZXR1cm4gKGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCA/IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIDogbnVsbCk7XG59XG5cbi8vIENvZXJjZSBkZXNpZ25hdGVkIG51bWJlciBwcm9wZXJ0aWVzIGZyb20gc3RyaW5ncyB0byBudW1iZXJzXG5mdW5jdGlvbiBfY29lcmNlTnVtZXJpY1Byb3BzKHByb3BzKSB7XG5cdHZhciBwcm9wTmFtZSwgcHJvcFR5cGUsIHByb3BWYWx1ZTtcblx0Ly8gTG9vcCB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIGluIGdpdmVuIHByb3BlcnR5IG1hcFxuXHRmb3IgKHByb3BOYW1lIGluIHByb3BzKSB7XG5cdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcE5hbWUpKSB7XG5cdFx0XHRwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cdFx0XHRwcm9wVHlwZSA9IHR5cGVPZihwcm9wVmFsdWUpO1xuXHRcdFx0Ly8gSWYgcHJvcGVydHkgaXMgbm9uLWVtcHR5IHN0cmluZyBhbmQgdmFsdWUgaXMgbnVtZXJpY1xuXHRcdFx0aWYgKHByb3BUeXBlID09PSAnc3RyaW5nJyAmJiBpc051bWVyaWMocHJvcFZhbHVlKSAmJiBwcm9wTmFtZSAhPT0gJ3RleHQnKSB7XG5cdFx0XHRcdC8vIENvbnZlcnQgdmFsdWUgdG8gbnVtYmVyXG5cdFx0XHRcdHByb3BzW3Byb3BOYW1lXSA9IHBhcnNlRmxvYXQocHJvcFZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly8gRW5zdXJlIHZhbHVlIG9mIHRleHQgcHJvcGVydHkgaXMgYWx3YXlzIGEgc3RyaW5nXG5cdGlmIChwcm9wcy50ZXh0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRwcm9wcy50ZXh0ID0gU3RyaW5nKHByb3BzLnRleHQpO1xuXHR9XG59XG5cbi8vIENsb25lIHRoZSBnaXZlbiB0cmFuc2Zvcm1hdGlvbnMgb2JqZWN0XG5mdW5jdGlvbiBfY2xvbmVUcmFuc2Zvcm1zKHRyYW5zZm9ybXMpIHtcblx0Ly8gQ2xvbmUgdGhlIG9iamVjdCBpdHNlbGZcblx0dHJhbnNmb3JtcyA9IGV4dGVuZE9iamVjdCh7fSwgdHJhbnNmb3Jtcyk7XG5cdC8vIENsb25lIHRoZSBvYmplY3QncyBtYXNrcyBhcnJheVxuXHR0cmFuc2Zvcm1zLm1hc2tzID0gdHJhbnNmb3Jtcy5tYXNrcy5zbGljZSgwKTtcblx0cmV0dXJuIHRyYW5zZm9ybXM7XG59XG5cbi8vIFNhdmUgY2FudmFzIGNvbnRleHQgYW5kIHVwZGF0ZSB0cmFuc2Zvcm1hdGlvbiBzdGFja1xuZnVuY3Rpb24gX3NhdmVDYW52YXMoY3R4LCBkYXRhKSB7XG5cdHZhciB0cmFuc2Zvcm1zO1xuXHRjdHguc2F2ZSgpO1xuXHR0cmFuc2Zvcm1zID0gX2Nsb25lVHJhbnNmb3JtcyhkYXRhLnRyYW5zZm9ybXMpO1xuXHRkYXRhLnNhdmVkVHJhbnNmb3Jtcy5wdXNoKHRyYW5zZm9ybXMpO1xufVxuXG4vLyBSZXN0b3JlIGNhbnZhcyBjb250ZXh0IHVwZGF0ZSB0cmFuc2Zvcm1hdGlvbiBzdGFja1xuZnVuY3Rpb24gX3Jlc3RvcmVDYW52YXMoY3R4LCBkYXRhKSB7XG5cdGlmIChkYXRhLnNhdmVkVHJhbnNmb3Jtcy5sZW5ndGggPT09IDApIHtcblx0XHQvLyBSZXNldCB0cmFuc2Zvcm1hdGlvbiBzdGF0ZSBpZiBpdCBjYW4ndCBiZSByZXN0b3JlZCBhbnkgbW9yZVxuXHRcdGRhdGEudHJhbnNmb3JtcyA9IF9jbG9uZVRyYW5zZm9ybXMoYmFzZVRyYW5zZm9ybXMpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFJlc3RvcmUgY2FudmFzIGNvbnRleHRcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdC8vIFJlc3RvcmUgY3VycmVudCB0cmFuc2Zvcm0gc3RhdGUgdG8gdGhlIGxhc3Qgc2F2ZWQgc3RhdGVcblx0XHRkYXRhLnRyYW5zZm9ybXMgPSBkYXRhLnNhdmVkVHJhbnNmb3Jtcy5wb3AoKTtcblx0fVxufVxuXG4vLyBTZXQgdGhlIHN0eWxlIHdpdGggdGhlIGdpdmVuIG5hbWVcbmZ1bmN0aW9uIF9zZXRTdHlsZShjYW52YXMsIGN0eCwgcGFyYW1zLCBzdHlsZU5hbWUpIHtcblx0aWYgKHBhcmFtc1tzdHlsZU5hbWVdKSB7XG5cdFx0aWYgKGlzRnVuY3Rpb24ocGFyYW1zW3N0eWxlTmFtZV0pKSB7XG5cdFx0XHQvLyBIYW5kbGUgZnVuY3Rpb25zXG5cdFx0XHRjdHhbc3R5bGVOYW1lXSA9IHBhcmFtc1tzdHlsZU5hbWVdLmNhbGwoY2FudmFzLCBwYXJhbXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBIYW5kbGUgc3RyaW5nIHZhbHVlc1xuXHRcdFx0Y3R4W3N0eWxlTmFtZV0gPSBwYXJhbXNbc3R5bGVOYW1lXTtcblx0XHR9XG5cdH1cbn1cblxuLy8gU2V0IGNhbnZhcyBjb250ZXh0IHByb3BlcnRpZXNcbmZ1bmN0aW9uIF9zZXRHbG9iYWxQcm9wcyhjYW52YXMsIGN0eCwgcGFyYW1zKSB7XG5cdF9zZXRTdHlsZShjYW52YXMsIGN0eCwgcGFyYW1zLCAnZmlsbFN0eWxlJyk7XG5cdF9zZXRTdHlsZShjYW52YXMsIGN0eCwgcGFyYW1zLCAnc3Ryb2tlU3R5bGUnKTtcblx0Y3R4LmxpbmVXaWR0aCA9IHBhcmFtcy5zdHJva2VXaWR0aDtcblx0Ly8gT3B0aW9uYWxseSByb3VuZCBjb3JuZXJzIGZvciBwYXRoc1xuXHRpZiAocGFyYW1zLnJvdW5kZWQpIHtcblx0XHRjdHgubGluZUNhcCA9IGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XG5cdH0gZWxzZSB7XG5cdFx0Y3R4LmxpbmVDYXAgPSBwYXJhbXMuc3Ryb2tlQ2FwO1xuXHRcdGN0eC5saW5lSm9pbiA9IHBhcmFtcy5zdHJva2VKb2luO1xuXHRcdGN0eC5taXRlckxpbWl0ID0gcGFyYW1zLm1pdGVyTGltaXQ7XG5cdH1cblx0Ly8gUmVzZXQgc3Ryb2tlRGFzaCBpZiBudWxsXG5cdGlmICghcGFyYW1zLnN0cm9rZURhc2gpIHtcblx0XHRwYXJhbXMuc3Ryb2tlRGFzaCA9IFtdO1xuXHR9XG5cdC8vIERhc2hlZCBsaW5lc1xuXHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0Y3R4LnNldExpbmVEYXNoKHBhcmFtcy5zdHJva2VEYXNoKTtcblx0fVxuXHRjdHgud2Via2l0TGluZURhc2ggPSBwYXJhbXMuc3Ryb2tlRGFzaDtcblx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gY3R4LndlYmtpdExpbmVEYXNoT2Zmc2V0ID0gY3R4Lm1vekRhc2hPZmZzZXQgPSBwYXJhbXMuc3Ryb2tlRGFzaE9mZnNldDtcblx0Ly8gRHJvcCBzaGFkb3dcblx0Y3R4LnNoYWRvd09mZnNldFggPSBwYXJhbXMuc2hhZG93WDtcblx0Y3R4LnNoYWRvd09mZnNldFkgPSBwYXJhbXMuc2hhZG93WTtcblx0Y3R4LnNoYWRvd0JsdXIgPSBwYXJhbXMuc2hhZG93Qmx1cjtcblx0Y3R4LnNoYWRvd0NvbG9yID0gcGFyYW1zLnNoYWRvd0NvbG9yO1xuXHQvLyBPcGFjaXR5IGFuZCBjb21wb3NpdGUgb3BlcmF0aW9uXG5cdGN0eC5nbG9iYWxBbHBoYSA9IHBhcmFtcy5vcGFjaXR5O1xuXHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gcGFyYW1zLmNvbXBvc2l0aW5nO1xuXHQvLyBTdXBwb3J0IGNyb3NzLWJyb3dzZXIgdG9nZ2xpbmcgb2YgaW1hZ2Ugc21vb3RoaW5nXG5cdGlmIChwYXJhbXMuaW1hZ2VTbW9vdGhpbmcpIHtcblx0XHRjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gcGFyYW1zLmltYWdlU21vb3RoaW5nO1xuXHR9XG59XG5cbi8vIE9wdGlvbmFsbHkgZW5hYmxlIG1hc2tpbmcgc3VwcG9ydCBmb3IgdGhpcyBwYXRoXG5mdW5jdGlvbiBfZW5hYmxlTWFza2luZyhjdHgsIGRhdGEsIHBhcmFtcykge1xuXHRpZiAocGFyYW1zLm1hc2spIHtcblx0XHQvLyBJZiBqQ2FudmFzIGF1dG9zYXZlIGlzIGVuYWJsZWRcblx0XHRpZiAocGFyYW1zLmF1dG9zYXZlKSB7XG5cdFx0XHQvLyBBdXRvbWF0aWNhbGx5IHNhdmUgdHJhbnNmb3JtYXRpb24gc3RhdGUgYnkgZGVmYXVsdFxuXHRcdFx0X3NhdmVDYW52YXMoY3R4LCBkYXRhKTtcblx0XHR9XG5cdFx0Ly8gQ2xpcCB0aGUgY3VycmVudCBwYXRoXG5cdFx0Y3R4LmNsaXAoKTtcblx0XHQvLyBLZWVwIHRyYWNrIG9mIGN1cnJlbnQgbWFza3Ncblx0XHRkYXRhLnRyYW5zZm9ybXMubWFza3MucHVzaChwYXJhbXMuX2FyZ3MpO1xuXHR9XG59XG5cbi8vIFJlc3RvcmUgaW5kaXZpZHVhbCBzaGFwZSB0cmFuc2Zvcm1hdGlvblxuZnVuY3Rpb24gX3Jlc3RvcmVUcmFuc2Zvcm0oY3R4LCBwYXJhbXMpIHtcblx0Ly8gSWYgc2hhcGUgaGFzIGJlZW4gdHJhbnNmb3JtZWQgYnkgakNhbnZhc1xuXHRpZiAocGFyYW1zLl90cmFuc2Zvcm1lZCkge1xuXHRcdC8vIFJlc3RvcmUgY2FudmFzIGNvbnRleHRcblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9XG59XG5cbi8vIENsb3NlIGN1cnJlbnQgY2FudmFzIHBhdGhcbmZ1bmN0aW9uIF9jbG9zZVBhdGgoY2FudmFzLCBjdHgsIHBhcmFtcykge1xuXHR2YXIgZGF0YTtcblxuXHQvLyBPcHRpb25hbGx5IGNsb3NlIHBhdGhcblx0aWYgKHBhcmFtcy5jbG9zZWQpIHtcblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdH1cblxuXHRpZiAocGFyYW1zLnNoYWRvd1N0cm9rZSAmJiBwYXJhbXMuc3Ryb2tlV2lkdGggIT09IDApIHtcblx0XHQvLyBFeHRlbmQgdGhlIHNoYWRvdyB0byBpbmNsdWRlIHRoZSBzdHJva2Ugb2YgYSBkcmF3aW5nXG5cblx0XHQvLyBBZGQgYSBzdHJva2Ugc2hhZG93IGJ5IHN0cm9raW5nIGJlZm9yZSBmaWxsaW5nXG5cdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdGN0eC5maWxsKCk7XG5cdFx0Ly8gRW5zdXJlIHRoZSBiZWxvdyBzdHJva2luZyBkb2VzIG5vdCBpbmhlcml0IGEgc2hhZG93XG5cdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3RyYW5zcGFyZW50Jztcblx0XHRjdHguc2hhZG93Qmx1ciA9IDA7XG5cdFx0Ly8gU3Ryb2tlIG92ZXIgZmlsbCBhcyB1c3VhbFxuXHRcdGN0eC5zdHJva2UoKTtcblxuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHNoYWRvd1N0cm9rZSBpcyBub3QgZW5hYmxlZCwgc3Ryb2tlICYgZmlsbCBhcyB1c3VhbFxuXG5cdFx0Y3R4LmZpbGwoKTtcblx0XHQvLyBQcmV2ZW50IGV4dHJhIHNoYWRvdyBjcmVhdGVkIGJ5IHN0cm9rZSAoYnV0IG9ubHkgd2hlbiBmaWxsIGlzIHByZXNlbnQpXG5cdFx0aWYgKHBhcmFtcy5maWxsU3R5bGUgIT09ICd0cmFuc3BhcmVudCcpIHtcblx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICd0cmFuc3BhcmVudCc7XG5cdFx0fVxuXHRcdGlmIChwYXJhbXMuc3Ryb2tlV2lkdGggIT09IDApIHtcblx0XHRcdC8vIE9ubHkgc3Ryb2tlIGlmIHRoZSBzdHJva2UgaXMgbm90IDBcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cblx0fVxuXG5cdC8vIE9wdGlvbmFsbHkgY2xvc2UgcGF0aFxuXHRpZiAoIXBhcmFtcy5jbG9zZWQpIHtcblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdH1cblxuXHQvLyBSZXN0b3JlIGluZGl2aWR1YWwgc2hhcGUgdHJhbnNmb3JtYXRpb25cblx0X3Jlc3RvcmVUcmFuc2Zvcm0oY3R4LCBwYXJhbXMpO1xuXG5cdC8vIE1hc2sgc2hhcGUgaWYgY2hvc2VuXG5cdGlmIChwYXJhbXMubWFzaykge1xuXHRcdC8vIFJldHJpZXZlIGNhbnZhcyBkYXRhXG5cdFx0ZGF0YSA9IF9nZXRDYW52YXNEYXRhKGNhbnZhcyk7XG5cdFx0X2VuYWJsZU1hc2tpbmcoY3R4LCBkYXRhLCBwYXJhbXMpO1xuXHR9XG5cbn1cblxuLy8gVHJhbnNmb3JtICh0cmFuc2xhdGUsIHNjYWxlLCBvciByb3RhdGUpIHNoYXBlXG5mdW5jdGlvbiBfdHJhbnNmb3JtU2hhcGUoY2FudmFzLCBjdHgsIHBhcmFtcywgd2lkdGgsIGhlaWdodCkge1xuXG5cdC8vIEdldCBjb252ZXJzaW9uIGZhY3RvciBmb3IgcmFkaWFuc1xuXHRwYXJhbXMuX3RvUmFkID0gKHBhcmFtcy5pbkRlZ3JlZXMgPyAoUEkgLyAxODApIDogMSk7XG5cblx0cGFyYW1zLl90cmFuc2Zvcm1lZCA9IHRydWU7XG5cdGN0eC5zYXZlKCk7XG5cblx0Ly8gT3B0aW9uYWxseSBtZWFzdXJlICh4LCB5KSBwb3NpdGlvbiBmcm9tIHRvcC1sZWZ0IGNvcm5lclxuXHRpZiAoIXBhcmFtcy5mcm9tQ2VudGVyICYmICFwYXJhbXMuX2NlbnRlcmVkICYmIHdpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHQvLyBBbHdheXMgZHJhdyBmcm9tIGNlbnRlciB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZFxuXHRcdGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aGVpZ2h0ID0gd2lkdGg7XG5cdFx0fVxuXHRcdHBhcmFtcy54ICs9IHdpZHRoIC8gMjtcblx0XHRwYXJhbXMueSArPSBoZWlnaHQgLyAyO1xuXHRcdHBhcmFtcy5fY2VudGVyZWQgPSB0cnVlO1xuXHR9XG5cdC8vIE9wdGlvbmFsbHkgcm90YXRlIHNoYXBlXG5cdGlmIChwYXJhbXMucm90YXRlKSB7XG5cdFx0X3JvdGF0ZUNhbnZhcyhjdHgsIHBhcmFtcywgbnVsbCk7XG5cdH1cblx0Ly8gT3B0aW9uYWxseSBzY2FsZSBzaGFwZVxuXHRpZiAocGFyYW1zLnNjYWxlICE9PSAxIHx8IHBhcmFtcy5zY2FsZVggIT09IDEgfHwgcGFyYW1zLnNjYWxlWSAhPT0gMSkge1xuXHRcdF9zY2FsZUNhbnZhcyhjdHgsIHBhcmFtcywgbnVsbCk7XG5cdH1cblx0Ly8gT3B0aW9uYWxseSB0cmFuc2xhdGUgc2hhcGVcblx0aWYgKHBhcmFtcy50cmFuc2xhdGUgfHwgcGFyYW1zLnRyYW5zbGF0ZVggfHwgcGFyYW1zLnRyYW5zbGF0ZVkpIHtcblx0XHRfdHJhbnNsYXRlQ2FudmFzKGN0eCwgcGFyYW1zLCBudWxsKTtcblx0fVxuXG59XG5cbi8qIFBsdWdpbiBBUEkgKi9cblxuLy8gRXh0ZW5kIGpDYW52YXMgd2l0aCBhIHVzZXItZGVmaW5lZCBtZXRob2RcbmpDYW52YXMuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKHBsdWdpbikge1xuXG5cdC8vIENyZWF0ZSBwbHVnaW5cblx0aWYgKHBsdWdpbi5uYW1lKSB7XG5cdFx0Ly8gTWVyZ2UgcHJvcGVydGllcyB3aXRoIGRlZmF1bHRzXG5cdFx0aWYgKHBsdWdpbi5wcm9wcykge1xuXHRcdFx0ZXh0ZW5kT2JqZWN0KGRlZmF1bHRzLCBwbHVnaW4ucHJvcHMpO1xuXHRcdH1cblx0XHQvLyBEZWZpbmUgcGx1Z2luIG1ldGhvZFxuXHRcdCQuZm5bcGx1Z2luLm5hbWVdID0gZnVuY3Rpb24gc2VsZihhcmdzKSB7XG5cdFx0XHR2YXIgJGNhbnZhc2VzID0gdGhpcywgY2FudmFzLCBlLCBjdHgsXG5cdFx0XHRcdHBhcmFtcztcblxuXHRcdFx0Zm9yIChlID0gMDsgZSA8ICRjYW52YXNlcy5sZW5ndGg7IGUgKz0gMSkge1xuXHRcdFx0XHRjYW52YXMgPSAkY2FudmFzZXNbZV07XG5cdFx0XHRcdGN0eCA9IF9nZXRDb250ZXh0KGNhbnZhcyk7XG5cdFx0XHRcdGlmIChjdHgpIHtcblxuXHRcdFx0XHRcdHBhcmFtcyA9IG5ldyBqQ2FudmFzT2JqZWN0KGFyZ3MpO1xuXHRcdFx0XHRcdF9hZGRMYXllcihjYW52YXMsIHBhcmFtcywgYXJncywgc2VsZik7XG5cblx0XHRcdFx0XHRfc2V0R2xvYmFsUHJvcHMoY2FudmFzLCBjdHgsIHBhcmFtcyk7XG5cdFx0XHRcdFx0cGx1Z2luLmZuLmNhbGwoY2FudmFzLCBjdHgsIHBhcmFtcyk7XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICRjYW52YXNlcztcblx0XHR9O1xuXHRcdC8vIEFkZCBkcmF3aW5nIHR5cGUgdG8gZHJhd2luZyBtYXBcblx0XHRpZiAocGx1Z2luLnR5cGUpIHtcblx0XHRcdG1hcHMuZHJhd2luZ3NbcGx1Z2luLnR5cGVdID0gcGx1Z2luLm5hbWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAkLmZuW3BsdWdpbi5uYW1lXTtcbn07XG5cbi8qIExheWVyIEFQSSAqL1xuXG4vLyBSZXRyaWV2ZWQgdGhlIHN0b3JlZCBqQ2FudmFzIGRhdGEgZm9yIGEgY2FudmFzIGVsZW1lbnRcbmZ1bmN0aW9uIF9nZXRDYW52YXNEYXRhKGNhbnZhcykge1xuXHR2YXIgZGF0YUNhY2hlID0gY2FjaGVzLmRhdGFDYWNoZSwgZGF0YTtcblx0aWYgKGRhdGFDYWNoZS5fY2FudmFzID09PSBjYW52YXMgJiYgZGF0YUNhY2hlLl9kYXRhKSB7XG5cblx0XHQvLyBSZXRyaWV2ZSBjYW52YXMgZGF0YSBmcm9tIGNhY2hlIGlmIHBvc3NpYmxlXG5cdFx0ZGF0YSA9IGRhdGFDYWNoZS5fZGF0YTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gUmV0cmlldmUgY2FudmFzIGRhdGEgZnJvbSBqUXVlcnkncyBpbnRlcm5hbCBkYXRhIHN0b3JhZ2Vcblx0XHRkYXRhID0gJC5kYXRhKGNhbnZhcywgJ2pDYW52YXMnKTtcblx0XHRpZiAoIWRhdGEpIHtcblxuXHRcdFx0Ly8gQ3JlYXRlIGNhbnZhcyBkYXRhIG9iamVjdCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0XG5cdFx0XHRkYXRhID0ge1xuXHRcdFx0XHQvLyBUaGUgYXNzb2NpYXRlZCBjYW52YXMgZWxlbWVudFxuXHRcdFx0XHRjYW52YXM6IGNhbnZhcyxcblx0XHRcdFx0Ly8gTGF5ZXJzIGFycmF5XG5cdFx0XHRcdGxheWVyczogW10sXG5cdFx0XHRcdC8vIExheWVyIG1hcHNcblx0XHRcdFx0bGF5ZXI6IHtcblx0XHRcdFx0XHRuYW1lczoge30sXG5cdFx0XHRcdFx0Z3JvdXBzOiB7fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRldmVudEhvb2tzOiB7fSxcblx0XHRcdFx0Ly8gQWxsIGxheWVycyB0aGF0IGludGVyc2VjdCB3aXRoIHRoZSBldmVudCBjb29yZGluYXRlcyAocmVnYXJkbGVzcyBvZiB2aXNpYmlsaXR5KVxuXHRcdFx0XHRpbnRlcnNlY3Rpbmc6IFtdLFxuXHRcdFx0XHQvLyBUaGUgdG9wbW9zdCBsYXllciB3aG9zZSBhcmVhIGNvbnRhaW5zIHRoZSBldmVudCBjb29yZGluYXRlc1xuXHRcdFx0XHRsYXN0SW50ZXJzZWN0ZWQ6IG51bGwsXG5cdFx0XHRcdGN1cnNvcjogJChjYW52YXMpLmNzcygnY3Vyc29yJyksXG5cdFx0XHRcdC8vIFByb3BlcnRpZXMgZm9yIHRoZSBjdXJyZW50IGRyYWcgZXZlbnRcblx0XHRcdFx0ZHJhZzoge1xuXHRcdFx0XHRcdGxheWVyOiBudWxsLFxuXHRcdFx0XHRcdGRyYWdnaW5nOiBmYWxzZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBEYXRhIGZvciB0aGUgY3VycmVudCBldmVudFxuXHRcdFx0XHRldmVudDoge1xuXHRcdFx0XHRcdHR5cGU6IG51bGwsXG5cdFx0XHRcdFx0eDogbnVsbCxcblx0XHRcdFx0XHR5OiBudWxsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIEV2ZW50cyB3aGljaCBhbHJlYWR5IGhhdmUgYmVlbiBib3VuZCB0byB0aGUgY2FudmFzXG5cdFx0XHRcdGV2ZW50czoge30sXG5cdFx0XHRcdC8vIFRoZSBjYW52YXMncyBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIHN0YXRlXG5cdFx0XHRcdHRyYW5zZm9ybXM6IF9jbG9uZVRyYW5zZm9ybXMoYmFzZVRyYW5zZm9ybXMpLFxuXHRcdFx0XHRzYXZlZFRyYW5zZm9ybXM6IFtdLFxuXHRcdFx0XHQvLyBXaGV0aGVyIGEgbGF5ZXIgaXMgYmVpbmcgYW5pbWF0ZWQgb3Igbm90XG5cdFx0XHRcdGFuaW1hdGluZzogZmFsc2UsXG5cdFx0XHRcdC8vIFRoZSBsYXllciBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWRcblx0XHRcdFx0YW5pbWF0ZWQ6IG51bGwsXG5cdFx0XHRcdC8vIFRoZSBkZXZpY2UgcGl4ZWwgcmF0aW9cblx0XHRcdFx0cGl4ZWxSYXRpbzogMSxcblx0XHRcdFx0Ly8gV2hldGhlciBwaXhlbCByYXRpbyB0cmFuc2Zvcm1hdGlvbnMgaGF2ZSBiZWVuIGFwcGxpZWRcblx0XHRcdFx0c2NhbGVkOiBmYWxzZSxcblx0XHRcdFx0Ly8gV2hldGhlciB0aGUgY2FudmFzIHNob3VsZCBiZSByZWRyYXduIHdoZW4gYSBsYXllciBtb3VzZW1vdmVcblx0XHRcdFx0Ly8gZXZlbnQgdHJpZ2dlcnMgKGVpdGhlciBkaXJlY3RseSwgb3IgaW5kaXJlY3RseSB2aWEgZHJhZ2dpbmcpXG5cdFx0XHRcdHJlZHJhd09uTW91c2Vtb3ZlOiBmYWxzZVxuXHRcdFx0fTtcblx0XHRcdC8vIFVzZSBqUXVlcnkgdG8gc3RvcmUgY2FudmFzIGRhdGFcblx0XHRcdCQuZGF0YShjYW52YXMsICdqQ2FudmFzJywgZGF0YSk7XG5cblx0XHR9XG5cdFx0Ly8gQ2FjaGUgY2FudmFzIGRhdGEgZm9yIGZhc3RlciByZXRyaWV2YWxcblx0XHRkYXRhQ2FjaGUuX2NhbnZhcyA9IGNhbnZhcztcblx0XHRkYXRhQ2FjaGUuX2RhdGEgPSBkYXRhO1xuXG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbi8vIEluaXRpYWxpemUgYWxsIG9mIGEgbGF5ZXIncyBhc3NvY2lhdGVkIGpDYW52YXMgZXZlbnRzXG5mdW5jdGlvbiBfYWRkTGF5ZXJFdmVudHMoJGNhbnZhcywgZGF0YSwgbGF5ZXIpIHtcblx0dmFyIGV2ZW50TmFtZTtcblx0Ly8gRGV0ZXJtaW5lIHdoaWNoIGpDYW52YXMgZXZlbnRzIG5lZWQgdG8gYmUgYm91bmQgdG8gdGhpcyBsYXllclxuXHRmb3IgKGV2ZW50TmFtZSBpbiBqQ2FudmFzLmV2ZW50cykge1xuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoakNhbnZhcy5ldmVudHMsIGV2ZW50TmFtZSkpIHtcblx0XHRcdC8vIElmIGxheWVyIGhhcyBjYWxsYmFjayBmdW5jdGlvbiB0byBjb21wbGVtZW50IGl0XG5cdFx0XHRpZiAobGF5ZXJbZXZlbnROYW1lXSB8fCAobGF5ZXIuY3Vyc29ycyAmJiBsYXllci5jdXJzb3JzW2V2ZW50TmFtZV0pKSB7XG5cdFx0XHRcdC8vIEJpbmQgZXZlbnQgdG8gbGF5ZXJcblx0XHRcdFx0X2FkZEV4cGxpY2l0TGF5ZXJFdmVudCgkY2FudmFzLCBkYXRhLCBsYXllciwgZXZlbnROYW1lKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0aWYgKCFkYXRhLmV2ZW50cy5tb3VzZW91dCkge1xuXHRcdCRjYW52YXMuYmluZCgnbW91c2VvdXQuakNhbnZhcycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFJldHJpZXZlIHRoZSBsYXllciB3aG9zZSBkcmFnIGV2ZW50IHdhcyBjYW5jZWxlZFxuXHRcdFx0dmFyIGxheWVyID0gZGF0YS5kcmFnLmxheWVyLCBsO1xuXHRcdFx0Ly8gSWYgY3Vyc29yIG1vdXNlcyBvdXQgb2YgY2FudmFzIHdoaWxlIGRyYWdnaW5nXG5cdFx0XHRpZiAobGF5ZXIpIHtcblx0XHRcdFx0Ly8gQ2FuY2VsIGRyYWdcblx0XHRcdFx0ZGF0YS5kcmFnID0ge307XG5cdFx0XHRcdF90cmlnZ2VyTGF5ZXJFdmVudCgkY2FudmFzLCBkYXRhLCBsYXllciwgJ2RyYWdjYW5jZWwnKTtcblx0XHRcdH1cblx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgbGF5ZXJzXG5cdFx0XHRmb3IgKGwgPSAwOyBsIDwgZGF0YS5sYXllcnMubGVuZ3RoOyBsICs9IDEpIHtcblx0XHRcdFx0bGF5ZXIgPSBkYXRhLmxheWVyc1tsXTtcblx0XHRcdFx0Ly8gSWYgbGF5ZXIgdGhpbmtzIGl0J3Mgc3RpbGwgYmVpbmcgbW91c2VkIG92ZXJcblx0XHRcdFx0aWYgKGxheWVyLl9ob3ZlcmVkKSB7XG5cdFx0XHRcdFx0Ly8gVHJpZ2dlciBtb3VzZW91dCBvbiBsYXllclxuXHRcdFx0XHRcdCRjYW52YXMudHJpZ2dlckxheWVyRXZlbnQoZGF0YS5sYXllcnNbbF0sICdtb3VzZW91dCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBSZWRyYXcgbGF5ZXJzXG5cdFx0XHQkY2FudmFzLmRyYXdMYXllcnMoKTtcblx0XHR9KTtcblx0XHQvLyBJbmRpY2F0ZSB0aGF0IGFuIGV2ZW50IGhhbmRsZXIgaGFzIGJlZW4gYm91bmRcblx0XHRkYXRhLmV2ZW50cy5tb3VzZW91dCA9IHRydWU7XG5cdH1cbn1cblxuLy8gSW5pdGlhbGl6ZSB0aGUgZ2l2ZW4gZXZlbnQgb24gdGhlIGdpdmVuIGxheWVyXG5mdW5jdGlvbiBfYWRkTGF5ZXJFdmVudCgkY2FudmFzLCBkYXRhLCBsYXllciwgZXZlbnROYW1lKSB7XG5cdC8vIFVzZSB0b3VjaCBldmVudHMgaWYgYXBwcm9wcmlhdGVcblx0Ly8gZXZlbnROYW1lID0gX2dldE1vdXNlRXZlbnROYW1lKGV2ZW50TmFtZSk7XG5cdC8vIEJpbmQgZXZlbnQgdG8gbGF5ZXJcblx0akNhbnZhcy5ldmVudHNbZXZlbnROYW1lXSgkY2FudmFzLCBkYXRhKTtcblx0bGF5ZXIuX2V2ZW50ID0gdHJ1ZTtcbn1cblxuLy8gQWRkIGEgbGF5ZXIgZXZlbnQgdGhhdCB3YXMgZXhwbGljaXRseSBkZWNsYXJlZCBpbiB0aGUgbGF5ZXIncyBwYXJhbWV0ZXIgbWFwLFxuLy8gZXhjbHVkaW5nIGV2ZW50cyBhZGRlZCBpbXBsaWNpdGx5IChlLmcuIG1vdXNlbW92ZSBldmVudCByZXF1aXJlZCBieSBkcmFnZ2FibGVcbi8vIGxheWVycylcbmZ1bmN0aW9uIF9hZGRFeHBsaWNpdExheWVyRXZlbnQoJGNhbnZhcywgZGF0YSwgbGF5ZXIsIGV2ZW50TmFtZSkge1xuXHRfYWRkTGF5ZXJFdmVudCgkY2FudmFzLCBkYXRhLCBsYXllciwgZXZlbnROYW1lKTtcblx0aWYgKGV2ZW50TmFtZSA9PT0gJ21vdXNlb3ZlcicgfHwgZXZlbnROYW1lID09PSAnbW91c2VvdXQnIHx8IGV2ZW50TmFtZSA9PT0gJ21vdXNlbW92ZScpIHtcblx0XHRkYXRhLnJlZHJhd09uTW91c2Vtb3ZlID0gdHJ1ZTtcblx0fVxufVxuXG4vLyBFbmFibGUgZHJhZyBzdXBwb3J0IGZvciB0aGlzIGxheWVyXG5mdW5jdGlvbiBfZW5hYmxlRHJhZygkY2FudmFzLCBkYXRhLCBsYXllcikge1xuXHR2YXIgZHJhZ0hlbHBlckV2ZW50cywgZXZlbnROYW1lLCBpO1xuXHQvLyBPbmx5IG1ha2UgbGF5ZXIgZHJhZ2dhYmxlIGlmIG5lY2Vzc2FyeVxuXHRpZiAobGF5ZXIuZHJhZ2dhYmxlIHx8IGxheWVyLmN1cnNvcnMpIHtcblxuXHRcdC8vIE9yZ2FuaXplIGhlbHBlciBldmVudHMgd2hpY2ggZW5hYmxlIGRyYWcgc3VwcG9ydFxuXHRcdGRyYWdIZWxwZXJFdmVudHMgPSBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCddO1xuXG5cdFx0Ly8gQmluZCBlYWNoIGhlbHBlciBldmVudCB0byB0aGUgY2FudmFzXG5cdFx0Zm9yIChpID0gMDsgaSA8IGRyYWdIZWxwZXJFdmVudHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdC8vIFVzZSB0b3VjaCBldmVudHMgaWYgYXBwcm9wcmlhdGVcblx0XHRcdGV2ZW50TmFtZSA9IGRyYWdIZWxwZXJFdmVudHNbaV07XG5cdFx0XHQvLyBCaW5kIGV2ZW50XG5cdFx0XHRfYWRkTGF5ZXJFdmVudCgkY2FudmFzLCBkYXRhLCBsYXllciwgZXZlbnROYW1lKTtcblx0XHR9XG5cdFx0Ly8gSW5kaWNhdGUgdGhhdCB0aGlzIGxheWVyIGhhcyBldmVudHMgYm91bmQgdG8gaXRcblx0XHRsYXllci5fZXZlbnQgPSB0cnVlO1xuXG5cdH1cbn1cblxuLy8gVXBkYXRlIGEgbGF5ZXIgcHJvcGVydHkgbWFwIGlmIHByb3BlcnR5IGlzIGNoYW5nZWRcbmZ1bmN0aW9uIF91cGRhdGVMYXllck5hbWUoJGNhbnZhcywgZGF0YSwgbGF5ZXIsIHByb3BzKSB7XG5cdHZhciBuYW1lTWFwID0gZGF0YS5sYXllci5uYW1lcztcblxuXHQvLyBJZiBsYXllciBuYW1lIGlzIGJlaW5nIGFkZGVkLCBub3QgY2hhbmdlZFxuXHRpZiAoIXByb3BzKSB7XG5cblx0XHRwcm9wcyA9IGxheWVyO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBSZW1vdmUgb2xkIGxheWVyIG5hbWUgZW50cnkgYmVjYXVzZSBsYXllciBuYW1lIGhhcyBjaGFuZ2VkXG5cdFx0aWYgKHByb3BzLm5hbWUgIT09IHVuZGVmaW5lZCAmJiBpc1N0cmluZyhsYXllci5uYW1lKSAmJiBsYXllci5uYW1lICE9PSBwcm9wcy5uYW1lKSB7XG5cdFx0XHRkZWxldGUgbmFtZU1hcFtsYXllci5uYW1lXTtcblx0XHR9XG5cblx0fVxuXG5cdC8vIEFkZCBuZXcgZW50cnkgdG8gbGF5ZXIgbmFtZSBtYXAgd2l0aCBuZXcgbmFtZVxuXHRpZiAoaXNTdHJpbmcocHJvcHMubmFtZSkpIHtcblx0XHRuYW1lTWFwW3Byb3BzLm5hbWVdID0gbGF5ZXI7XG5cdH1cbn1cblxuLy8gQ3JlYXRlIG9yIHVwZGF0ZSB0aGUgZGF0YSBtYXAgZm9yIHRoZSBnaXZlbiBsYXllciBhbmQgZ3JvdXAgdHlwZVxuZnVuY3Rpb24gX3VwZGF0ZUxheWVyR3JvdXBzKCRjYW52YXMsIGRhdGEsIGxheWVyLCBwcm9wcykge1xuXHR2YXIgZ3JvdXBNYXAgPSBkYXRhLmxheWVyLmdyb3Vwcyxcblx0XHRncm91cCwgZ3JvdXBOYW1lLCBnLFxuXHRcdGluZGV4LCBsO1xuXG5cdC8vIElmIGdyb3VwIG5hbWUgaXMgbm90IGNoYW5naW5nXG5cdGlmICghcHJvcHMpIHtcblxuXHRcdHByb3BzID0gbGF5ZXI7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFJlbW92ZSBsYXllciBmcm9tIGFsbCBvZiBpdHMgYXNzb2NpYXRlZCBncm91cHNcblx0XHRpZiAocHJvcHMuZ3JvdXBzICE9PSB1bmRlZmluZWQgJiYgbGF5ZXIuZ3JvdXBzICE9PSBudWxsKSB7XG5cdFx0XHRmb3IgKGcgPSAwOyBnIDwgbGF5ZXIuZ3JvdXBzLmxlbmd0aDsgZyArPSAxKSB7XG5cdFx0XHRcdGdyb3VwTmFtZSA9IGxheWVyLmdyb3Vwc1tnXTtcblx0XHRcdFx0Z3JvdXAgPSBncm91cE1hcFtncm91cE5hbWVdO1xuXHRcdFx0XHRpZiAoZ3JvdXApIHtcblx0XHRcdFx0XHQvLyBSZW1vdmUgbGF5ZXIgZnJvbSBpdHMgb2xkIGxheWVyIGdyb3VwIGVudHJ5XG5cdFx0XHRcdFx0Zm9yIChsID0gMDsgbCA8IGdyb3VwLmxlbmd0aDsgbCArPSAxKSB7XG5cdFx0XHRcdFx0XHRpZiAoZ3JvdXBbbF0gPT09IGxheWVyKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxheWVyJ3MgaW5pdGlhbCBpbmRleFxuXHRcdFx0XHRcdFx0XHRpbmRleCA9IGw7XG5cdFx0XHRcdFx0XHRcdC8vIFJlbW92ZSBsYXllciBvbmNlIGZvdW5kXG5cdFx0XHRcdFx0XHRcdGdyb3VwLnNwbGljZShsLCAxKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFJlbW92ZSBsYXllciBncm91cCBlbnRyeSBpZiBncm91cCBpcyBlbXB0eVxuXHRcdFx0XHRcdGlmIChncm91cC5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdGRlbGV0ZSBncm91cE1hcFtncm91cE5hbWVdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblx0Ly8gQWRkIGxheWVyIHRvIG5ldyBncm91cCBpZiBhIG5ldyBncm91cCBuYW1lIGlzIGdpdmVuXG5cdGlmIChwcm9wcy5ncm91cHMgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5ncm91cHMgIT09IG51bGwpIHtcblxuXHRcdGZvciAoZyA9IDA7IGcgPCBwcm9wcy5ncm91cHMubGVuZ3RoOyBnICs9IDEpIHtcblxuXHRcdFx0Z3JvdXBOYW1lID0gcHJvcHMuZ3JvdXBzW2ddO1xuXG5cdFx0XHRncm91cCA9IGdyb3VwTWFwW2dyb3VwTmFtZV07XG5cdFx0XHRpZiAoIWdyb3VwKSB7XG5cdFx0XHRcdC8vIENyZWF0ZSBuZXcgZ3JvdXAgZW50cnkgaWYgaXQgZG9lc24ndCBleGlzdFxuXHRcdFx0XHRncm91cCA9IGdyb3VwTWFwW2dyb3VwTmFtZV0gPSBbXTtcblx0XHRcdFx0Z3JvdXAubmFtZSA9IGdyb3VwTmFtZTtcblx0XHRcdH1cblx0XHRcdGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIEFkZCBsYXllciB0byBlbmQgb2YgZ3JvdXAgdW5sZXNzIG90aGVyd2lzZSBzdGF0ZWRcblx0XHRcdFx0aW5kZXggPSBncm91cC5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHQvLyBBZGQgbGF5ZXIgdG8gaXRzIG5ldyBsYXllciBncm91cFxuXHRcdFx0Z3JvdXAuc3BsaWNlKGluZGV4LCAwLCBsYXllcik7XG5cblx0XHR9XG5cblx0fVxufVxuXG4vLyBHZXQgZXZlbnQgaG9va3Mgb2JqZWN0IGZvciB0aGUgZmlyc3Qgc2VsZWN0ZWQgY2FudmFzXG4kLmZuLmdldEV2ZW50SG9va3MgPSBmdW5jdGlvbiBnZXRFdmVudEhvb2tzKCkge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgY2FudmFzLCBkYXRhLFxuXHRcdGV2ZW50SG9va3MgPSB7fTtcblxuXHRpZiAoJGNhbnZhc2VzLmxlbmd0aCAhPT0gMCkge1xuXHRcdGNhbnZhcyA9ICRjYW52YXNlc1swXTtcblx0XHRkYXRhID0gX2dldENhbnZhc0RhdGEoY2FudmFzKTtcblx0XHRldmVudEhvb2tzID0gZGF0YS5ldmVudEhvb2tzO1xuXHR9XG5cdHJldHVybiBldmVudEhvb2tzO1xufTtcblxuLy8gU2V0IGV2ZW50IGhvb2tzIGZvciB0aGUgc2VsZWN0ZWQgY2FudmFzZXNcbiQuZm4uc2V0RXZlbnRIb29rcyA9IGZ1bmN0aW9uIHNldEV2ZW50SG9va3MoZXZlbnRIb29rcykge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgZSxcblx0XHRkYXRhO1xuXHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0ZGF0YSA9IF9nZXRDYW52YXNEYXRhKCRjYW52YXNlc1tlXSk7XG5cdFx0ZXh0ZW5kT2JqZWN0KGRhdGEuZXZlbnRIb29rcywgZXZlbnRIb29rcyk7XG5cdH1cblx0cmV0dXJuICRjYW52YXNlcztcbn07XG5cbi8vIEdldCBqQ2FudmFzIGxheWVycyBhcnJheVxuJC5mbi5nZXRMYXllcnMgPSBmdW5jdGlvbiBnZXRMYXllcnMoY2FsbGJhY2spIHtcblx0dmFyICRjYW52YXNlcyA9IHRoaXMsIGNhbnZhcywgZGF0YSxcblx0XHRsYXllcnMsIGxheWVyLCBsLFxuXHRcdG1hdGNoaW5nID0gW107XG5cblx0aWYgKCRjYW52YXNlcy5sZW5ndGggIT09IDApIHtcblxuXHRcdGNhbnZhcyA9ICRjYW52YXNlc1swXTtcblx0XHRkYXRhID0gX2dldENhbnZhc0RhdGEoY2FudmFzKTtcblx0XHQvLyBSZXRyaWV2ZSBsYXllcnMgYXJyYXkgZm9yIHRoaXMgY2FudmFzXG5cdFx0bGF5ZXJzID0gZGF0YS5sYXllcnM7XG5cblx0XHQvLyBJZiBhIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGdpdmVuXG5cdFx0aWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG5cblx0XHRcdC8vIEZpbHRlciB0aGUgbGF5ZXJzIGFycmF5IHVzaW5nIHRoZSBjYWxsYmFja1xuXHRcdFx0Zm9yIChsID0gMDsgbCA8IGxheWVycy5sZW5ndGg7IGwgKz0gMSkge1xuXHRcdFx0XHRsYXllciA9IGxheWVyc1tsXTtcblx0XHRcdFx0aWYgKGNhbGxiYWNrLmNhbGwoY2FudmFzLCBsYXllcikpIHtcblx0XHRcdFx0XHQvLyBBZGQgbGF5ZXIgdG8gYXJyYXkgb2YgbWF0Y2hpbmcgbGF5ZXJzIGlmIHRlc3QgcGFzc2VzXG5cdFx0XHRcdFx0bWF0Y2hpbmcucHVzaChsYXllcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBPdGhlcndpc2UsIGdldCBhbGwgbGF5ZXJzXG5cblx0XHRcdG1hdGNoaW5nID0gbGF5ZXJzO1xuXG5cdFx0fVxuXG5cdH1cblx0cmV0dXJuIG1hdGNoaW5nO1xufTtcblxuLy8gR2V0IGEgc2luZ2xlIGpDYW52YXMgbGF5ZXIgb2JqZWN0XG4kLmZuLmdldExheWVyID0gZnVuY3Rpb24gZ2V0TGF5ZXIobGF5ZXJJZCkge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgY2FudmFzLFxuXHRcdGRhdGEsIGxheWVycywgbGF5ZXIsIGwsXG5cdFx0aWRUeXBlO1xuXG5cdGlmICgkY2FudmFzZXMubGVuZ3RoICE9PSAwKSB7XG5cblx0XHRjYW52YXMgPSAkY2FudmFzZXNbMF07XG5cdFx0ZGF0YSA9IF9nZXRDYW52YXNEYXRhKGNhbnZhcyk7XG5cdFx0bGF5ZXJzID0gZGF0YS5sYXllcnM7XG5cdFx0aWRUeXBlID0gdHlwZU9mKGxheWVySWQpO1xuXG5cdFx0aWYgKGxheWVySWQgJiYgbGF5ZXJJZC5sYXllcikge1xuXG5cdFx0XHQvLyBSZXR1cm4gdGhlIGFjdHVhbCBsYXllciBvYmplY3QgaWYgZ2l2ZW5cblx0XHRcdGxheWVyID0gbGF5ZXJJZDtcblxuXHRcdH0gZWxzZSBpZiAoaWRUeXBlID09PSAnbnVtYmVyJykge1xuXG5cdFx0XHQvLyBSZXRyaWV2ZSB0aGUgbGF5ZXIgdXNpbmcgdGhlIGdpdmVuIGluZGV4XG5cblx0XHRcdC8vIEFsbG93IGZvciBuZWdhdGl2ZSBpbmRpY2VzXG5cdFx0XHRpZiAobGF5ZXJJZCA8IDApIHtcblx0XHRcdFx0bGF5ZXJJZCA9IGxheWVycy5sZW5ndGggKyBsYXllcklkO1xuXHRcdFx0fVxuXHRcdFx0Ly8gR2V0IGxheWVyIHdpdGggdGhlIGdpdmVuIGluZGV4XG5cdFx0XHRsYXllciA9IGxheWVyc1tsYXllcklkXTtcblxuXHRcdH0gZWxzZSBpZiAoaWRUeXBlID09PSAncmVnZXhwJykge1xuXG5cdFx0XHQvLyBHZXQgbGF5ZXIgd2l0aCB0aGUgbmFtZSB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIHJlZ2V4XG5cdFx0XHRmb3IgKGwgPSAwOyBsIDwgbGF5ZXJzLmxlbmd0aDsgbCArPSAxKSB7XG5cdFx0XHRcdC8vIENoZWNrIGlmIGxheWVyIG1hdGNoZXMgbmFtZVxuXHRcdFx0XHRpZiAoaXNTdHJpbmcobGF5ZXJzW2xdLm5hbWUpICYmIGxheWVyc1tsXS5uYW1lLm1hdGNoKGxheWVySWQpKSB7XG5cdFx0XHRcdFx0bGF5ZXIgPSBsYXllcnNbbF07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEdldCBsYXllciB3aXRoIHRoZSBnaXZlbiBuYW1lXG5cdFx0XHRsYXllciA9IGRhdGEubGF5ZXIubmFtZXNbbGF5ZXJJZF07XG5cblx0XHR9XG5cblx0fVxuXHRyZXR1cm4gbGF5ZXI7XG59O1xuXG4vLyBHZXQgYWxsIGxheWVycyBpbiB0aGUgZ2l2ZW4gZ3JvdXBcbiQuZm4uZ2V0TGF5ZXJHcm91cCA9IGZ1bmN0aW9uIGdldExheWVyR3JvdXAoZ3JvdXBJZCkge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgY2FudmFzLCBkYXRhLFxuXHRcdGdyb3VwcywgZ3JvdXBOYW1lLCBncm91cCxcblx0XHRpZFR5cGUgPSB0eXBlT2YoZ3JvdXBJZCk7XG5cblx0aWYgKCRjYW52YXNlcy5sZW5ndGggIT09IDApIHtcblxuXHRcdGNhbnZhcyA9ICRjYW52YXNlc1swXTtcblxuXHRcdGlmIChpZFR5cGUgPT09ICdhcnJheScpIHtcblxuXHRcdFx0Ly8gUmV0dXJuIGxheWVyIGdyb3VwIGlmIGdpdmVuXG5cdFx0XHRncm91cCA9IGdyb3VwSWQ7XG5cblx0XHR9IGVsc2UgaWYgKGlkVHlwZSA9PT0gJ3JlZ2V4cCcpIHtcblxuXHRcdFx0Ly8gR2V0IGNhbnZhcyBkYXRhXG5cdFx0XHRkYXRhID0gX2dldENhbnZhc0RhdGEoY2FudmFzKTtcblx0XHRcdGdyb3VwcyA9IGRhdGEubGF5ZXIuZ3JvdXBzO1xuXHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCBsYXllcnMgZ3JvdXBzIGZvciB0aGlzIGNhbnZhc1xuXHRcdFx0Zm9yIChncm91cE5hbWUgaW4gZ3JvdXBzKSB7XG5cdFx0XHRcdC8vIEZpbmQgYSBncm91cCB3aG9zZSBuYW1lIG1hdGNoZXMgdGhlIGdpdmVuIHJlZ2V4XG5cdFx0XHRcdGlmIChncm91cE5hbWUubWF0Y2goZ3JvdXBJZCkpIHtcblx0XHRcdFx0XHRncm91cCA9IGdyb3Vwc1tncm91cE5hbWVdO1xuXHRcdFx0XHRcdC8vIFN0b3AgYWZ0ZXIgZmluZGluZyB0aGUgZmlyc3QgbWF0Y2hpbmcgZ3JvdXBcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRmluZCBsYXllciBncm91cCB3aXRoIHRoZSBnaXZlbiBncm91cCBuYW1lXG5cdFx0XHRkYXRhID0gX2dldENhbnZhc0RhdGEoY2FudmFzKTtcblx0XHRcdGdyb3VwID0gZGF0YS5sYXllci5ncm91cHNbZ3JvdXBJZF07XG5cdFx0fVxuXG5cdH1cblx0cmV0dXJuIGdyb3VwO1xufTtcblxuLy8gR2V0IGluZGV4IG9mIGxheWVyIGluIGxheWVycyBhcnJheVxuJC5mbi5nZXRMYXllckluZGV4ID0gZnVuY3Rpb24gZ2V0TGF5ZXJJbmRleChsYXllcklkKSB7XG5cdHZhciAkY2FudmFzZXMgPSB0aGlzLFxuXHRcdGxheWVycyA9ICRjYW52YXNlcy5nZXRMYXllcnMoKSxcblx0XHRsYXllciA9ICRjYW52YXNlcy5nZXRMYXllcihsYXllcklkKTtcblxuXHRyZXR1cm4gaW5BcnJheShsYXllciwgbGF5ZXJzKTtcbn07XG5cbi8vIFNldCBwcm9wZXJ0aWVzIG9mIGEgbGF5ZXJcbiQuZm4uc2V0TGF5ZXIgPSBmdW5jdGlvbiBzZXRMYXllcihsYXllcklkLCBwcm9wcykge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgJGNhbnZhcywgZSxcblx0XHRkYXRhLCBsYXllcixcblx0XHRwcm9wTmFtZSwgcHJvcFZhbHVlLCBwcm9wVHlwZTtcblxuXHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0JGNhbnZhcyA9ICQoJGNhbnZhc2VzW2VdKTtcblx0XHRkYXRhID0gX2dldENhbnZhc0RhdGEoJGNhbnZhc2VzW2VdKTtcblxuXHRcdGxheWVyID0gJCgkY2FudmFzZXNbZV0pLmdldExheWVyKGxheWVySWQpO1xuXHRcdGlmIChsYXllcikge1xuXG5cdFx0XHQvLyBVcGRhdGUgbGF5ZXIgcHJvcGVydHkgbWFwc1xuXHRcdFx0X3VwZGF0ZUxheWVyTmFtZSgkY2FudmFzLCBkYXRhLCBsYXllciwgcHJvcHMpO1xuXHRcdFx0X3VwZGF0ZUxheWVyR3JvdXBzKCRjYW52YXMsIGRhdGEsIGxheWVyLCBwcm9wcyk7XG5cblx0XHRcdF9jb2VyY2VOdW1lcmljUHJvcHMocHJvcHMpO1xuXG5cdFx0XHQvLyBNZXJnZSBwcm9wZXJ0aWVzIHdpdGggbGF5ZXJcblx0XHRcdGZvciAocHJvcE5hbWUgaW4gcHJvcHMpIHtcblx0XHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcE5hbWUpKSB7XG5cdFx0XHRcdFx0cHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuXHRcdFx0XHRcdHByb3BUeXBlID0gdHlwZU9mKHByb3BWYWx1ZSk7XG5cdFx0XHRcdFx0aWYgKHByb3BUeXBlID09PSAnb2JqZWN0JyAmJiBpc1BsYWluT2JqZWN0KHByb3BWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdC8vIENsb25lIG9iamVjdHNcblx0XHRcdFx0XHRcdGxheWVyW3Byb3BOYW1lXSA9IGV4dGVuZE9iamVjdCh7fSwgcHJvcFZhbHVlKTtcblx0XHRcdFx0XHRcdF9jb2VyY2VOdW1lcmljUHJvcHMobGF5ZXJbcHJvcE5hbWVdKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHByb3BUeXBlID09PSAnYXJyYXknKSB7XG5cdFx0XHRcdFx0XHQvLyBDbG9uZSBhcnJheXNcblx0XHRcdFx0XHRcdGxheWVyW3Byb3BOYW1lXSA9IHByb3BWYWx1ZS5zbGljZSgwKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHByb3BUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0aWYgKHByb3BWYWx1ZS5pbmRleE9mKCcrPScpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEluY3JlbWVudCBudW1iZXJzIHByZWZpeGVkIHdpdGggKz1cblx0XHRcdFx0XHRcdFx0bGF5ZXJbcHJvcE5hbWVdICs9IHBhcnNlRmxvYXQocHJvcFZhbHVlLnN1YnN0cigyKSk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHByb3BWYWx1ZS5pbmRleE9mKCctPScpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdC8vIERlY3JlbWVudCBudW1iZXJzIHByZWZpeGVkIHdpdGggLT1cblx0XHRcdFx0XHRcdFx0bGF5ZXJbcHJvcE5hbWVdIC09IHBhcnNlRmxvYXQocHJvcFZhbHVlLnN1YnN0cigyKSk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCFpc05hTihwcm9wVmFsdWUpICYmIGlzTnVtZXJpYyhwcm9wVmFsdWUpICYmIHByb3BOYW1lICE9PSAndGV4dCcpIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ29udmVydCBudW1lcmljIHZhbHVlcyBhcyBzdHJpbmdzIHRvIG51bWJlcnNcblx0XHRcdFx0XHRcdFx0bGF5ZXJbcHJvcE5hbWVdID0gcGFyc2VGbG9hdChwcm9wVmFsdWUpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBzZXQgZ2l2ZW4gc3RyaW5nIHZhbHVlXG5cdFx0XHRcdFx0XHRcdGxheWVyW3Byb3BOYW1lXSA9IHByb3BWYWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBzZXQgZ2l2ZW4gdmFsdWVcblx0XHRcdFx0XHRcdGxheWVyW3Byb3BOYW1lXSA9IHByb3BWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIGxheWVyIGV2ZW50c1xuXHRcdFx0X2FkZExheWVyRXZlbnRzKCRjYW52YXMsIGRhdGEsIGxheWVyKTtcblx0XHRcdF9lbmFibGVEcmFnKCRjYW52YXMsIGRhdGEsIGxheWVyKTtcblxuXHRcdFx0Ly8gSWYgbGF5ZXIncyBwcm9wZXJ0aWVzIHdlcmUgY2hhbmdlZFxuXHRcdFx0aWYgKCQuaXNFbXB0eU9iamVjdChwcm9wcykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdF90cmlnZ2VyTGF5ZXJFdmVudCgkY2FudmFzLCBkYXRhLCBsYXllciwgJ2NoYW5nZScsIHByb3BzKTtcblx0XHRcdH1cblxuXHRcdH1cblx0fVxuXHRyZXR1cm4gJGNhbnZhc2VzO1xufTtcblxuLy8gU2V0IHByb3BlcnRpZXMgb2YgYWxsIGxheWVycyAob3B0aW9uYWxseSBmaWx0ZXJlZCBieSBhIGNhbGxiYWNrKVxuJC5mbi5zZXRMYXllcnMgPSBmdW5jdGlvbiBzZXRMYXllcnMocHJvcHMsIGNhbGxiYWNrKSB7XG5cdHZhciAkY2FudmFzZXMgPSB0aGlzLCAkY2FudmFzLCBlLFxuXHRcdGxheWVycywgbDtcblx0Zm9yIChlID0gMDsgZSA8ICRjYW52YXNlcy5sZW5ndGg7IGUgKz0gMSkge1xuXHRcdCRjYW52YXMgPSAkKCRjYW52YXNlc1tlXSk7XG5cblx0XHRsYXllcnMgPSAkY2FudmFzLmdldExheWVycyhjYWxsYmFjayk7XG5cdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCBsYXllcnNcblx0XHRmb3IgKGwgPSAwOyBsIDwgbGF5ZXJzLmxlbmd0aDsgbCArPSAxKSB7XG5cdFx0XHQvLyBTZXQgcHJvcGVydGllcyBvZiBlYWNoIGxheWVyXG5cdFx0XHQkY2FudmFzLnNldExheWVyKGxheWVyc1tsXSwgcHJvcHMpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gJGNhbnZhc2VzO1xufTtcblxuLy8gU2V0IHByb3BlcnRpZXMgb2YgYWxsIGxheWVycyBpbiB0aGUgZ2l2ZW4gZ3JvdXBcbiQuZm4uc2V0TGF5ZXJHcm91cCA9IGZ1bmN0aW9uIHNldExheWVyR3JvdXAoZ3JvdXBJZCwgcHJvcHMpIHtcblx0dmFyICRjYW52YXNlcyA9IHRoaXMsICRjYW52YXMsIGUsXG5cdFx0Z3JvdXAsIGw7XG5cblx0Zm9yIChlID0gMDsgZSA8ICRjYW52YXNlcy5sZW5ndGg7IGUgKz0gMSkge1xuXHRcdC8vIEdldCBsYXllciBncm91cFxuXHRcdCRjYW52YXMgPSAkKCRjYW52YXNlc1tlXSk7XG5cblx0XHRncm91cCA9ICRjYW52YXMuZ2V0TGF5ZXJHcm91cChncm91cElkKTtcblx0XHQvLyBJZiBncm91cCBleGlzdHNcblx0XHRpZiAoZ3JvdXApIHtcblxuXHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGxheWVycyBpbiBncm91cFxuXHRcdFx0Zm9yIChsID0gMDsgbCA8IGdyb3VwLmxlbmd0aDsgbCArPSAxKSB7XG5cdFx0XHRcdC8vIE1lcmdlIGdpdmVuIHByb3BlcnRpZXMgd2l0aCBsYXllclxuXHRcdFx0XHQkY2FudmFzLnNldExheWVyKGdyb3VwW2xdLCBwcm9wcyk7XG5cdFx0XHR9XG5cblx0XHR9XG5cdH1cblx0cmV0dXJuICRjYW52YXNlcztcbn07XG5cbi8vIE1vdmUgYSBsYXllciB0byB0aGUgZ2l2ZW4gaW5kZXggaW4gdGhlIGxheWVycyBhcnJheVxuJC5mbi5tb3ZlTGF5ZXIgPSBmdW5jdGlvbiBtb3ZlTGF5ZXIobGF5ZXJJZCwgaW5kZXgpIHtcblx0dmFyICRjYW52YXNlcyA9IHRoaXMsICRjYW52YXMsIGUsXG5cdFx0ZGF0YSwgbGF5ZXJzLCBsYXllcjtcblxuXHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0JGNhbnZhcyA9ICQoJGNhbnZhc2VzW2VdKTtcblx0XHRkYXRhID0gX2dldENhbnZhc0RhdGEoJGNhbnZhc2VzW2VdKTtcblxuXHRcdC8vIFJldHJpZXZlIGxheWVycyBhcnJheSBhbmQgZGVzaXJlZCBsYXllclxuXHRcdGxheWVycyA9IGRhdGEubGF5ZXJzO1xuXHRcdGxheWVyID0gJGNhbnZhcy5nZXRMYXllcihsYXllcklkKTtcblx0XHRpZiAobGF5ZXIpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIGxheWVyIGluZGV4IGlzIGFjY3VyYXRlXG5cdFx0XHRsYXllci5pbmRleCA9IGluQXJyYXkobGF5ZXIsIGxheWVycyk7XG5cblx0XHRcdC8vIFJlbW92ZSBsYXllciBmcm9tIGl0cyBjdXJyZW50IHBsYWNlbWVudFxuXHRcdFx0bGF5ZXJzLnNwbGljZShsYXllci5pbmRleCwgMSk7XG5cdFx0XHQvLyBBZGQgbGF5ZXIgaW4gaXRzIG5ldyBwbGFjZW1lbnRcblx0XHRcdGxheWVycy5zcGxpY2UoaW5kZXgsIDAsIGxheWVyKTtcblxuXHRcdFx0Ly8gSGFuZGxlIG5lZ2F0aXZlIGluZGljZXNcblx0XHRcdGlmIChpbmRleCA8IDApIHtcblx0XHRcdFx0aW5kZXggPSBsYXllcnMubGVuZ3RoICsgaW5kZXg7XG5cdFx0XHR9XG5cdFx0XHQvLyBVcGRhdGUgbGF5ZXIncyBzdG9yZWQgaW5kZXhcblx0XHRcdGxheWVyLmluZGV4ID0gaW5kZXg7XG5cblx0XHRcdF90cmlnZ2VyTGF5ZXJFdmVudCgkY2FudmFzLCBkYXRhLCBsYXllciwgJ21vdmUnKTtcblxuXHRcdH1cblx0fVxuXHRyZXR1cm4gJGNhbnZhc2VzO1xufTtcblxuLy8gUmVtb3ZlIGEgakNhbnZhcyBsYXllclxuJC5mbi5yZW1vdmVMYXllciA9IGZ1bmN0aW9uIHJlbW92ZUxheWVyKGxheWVySWQpIHtcblx0dmFyICRjYW52YXNlcyA9IHRoaXMsICRjYW52YXMsIGUsIGRhdGEsXG5cdFx0bGF5ZXJzLCBsYXllcjtcblxuXHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0JGNhbnZhcyA9ICQoJGNhbnZhc2VzW2VdKTtcblx0XHRkYXRhID0gX2dldENhbnZhc0RhdGEoJGNhbnZhc2VzW2VdKTtcblxuXHRcdC8vIFJldHJpZXZlIGxheWVycyBhcnJheSBhbmQgZGVzaXJlZCBsYXllclxuXHRcdGxheWVycyA9ICRjYW52YXMuZ2V0TGF5ZXJzKCk7XG5cdFx0bGF5ZXIgPSAkY2FudmFzLmdldExheWVyKGxheWVySWQpO1xuXHRcdC8vIFJlbW92ZSBsYXllciBpZiBmb3VuZFxuXHRcdGlmIChsYXllcikge1xuXG5cdFx0XHQvLyBFbnN1cmUgbGF5ZXIgaW5kZXggaXMgYWNjdXJhdGVcblx0XHRcdGxheWVyLmluZGV4ID0gaW5BcnJheShsYXllciwgbGF5ZXJzKTtcblx0XHRcdC8vIFJlbW92ZSBsYXllciBhbmQgYWxsb3cgaXQgdG8gYmUgcmUtYWRkZWQgbGF0ZXJcblx0XHRcdGxheWVycy5zcGxpY2UobGF5ZXIuaW5kZXgsIDEpO1xuXHRcdFx0ZGVsZXRlIGxheWVyLl9sYXllcjtcblxuXHRcdFx0Ly8gVXBkYXRlIGxheWVyIG5hbWUgbWFwXG5cdFx0XHRfdXBkYXRlTGF5ZXJOYW1lKCRjYW52YXMsIGRhdGEsIGxheWVyLCB7XG5cdFx0XHRcdG5hbWU6IG51bGxcblx0XHRcdH0pO1xuXHRcdFx0Ly8gVXBkYXRlIGxheWVyIGdyb3VwIG1hcFxuXHRcdFx0X3VwZGF0ZUxheWVyR3JvdXBzKCRjYW52YXMsIGRhdGEsIGxheWVyLCB7XG5cdFx0XHRcdGdyb3VwczogbnVsbFxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIFRyaWdnZXIgJ3JlbW92ZScgZXZlbnRcblx0XHRcdF90cmlnZ2VyTGF5ZXJFdmVudCgkY2FudmFzLCBkYXRhLCBsYXllciwgJ3JlbW92ZScpO1xuXG5cdFx0fVxuXHR9XG5cdHJldHVybiAkY2FudmFzZXM7XG59O1xuXG4vLyBSZW1vdmUgYWxsIGxheWVyc1xuJC5mbi5yZW1vdmVMYXllcnMgPSBmdW5jdGlvbiByZW1vdmVMYXllcnMoY2FsbGJhY2spIHtcblx0dmFyICRjYW52YXNlcyA9IHRoaXMsICRjYW52YXMsIGUsXG5cdFx0ZGF0YSwgbGF5ZXJzLCBsYXllciwgbDtcblxuXHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0JGNhbnZhcyA9ICQoJGNhbnZhc2VzW2VdKTtcblx0XHRkYXRhID0gX2dldENhbnZhc0RhdGEoJGNhbnZhc2VzW2VdKTtcblx0XHRsYXllcnMgPSAkY2FudmFzLmdldExheWVycyhjYWxsYmFjaykuc2xpY2UoMCk7XG5cdFx0Ly8gUmVtb3ZlIGFsbCBsYXllcnMgaW5kaXZpZHVhbGx5XG5cdFx0Zm9yIChsID0gMDsgbCA8IGxheWVycy5sZW5ndGg7IGwgKz0gMSkge1xuXHRcdFx0bGF5ZXIgPSBsYXllcnNbbF07XG5cdFx0XHQkY2FudmFzLnJlbW92ZUxheWVyKGxheWVyKTtcblx0XHR9XG5cdFx0Ly8gVXBkYXRlIGxheWVyIG1hcHNcblx0XHRkYXRhLmxheWVyLm5hbWVzID0ge307XG5cdFx0ZGF0YS5sYXllci5ncm91cHMgPSB7fTtcblx0fVxuXHRyZXR1cm4gJGNhbnZhc2VzO1xufTtcblxuLy8gUmVtb3ZlIGFsbCBsYXllcnMgaW4gdGhlIGdyb3VwIHdpdGggdGhlIGdpdmVuIElEXG4kLmZuLnJlbW92ZUxheWVyR3JvdXAgPSBmdW5jdGlvbiByZW1vdmVMYXllckdyb3VwKGdyb3VwSWQpIHtcblx0dmFyICRjYW52YXNlcyA9IHRoaXMsICRjYW52YXMsIGUsIGdyb3VwLCBsO1xuXG5cdGlmIChncm91cElkICE9PSB1bmRlZmluZWQpIHtcblx0XHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0XHQkY2FudmFzID0gJCgkY2FudmFzZXNbZV0pO1xuXG5cdFx0XHRncm91cCA9ICRjYW52YXMuZ2V0TGF5ZXJHcm91cChncm91cElkKTtcblx0XHRcdC8vIFJlbW92ZSBsYXllciBncm91cCB1c2luZyBnaXZlbiBncm91cCBuYW1lXG5cdFx0XHRpZiAoZ3JvdXApIHtcblxuXHRcdFx0XHQvLyBDbG9uZSBncm91cHMgYXJyYXlcblx0XHRcdFx0Z3JvdXAgPSBncm91cC5zbGljZSgwKTtcblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggbGF5ZXJzIGluIGdyb3VwXG5cdFx0XHRcdGZvciAobCA9IDA7IGwgPCBncm91cC5sZW5ndGg7IGwgKz0gMSkge1xuXHRcdFx0XHRcdCRjYW52YXMucmVtb3ZlTGF5ZXIoZ3JvdXBbbF0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuICRjYW52YXNlcztcbn07XG5cbi8vIEFkZCBhbiBleGlzdGluZyBsYXllciB0byBhIGxheWVyIGdyb3VwXG4kLmZuLmFkZExheWVyVG9Hcm91cCA9IGZ1bmN0aW9uIGFkZExheWVyVG9Hcm91cChsYXllcklkLCBncm91cE5hbWUpIHtcblx0dmFyICRjYW52YXNlcyA9IHRoaXMsICRjYW52YXMsIGUsXG5cdFx0bGF5ZXIsIGdyb3VwcyA9IFtncm91cE5hbWVdO1xuXG5cdGZvciAoZSA9IDA7IGUgPCAkY2FudmFzZXMubGVuZ3RoOyBlICs9IDEpIHtcblx0XHQkY2FudmFzID0gJCgkY2FudmFzZXNbZV0pO1xuXHRcdGxheWVyID0gJGNhbnZhcy5nZXRMYXllcihsYXllcklkKTtcblxuXHRcdC8vIElmIGxheWVyIGlzIG5vdCBhbHJlYWR5IGluIGdyb3VwXG5cdFx0aWYgKGxheWVyLmdyb3Vwcykge1xuXHRcdFx0Ly8gQ2xvbmUgZ3JvdXBzIGxpc3Rcblx0XHRcdGdyb3VwcyA9IGxheWVyLmdyb3Vwcy5zbGljZSgwKTtcblx0XHRcdC8vIElmIGxheWVyIGlzIG5vdCBhbHJlYWR5IGluIGdyb3VwXG5cdFx0XHRpZiAoaW5BcnJheShncm91cE5hbWUsIGxheWVyLmdyb3VwcykgPT09IC0xKSB7XG5cdFx0XHRcdC8vIEFkZCBsYXllciB0byBncm91cFxuXHRcdFx0XHRncm91cHMucHVzaChncm91cE5hbWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBVcGRhdGUgbGF5ZXIgZ3JvdXAgbWFwc1xuXHRcdCRjYW52YXMuc2V0TGF5ZXIobGF5ZXIsIHtcblx0XHRcdGdyb3VwczogZ3JvdXBzXG5cdFx0fSk7XG5cblx0fVxuXHRyZXR1cm4gJGNhbnZhc2VzO1xufTtcblxuLy8gUmVtb3ZlIGFuIGV4aXN0aW5nIGxheWVyIGZyb20gYSBsYXllciBncm91cFxuJC5mbi5yZW1vdmVMYXllckZyb21Hcm91cCA9IGZ1bmN0aW9uIHJlbW92ZUxheWVyRnJvbUdyb3VwKGxheWVySWQsIGdyb3VwTmFtZSkge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgJGNhbnZhcywgZSxcblx0XHRsYXllciwgZ3JvdXBzID0gW10sXG5cdFx0aW5kZXg7XG5cblx0Zm9yIChlID0gMDsgZSA8ICRjYW52YXNlcy5sZW5ndGg7IGUgKz0gMSkge1xuXHRcdCRjYW52YXMgPSAkKCRjYW52YXNlc1tlXSk7XG5cdFx0bGF5ZXIgPSAkY2FudmFzLmdldExheWVyKGxheWVySWQpO1xuXG5cdFx0aWYgKGxheWVyLmdyb3Vwcykge1xuXG5cdFx0XHQvLyBGaW5kIGluZGV4IG9mIGxheWVyIGluIGdyb3VwXG5cdFx0XHRpbmRleCA9IGluQXJyYXkoZ3JvdXBOYW1lLCBsYXllci5ncm91cHMpO1xuXG5cdFx0XHQvLyBJZiBsYXllciBpcyBpbiBncm91cFxuXHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXG5cdFx0XHRcdC8vIENsb25lIGdyb3VwcyBsaXN0XG5cdFx0XHRcdGdyb3VwcyA9IGxheWVyLmdyb3Vwcy5zbGljZSgwKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgbGF5ZXIgZnJvbSBncm91cFxuXHRcdFx0XHRncm91cHMuc3BsaWNlKGluZGV4LCAxKTtcblxuXHRcdFx0XHQvLyBVcGRhdGUgbGF5ZXIgZ3JvdXAgbWFwc1xuXHRcdFx0XHQkY2FudmFzLnNldExheWVyKGxheWVyLCB7XG5cdFx0XHRcdFx0Z3JvdXBzOiBncm91cHNcblx0XHRcdFx0fSk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cdHJldHVybiAkY2FudmFzZXM7XG59O1xuXG4vLyBHZXQgdG9wbW9zdCBsYXllciB0aGF0IGludGVyc2VjdHMgd2l0aCBldmVudCBjb29yZGluYXRlc1xuZnVuY3Rpb24gX2dldEludGVyc2VjdGluZ0xheWVyKGRhdGEpIHtcblx0dmFyIGxheWVyLCBpLFxuXHRcdG1hc2ssIG07XG5cblx0Ly8gU3RvcmUgdGhlIHRvcG1vc3QgbGF5ZXJcblx0bGF5ZXIgPSBudWxsO1xuXG5cdC8vIEdldCB0aGUgdG9wbW9zdCBsYXllciB3aG9zZSB2aXNpYmxlIGFyZWEgaW50ZXJzZWN0cyBldmVudCBjb29yZGluYXRlc1xuXHRmb3IgKGkgPSBkYXRhLmludGVyc2VjdGluZy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuXG5cdFx0Ly8gR2V0IGN1cnJlbnQgbGF5ZXJcblx0XHRsYXllciA9IGRhdGEuaW50ZXJzZWN0aW5nW2ldO1xuXG5cdFx0Ly8gSWYgbGF5ZXIgaGFzIHByZXZpb3VzIG1hc2tzXG5cdFx0aWYgKGxheWVyLl9tYXNrcykge1xuXG5cdFx0XHQvLyBTZWFyY2ggcHJldmlvdXMgbWFza3MgdG8gZW5zdXJlXG5cdFx0XHQvLyBsYXllciBpcyB2aXNpYmxlIGF0IGV2ZW50IGNvb3JkaW5hdGVzXG5cdFx0XHRmb3IgKG0gPSBsYXllci5fbWFza3MubGVuZ3RoIC0gMTsgbSA+PSAwOyBtIC09IDEpIHtcblx0XHRcdFx0bWFzayA9IGxheWVyLl9tYXNrc1ttXTtcblx0XHRcdFx0Ly8gSWYgbWFzayBkb2VzIG5vdCBpbnRlcnNlY3QgZXZlbnQgY29vcmRpbmF0ZXNcblx0XHRcdFx0aWYgKCFtYXNrLmludGVyc2VjdHMpIHtcblx0XHRcdFx0XHQvLyBJbmRpY2F0ZSB0aGF0IHRoZSBtYXNrIGRvZXMgbm90XG5cdFx0XHRcdFx0Ly8gaW50ZXJzZWN0IGV2ZW50IGNvb3JkaW5hdGVzXG5cdFx0XHRcdFx0bGF5ZXIuaW50ZXJzZWN0cyA9IGZhbHNlO1xuXHRcdFx0XHRcdC8vIFN0b3Agc2VhcmNoaW5nIHByZXZpb3VzIG1hc2tzXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjb29yZGluYXRlcyBpbnRlcnNlY3QgYWxsIHByZXZpb3VzIG1hc2tzXG5cdFx0XHQvLyBhbmQgbGF5ZXIgaXMgbm90IGludGFuZ2libGVcblx0XHRcdGlmIChsYXllci5pbnRlcnNlY3RzICYmICFsYXllci5pbnRhbmdpYmxlKSB7XG5cdFx0XHRcdC8vIFN0b3Agc2VhcmNoaW5nIGZvciB0b3Btb3N0IGxheWVyXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblx0Ly8gSWYgcmVzdWx0aW5nIGxheWVyIGlzIGludGFuZ2libGVcblx0aWYgKGxheWVyICYmIGxheWVyLmludGFuZ2libGUpIHtcblx0XHQvLyBDdXJzb3IgZG9lcyBub3QgaW50ZXJzZWN0IHRoaXMgbGF5ZXJcblx0XHRsYXllciA9IG51bGw7XG5cdH1cblx0cmV0dXJuIGxheWVyO1xufVxuXG4vLyBEcmF3IGluZGl2aWR1YWwgbGF5ZXIgKGludGVybmFsKVxuZnVuY3Rpb24gX2RyYXdMYXllcigkY2FudmFzLCBjdHgsIGxheWVyLCBuZXh0TGF5ZXJJbmRleCkge1xuXHRpZiAobGF5ZXIgJiYgbGF5ZXIudmlzaWJsZSAmJiBsYXllci5fbWV0aG9kKSB7XG5cdFx0aWYgKG5leHRMYXllckluZGV4KSB7XG5cdFx0XHRsYXllci5fbmV4dCA9IG5leHRMYXllckluZGV4O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsYXllci5fbmV4dCA9IG51bGw7XG5cdFx0fVxuXHRcdC8vIElmIGxheWVyIGlzIGFuIG9iamVjdCwgY2FsbCBpdHMgcmVzcGVjdGl2ZSBtZXRob2Rcblx0XHRpZiAobGF5ZXIuX21ldGhvZCkge1xuXHRcdFx0bGF5ZXIuX21ldGhvZC5jYWxsKCRjYW52YXMsIGxheWVyKTtcblx0XHR9XG5cdH1cbn1cblxuLy8gSGFuZGxlIGRyYWdnaW5nIG9mIHRoZSBjdXJyZW50bHktZHJhZ2dlZCBsYXllclxuZnVuY3Rpb24gX2hhbmRsZUxheWVyRHJhZygkY2FudmFzLCBkYXRhLCBldmVudFR5cGUpIHtcblx0dmFyIGxheWVycywgbGF5ZXIsIGwsXG5cdFx0ZHJhZywgZHJhZ0dyb3Vwcyxcblx0XHRncm91cCwgZ3JvdXBOYW1lLCBnLFxuXHRcdG5ld1gsIG5ld1k7XG5cblx0ZHJhZyA9IGRhdGEuZHJhZztcblx0bGF5ZXIgPSBkcmFnLmxheWVyO1xuXHRkcmFnR3JvdXBzID0gKGxheWVyICYmIGxheWVyLmRyYWdHcm91cHMpIHx8IFtdO1xuXHRsYXllcnMgPSBkYXRhLmxheWVycztcblxuXHRpZiAoZXZlbnRUeXBlID09PSAnbW91c2Vtb3ZlJyB8fCBldmVudFR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG5cdFx0Ly8gRGV0ZWN0IHdoZW4gdXNlciBpcyBjdXJyZW50bHkgZHJhZ2dpbmcgbGF5ZXJcblxuXHRcdGlmICghZHJhZy5kcmFnZ2luZykge1xuXHRcdFx0Ly8gRGV0ZWN0IHdoZW4gdXNlciBzdGFydHMgZHJhZ2dpbmcgbGF5ZXJcblxuXHRcdFx0Ly8gU2lnbmlmeSB0aGF0IGEgbGF5ZXIgb24gdGhlIGNhbnZhcyBpcyBiZWluZyBkcmFnZ2VkXG5cdFx0XHRkcmFnLmRyYWdnaW5nID0gdHJ1ZTtcblx0XHRcdGxheWVyLmRyYWdnaW5nID0gdHJ1ZTtcblxuXHRcdFx0Ly8gT3B0aW9uYWxseSBicmluZyBsYXllciB0byBmcm9udCB3aGVuIGRyYWcgc3RhcnRzXG5cdFx0XHRpZiAobGF5ZXIuYnJpbmdUb0Zyb250KSB7XG5cdFx0XHRcdC8vIFJlbW92ZSBsYXllciBmcm9tIGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuXHRcdFx0XHRsYXllcnMuc3BsaWNlKGxheWVyLmluZGV4LCAxKTtcblx0XHRcdFx0Ly8gQnJpbmcgbGF5ZXIgdG8gZnJvbnRcblx0XHRcdFx0Ly8gcHVzaCgpIHJldHVybnMgdGhlIG5ldyBhcnJheSBsZW5ndGhcblx0XHRcdFx0bGF5ZXIuaW5kZXggPSBsYXllcnMucHVzaChsYXllcik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkcmFnIHByb3BlcnRpZXMgZm9yIHRoaXMgbGF5ZXJcblx0XHRcdGxheWVyLl9zdGFydFggPSBsYXllci54O1xuXHRcdFx0bGF5ZXIuX3N0YXJ0WSA9IGxheWVyLnk7XG5cdFx0XHRsYXllci5fZW5kWCA9IGxheWVyLl9ldmVudFg7XG5cdFx0XHRsYXllci5fZW5kWSA9IGxheWVyLl9ldmVudFk7XG5cblx0XHRcdC8vIFRyaWdnZXIgZHJhZ3N0YXJ0IGV2ZW50XG5cdFx0XHRfdHJpZ2dlckxheWVyRXZlbnQoJGNhbnZhcywgZGF0YSwgbGF5ZXIsICdkcmFnc3RhcnQnKTtcblxuXHRcdH1cblxuXHRcdGlmIChkcmFnLmRyYWdnaW5nKSB7XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBhZnRlciBkcmFnXG5cdFx0XHRuZXdYID0gbGF5ZXIuX2V2ZW50WCAtIChsYXllci5fZW5kWCAtIGxheWVyLl9zdGFydFgpO1xuXHRcdFx0bmV3WSA9IGxheWVyLl9ldmVudFkgLSAobGF5ZXIuX2VuZFkgLSBsYXllci5fc3RhcnRZKTtcblx0XHRcdGlmIChsYXllci51cGRhdGVEcmFnWCkge1xuXHRcdFx0XHRuZXdYID0gbGF5ZXIudXBkYXRlRHJhZ1guY2FsbCgkY2FudmFzWzBdLCBsYXllciwgbmV3WCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGF5ZXIudXBkYXRlRHJhZ1kpIHtcblx0XHRcdFx0bmV3WSA9IGxheWVyLnVwZGF0ZURyYWdZLmNhbGwoJGNhbnZhc1swXSwgbGF5ZXIsIG5ld1kpO1xuXHRcdFx0fVxuXHRcdFx0bGF5ZXIuZHggPSBuZXdYIC0gbGF5ZXIueDtcblx0XHRcdGxheWVyLmR5ID0gbmV3WSAtIGxheWVyLnk7XG5cdFx0XHRpZiAobGF5ZXIucmVzdHJpY3REcmFnVG9BeGlzICE9PSAneScpIHtcblx0XHRcdFx0bGF5ZXIueCA9IG5ld1g7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGF5ZXIucmVzdHJpY3REcmFnVG9BeGlzICE9PSAneCcpIHtcblx0XHRcdFx0bGF5ZXIueSA9IG5ld1k7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyaWdnZXIgZHJhZyBldmVudFxuXHRcdFx0X3RyaWdnZXJMYXllckV2ZW50KCRjYW52YXMsIGRhdGEsIGxheWVyLCAnZHJhZycpO1xuXG5cdFx0XHQvLyBNb3ZlIGdyb3VwcyB3aXRoIGxheWVyIG9uIGRyYWdcblx0XHRcdGZvciAoZyA9IDA7IGcgPCBkcmFnR3JvdXBzLmxlbmd0aDsgZyArPSAxKSB7XG5cblx0XHRcdFx0Z3JvdXBOYW1lID0gZHJhZ0dyb3Vwc1tnXTtcblx0XHRcdFx0Z3JvdXAgPSBkYXRhLmxheWVyLmdyb3Vwc1tncm91cE5hbWVdO1xuXHRcdFx0XHRpZiAobGF5ZXIuZ3JvdXBzICYmIGdyb3VwKSB7XG5cblx0XHRcdFx0XHRmb3IgKGwgPSAwOyBsIDwgZ3JvdXAubGVuZ3RoOyBsICs9IDEpIHtcblx0XHRcdFx0XHRcdGlmIChncm91cFtsXSAhPT0gbGF5ZXIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGxheWVyLnJlc3RyaWN0RHJhZ1RvQXhpcyAhPT0gJ3knICYmIGdyb3VwW2xdLnJlc3RyaWN0RHJhZ1RvQXhpcyAhPT0gJ3knKSB7XG5cdFx0XHRcdFx0XHRcdFx0Z3JvdXBbbF0ueCArPSBsYXllci5keDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAobGF5ZXIucmVzdHJpY3REcmFnVG9BeGlzICE9PSAneCcgJiYgZ3JvdXBbbF0ucmVzdHJpY3REcmFnVG9BeGlzICE9PSAneCcpIHtcblx0XHRcdFx0XHRcdFx0XHRncm91cFtsXS55ICs9IGxheWVyLmR5O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSAnbW91c2V1cCcgfHwgZXZlbnRUeXBlID09PSAndG91Y2hlbmQnKSB7XG5cdFx0Ly8gRGV0ZWN0IHdoZW4gdXNlciBzdG9wcyBkcmFnZ2luZyBsYXllclxuXG5cdFx0aWYgKGRyYWcuZHJhZ2dpbmcpIHtcblx0XHRcdGxheWVyLmRyYWdnaW5nID0gZmFsc2U7XG5cdFx0XHRkcmFnLmRyYWdnaW5nID0gZmFsc2U7XG5cdFx0XHRkYXRhLnJlZHJhd09uTW91c2Vtb3ZlID0gZGF0YS5vcmlnaW5hbFJlZHJhd09uTW91c2Vtb3ZlO1xuXHRcdFx0Ly8gVHJpZ2dlciBkcmFnc3RvcCBldmVudFxuXHRcdFx0X3RyaWdnZXJMYXllckV2ZW50KCRjYW52YXMsIGRhdGEsIGxheWVyLCAnZHJhZ3N0b3AnKTtcblx0XHR9XG5cblx0XHQvLyBDYW5jZWwgZHJhZ2dpbmdcblx0XHRkYXRhLmRyYWcgPSB7fTtcblxuXHR9XG59XG5cblxuLy8gTGlzdCBvZiBDU1MzIGN1cnNvcnMgdGhhdCBuZWVkIHRvIGJlIHByZWZpeGVkXG5jc3MuY3Vyc29ycyA9IFsnZ3JhYicsICdncmFiYmluZycsICd6b29tLWluJywgJ3pvb20tb3V0J107XG5cbi8vIEZ1bmN0aW9uIHRvIGRldGVjdCB2ZW5kb3IgcHJlZml4XG4vLyBNb2RpZmllZCB2ZXJzaW9uIG9mIERhdmlkIFdhbHNoJ3MgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vZGF2aWR3YWxzaC5uYW1lL3ZlbmRvci1wcmVmaXhcbmNzcy5wcmVmaXggPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgc3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICcnKSxcblx0XHRwcmUgPSAoYXJyYXlTbGljZVxuXHRcdFx0LmNhbGwoc3R5bGVzKVxuXHRcdFx0LmpvaW4oJycpXG5cdFx0XHQubWF0Y2goLy0obW96fHdlYmtpdHxtcyktLykgfHwgKHN0eWxlcy5PTGluayA9PT0gJycgJiYgWycnLCAnbyddKVxuXHRcdClbMV07XG5cdHJldHVybiAnLScgKyBwcmUgKyAnLSc7XG59KSgpO1xuXG4vLyBTZXQgY3Vyc29yIG9uIGNhbnZhc1xuZnVuY3Rpb24gX3NldEN1cnNvcigkY2FudmFzLCBsYXllciwgZXZlbnRUeXBlKSB7XG5cdHZhciBjdXJzb3I7XG5cdGlmIChsYXllci5jdXJzb3JzKSB7XG5cdFx0Ly8gUmV0cmlldmUgY3Vyc29yIGZyb20gY3Vyc29ycyBvYmplY3QgaWYgaXQgZXhpc3RzXG5cdFx0Y3Vyc29yID0gbGF5ZXIuY3Vyc29yc1tldmVudFR5cGVdO1xuXHR9XG5cdC8vIFByZWZpeCBhbnkgQ1NTMyBjdXJzb3Jcblx0aWYgKCQuaW5BcnJheShjdXJzb3IsIGNzcy5jdXJzb3JzKSAhPT0gLTEpIHtcblx0XHRjdXJzb3IgPSBjc3MucHJlZml4ICsgY3Vyc29yO1xuXHR9XG5cdC8vIElmIGN1cnNvciBpcyBkZWZpbmVkXG5cdGlmIChjdXJzb3IpIHtcblx0XHQvLyBTZXQgY2FudmFzIGN1cnNvclxuXHRcdCRjYW52YXMuY3NzKHtcblx0XHRcdGN1cnNvcjogY3Vyc29yXG5cdFx0fSk7XG5cdH1cbn1cblxuLy8gUmVzZXQgY3Vyc29yIG9uIGNhbnZhc1xuZnVuY3Rpb24gX3Jlc2V0Q3Vyc29yKCRjYW52YXMsIGRhdGEpIHtcblx0JGNhbnZhcy5jc3Moe1xuXHRcdGN1cnNvcjogZGF0YS5jdXJzb3Jcblx0fSk7XG59XG5cbi8vIFJ1biB0aGUgZ2l2ZW4gZXZlbnQgY2FsbGJhY2sgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5mdW5jdGlvbiBfcnVuRXZlbnRDYWxsYmFjaygkY2FudmFzLCBsYXllciwgZXZlbnRUeXBlLCBjYWxsYmFja3MsIGFyZykge1xuXHQvLyBQcmV2ZW50IGNhbGxiYWNrIGZyb20gZmlyaW5nIHJlY3Vyc2l2ZWx5XG5cdGlmIChjYWxsYmFja3NbZXZlbnRUeXBlXSAmJiBsYXllci5fcnVubmluZyAmJiAhbGF5ZXIuX3J1bm5pbmdbZXZlbnRUeXBlXSkge1xuXHRcdC8vIFNpZ25pZnkgdGhlIHN0YXJ0IG9mIGNhbGxiYWNrIGV4ZWN1dGlvbiBmb3IgdGhpcyBldmVudFxuXHRcdGxheWVyLl9ydW5uaW5nW2V2ZW50VHlwZV0gPSB0cnVlO1xuXHRcdC8vIFJ1biBldmVudCBjYWxsYmFjayB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRjYWxsYmFja3NbZXZlbnRUeXBlXS5jYWxsKCRjYW52YXNbMF0sIGxheWVyLCBhcmcpO1xuXHRcdC8vIFNpZ25pZnkgdGhlIGVuZCBvZiBjYWxsYmFjayBleGVjdXRpb24gZm9yIHRoaXMgZXZlbnRcblx0XHRsYXllci5fcnVubmluZ1tldmVudFR5cGVdID0gZmFsc2U7XG5cdH1cbn1cblxuLy8gRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBsYXllciBjYW4gXCJsZWdhbGx5XCIgZmlyZSB0aGUgZ2l2ZW4gZXZlbnRcbmZ1bmN0aW9uIF9sYXllckNhbkZpcmVFdmVudChsYXllciwgZXZlbnRUeXBlKSB7XG5cdC8vIElmIGV2ZW50cyBhcmUgZGlzYWJsZSBhbmQgaWZcblx0Ly8gbGF5ZXIgaXMgdGFuZ2libGUgb3IgZXZlbnQgaXMgbm90IHRhbmdpYmxlXG5cdHJldHVybiAoIWxheWVyLmRpc2FibGVFdmVudHMgJiZcblx0XHQoIWxheWVyLmludGFuZ2libGUgfHwgJC5pbkFycmF5KGV2ZW50VHlwZSwgdGFuZ2libGVFdmVudHMpID09PSAtMSkpO1xufVxuXG4vLyBUcmlnZ2VyIHRoZSBnaXZlbiBldmVudCBvbiB0aGUgZ2l2ZW4gbGF5ZXJcbmZ1bmN0aW9uIF90cmlnZ2VyTGF5ZXJFdmVudCgkY2FudmFzLCBkYXRhLCBsYXllciwgZXZlbnRUeXBlLCBhcmcpIHtcblx0Ly8gSWYgbGF5ZXIgY2FuIGxlZ2FsbHkgZmlyZSB0aGlzIGV2ZW50IHR5cGVcblx0aWYgKF9sYXllckNhbkZpcmVFdmVudChsYXllciwgZXZlbnRUeXBlKSkge1xuXG5cdFx0Ly8gRG8gbm90IHNldCBhIGN1c3RvbSBjdXJzb3Igb24gbGF5ZXIgbW91c2VvdXRcblx0XHRpZiAoZXZlbnRUeXBlICE9PSAnbW91c2VvdXQnKSB7XG5cdFx0XHQvLyBVcGRhdGUgY3Vyc29yIGlmIG9uZSBpcyBkZWZpbmVkIGZvciB0aGlzIGV2ZW50XG5cdFx0XHRfc2V0Q3Vyc29yKCRjYW52YXMsIGxheWVyLCBldmVudFR5cGUpO1xuXHRcdH1cblxuXHRcdC8vIFRyaWdnZXIgdGhlIHVzZXItZGVmaW5lZCBldmVudCBjYWxsYmFja1xuXHRcdF9ydW5FdmVudENhbGxiYWNrKCRjYW52YXMsIGxheWVyLCBldmVudFR5cGUsIGxheWVyLCBhcmcpO1xuXHRcdC8vIFRyaWdnZXIgdGhlIGNhbnZhcy1ib3VuZCBldmVudCBob29rXG5cdFx0X3J1bkV2ZW50Q2FsbGJhY2soJGNhbnZhcywgbGF5ZXIsIGV2ZW50VHlwZSwgZGF0YS5ldmVudEhvb2tzLCBhcmcpO1xuXHRcdC8vIFRyaWdnZXIgdGhlIGdsb2JhbCBldmVudCBob29rXG5cdFx0X3J1bkV2ZW50Q2FsbGJhY2soJGNhbnZhcywgbGF5ZXIsIGV2ZW50VHlwZSwgakNhbnZhcy5ldmVudEhvb2tzLCBhcmcpO1xuXG5cdH1cbn1cblxuLy8gTWFudWFsbHkgdHJpZ2dlciBhIGxheWVyIGV2ZW50XG4kLmZuLnRyaWdnZXJMYXllckV2ZW50ID0gZnVuY3Rpb24gKGxheWVyLCBldmVudFR5cGUpIHtcblx0dmFyICRjYW52YXNlcyA9IHRoaXMsICRjYW52YXMsIGUsXG5cdFx0ZGF0YTtcblxuXHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0JGNhbnZhcyA9ICQoJGNhbnZhc2VzW2VdKTtcblx0XHRkYXRhID0gX2dldENhbnZhc0RhdGEoJGNhbnZhc2VzW2VdKTtcblx0XHRsYXllciA9ICRjYW52YXMuZ2V0TGF5ZXIobGF5ZXIpO1xuXHRcdGlmIChsYXllcikge1xuXHRcdFx0X3RyaWdnZXJMYXllckV2ZW50KCRjYW52YXMsIGRhdGEsIGxheWVyLCBldmVudFR5cGUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gJGNhbnZhc2VzO1xufTtcblxuLy8gRHJhdyBsYXllciB3aXRoIHRoZSBnaXZlbiBJRFxuJC5mbi5kcmF3TGF5ZXIgPSBmdW5jdGlvbiBkcmF3TGF5ZXIobGF5ZXJJZCkge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgZSwgY3R4LFxuXHRcdCRjYW52YXMsIGxheWVyO1xuXG5cdGZvciAoZSA9IDA7IGUgPCAkY2FudmFzZXMubGVuZ3RoOyBlICs9IDEpIHtcblx0XHQkY2FudmFzID0gJCgkY2FudmFzZXNbZV0pO1xuXHRcdGN0eCA9IF9nZXRDb250ZXh0KCRjYW52YXNlc1tlXSk7XG5cdFx0aWYgKGN0eCkge1xuXHRcdFx0bGF5ZXIgPSAkY2FudmFzLmdldExheWVyKGxheWVySWQpO1xuXHRcdFx0X2RyYXdMYXllcigkY2FudmFzLCBjdHgsIGxheWVyKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuICRjYW52YXNlcztcbn07XG5cbi8vIERyYXcgYWxsIGxheWVycyAob3IsIGlmIGdpdmVuLCBvbmx5IGxheWVycyBzdGFydGluZyBhdCBhbiBpbmRleClcbiQuZm4uZHJhd0xheWVycyA9IGZ1bmN0aW9uIGRyYXdMYXllcnMoYXJncykge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgJGNhbnZhcywgZSwgY3R4LFxuXHRcdC8vIEludGVybmFsIHBhcmFtZXRlcnMgZm9yIHJlZHJhd2luZyB0aGUgY2FudmFzXG5cdFx0cGFyYW1zID0gYXJncyB8fCB7fSxcblx0XHQvLyBPdGhlciB2YXJpYWJsZXNcblx0XHRsYXllcnMsIGxheWVyLCBsYXN0TGF5ZXIsIGwsIGluZGV4LCBsYXN0SW5kZXgsXG5cdFx0ZGF0YSwgZXZlbnRDYWNoZSwgZXZlbnRUeXBlLCBpc0ltYWdlTGF5ZXI7XG5cblx0Ly8gVGhlIGxheWVyIGluZGV4IGZyb20gd2hpY2ggdG8gc3RhcnQgcmVkcmF3aW5nIHRoZSBjYW52YXNcblx0aW5kZXggPSBwYXJhbXMuaW5kZXg7XG5cdGlmICghaW5kZXgpIHtcblx0XHRpbmRleCA9IDA7XG5cdH1cblxuXHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0JGNhbnZhcyA9ICQoJGNhbnZhc2VzW2VdKTtcblx0XHRjdHggPSBfZ2V0Q29udGV4dCgkY2FudmFzZXNbZV0pO1xuXHRcdGlmIChjdHgpIHtcblxuXHRcdFx0ZGF0YSA9IF9nZXRDYW52YXNEYXRhKCRjYW52YXNlc1tlXSk7XG5cblx0XHRcdC8vIENsZWFyIGNhbnZhcyBmaXJzdCB1bmxlc3Mgb3RoZXJ3aXNlIGRpcmVjdGVkXG5cdFx0XHRpZiAocGFyYW1zLmNsZWFyICE9PSBmYWxzZSkge1xuXHRcdFx0XHQkY2FudmFzLmNsZWFyQ2FudmFzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgY29tcGxldGlvbiBjYWxsYmFjayB3YXMgcHJvdmlkZWQsIHNhdmUgaXQgdG8gdGhlIGNhbnZhcyBkYXRhXG5cdFx0XHQvLyBzdG9yZSBzbyB0aGF0IHRoZSBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIHRvIGRyYXdMYXllcnMoKSBhZ2FpblxuXHRcdFx0Ly8gYWZ0ZXIgYW55IGltYWdlIGxheWVycyBoYXZlIGxvYWRlZFxuXHRcdFx0aWYgKHBhcmFtcy5jb21wbGV0ZSkge1xuXHRcdFx0XHRkYXRhLmRyYXdMYXllcnNDb21wbGV0ZSA9IHBhcmFtcy5jb21wbGV0ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FjaGUgdGhlIGxheWVycyBhcnJheVxuXHRcdFx0bGF5ZXJzID0gZGF0YS5sYXllcnM7XG5cblx0XHRcdC8vIERyYXcgbGF5ZXJzIGZyb20gZmlyc3QgdG8gbGFzdCAoYm90dG9tIHRvIHRvcClcblx0XHRcdGZvciAobCA9IGluZGV4OyBsIDwgbGF5ZXJzLmxlbmd0aDsgbCArPSAxKSB7XG5cdFx0XHRcdGxheWVyID0gbGF5ZXJzW2xdO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBsYXllciBpbmRleCBpcyB1cC10by1kYXRlXG5cdFx0XHRcdGxheWVyLmluZGV4ID0gbDtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IGFueSBvbmUgZXZlbnQgZnJvbSBmaXJpbmcgZXhjZXNzaXZlbHlcblx0XHRcdFx0aWYgKHBhcmFtcy5yZXNldEZpcmUpIHtcblx0XHRcdFx0XHRsYXllci5fZmlyZWQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBEcmF3IGxheWVyXG5cdFx0XHRcdF9kcmF3TGF5ZXIoJGNhbnZhcywgY3R4LCBsYXllciwgbCArIDEpO1xuXHRcdFx0XHQvLyBTdG9yZSBsaXN0IG9mIHByZXZpb3VzIG1hc2tzIGZvciBlYWNoIGxheWVyXG5cdFx0XHRcdGxheWVyLl9tYXNrcyA9IGRhdGEudHJhbnNmb3Jtcy5tYXNrcy5zbGljZSgwKTtcblxuXHRcdFx0XHQvLyBBbGxvdyBpbWFnZSBsYXllcnMgdG8gbG9hZCBiZWZvcmUgZHJhd2luZyBzdWNjZXNzaXZlIGxheWVyc1xuXHRcdFx0XHRpZiAobGF5ZXIuX21ldGhvZCA9PT0gJC5mbi5kcmF3SW1hZ2UgJiYgbGF5ZXIudmlzaWJsZSkge1xuXHRcdFx0XHRcdGlzSW1hZ2VMYXllciA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBsYXllciBpcyBhbiBpbWFnZSBsYXllclxuXHRcdFx0aWYgKGlzSW1hZ2VMYXllcikge1xuXHRcdFx0XHQvLyBTdG9wIGFuZCB3YWl0IGZvciBkcmF3SW1hZ2UoKSB0byByZXN1bWUgZHJhd0xheWVycygpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSB0aGUgbGF0ZXN0XG5cdFx0XHRsYXN0SW5kZXggPSBsO1xuXG5cdFx0XHQvLyBSdW4gY29tcGxldGlvbiBjYWxsYmFjayAoaWYgcHJvdmlkZWQpIG9uY2UgYWxsIGxheWVycyBoYXZlIGRyYXduXG5cdFx0XHRpZiAocGFyYW1zLmNvbXBsZXRlKSB7XG5cdFx0XHRcdHBhcmFtcy5jb21wbGV0ZS5jYWxsKCRjYW52YXNlc1tlXSk7XG5cdFx0XHRcdGRlbGV0ZSBkYXRhLmRyYXdMYXllcnNDb21wbGV0ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2V0IGZpcnN0IGxheWVyIHRoYXQgaW50ZXJzZWN0cyB3aXRoIGV2ZW50IGNvb3JkaW5hdGVzXG5cdFx0XHRsYXllciA9IF9nZXRJbnRlcnNlY3RpbmdMYXllcihkYXRhKTtcblxuXHRcdFx0ZXZlbnRDYWNoZSA9IGRhdGEuZXZlbnQ7XG5cdFx0XHRldmVudFR5cGUgPSBldmVudENhY2hlLnR5cGU7XG5cblx0XHRcdC8vIElmIGpDYW52YXMgaGFzIGRldGVjdGVkIGEgZHJhZ3N0YXJ0XG5cdFx0XHRpZiAoZGF0YS5kcmFnLmxheWVyKSB7XG5cdFx0XHRcdC8vIEhhbmRsZSBkcmFnZ2luZyBvZiBsYXllclxuXHRcdFx0XHRfaGFuZGxlTGF5ZXJEcmFnKCRjYW52YXMsIGRhdGEsIGV2ZW50VHlwZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hbmFnZSBtb3VzZW91dCBldmVudFxuXHRcdFx0bGFzdExheWVyID0gZGF0YS5sYXN0SW50ZXJzZWN0ZWQ7XG5cdFx0XHRpZiAobGFzdExheWVyICE9PSBudWxsICYmIGxheWVyICE9PSBsYXN0TGF5ZXIgJiYgbGFzdExheWVyLl9ob3ZlcmVkICYmICFsYXN0TGF5ZXIuX2ZpcmVkICYmICFkYXRhLmRyYWcuZHJhZ2dpbmcpIHtcblxuXHRcdFx0XHRkYXRhLmxhc3RJbnRlcnNlY3RlZCA9IG51bGw7XG5cdFx0XHRcdGxhc3RMYXllci5fZmlyZWQgPSB0cnVlO1xuXHRcdFx0XHRsYXN0TGF5ZXIuX2hvdmVyZWQgPSBmYWxzZTtcblx0XHRcdFx0X3RyaWdnZXJMYXllckV2ZW50KCRjYW52YXMsIGRhdGEsIGxhc3RMYXllciwgJ21vdXNlb3V0Jyk7XG5cdFx0XHRcdF9yZXNldEN1cnNvcigkY2FudmFzLCBkYXRhKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobGF5ZXIpIHtcblxuXHRcdFx0XHQvLyBVc2UgbW91c2UgZXZlbnQgY2FsbGJhY2tzIGlmIG5vIHRvdWNoIGV2ZW50IGNhbGxiYWNrcyBhcmUgZ2l2ZW5cblx0XHRcdFx0aWYgKCFsYXllcltldmVudFR5cGVdKSB7XG5cdFx0XHRcdFx0ZXZlbnRUeXBlID0gX2dldE1vdXNlRXZlbnROYW1lKGV2ZW50VHlwZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDaGVjayBldmVudHMgZm9yIGludGVyc2VjdGluZyBsYXllclxuXHRcdFx0XHRpZiAobGF5ZXIuX2V2ZW50ICYmIGxheWVyLmludGVyc2VjdHMpIHtcblxuXHRcdFx0XHRcdGRhdGEubGFzdEludGVyc2VjdGVkID0gbGF5ZXI7XG5cblx0XHRcdFx0XHQvLyBEZXRlY3QgbW91c2VvdmVyIGV2ZW50c1xuXHRcdFx0XHRcdGlmICgobGF5ZXIubW91c2VvdmVyIHx8IGxheWVyLm1vdXNlb3V0IHx8IGxheWVyLmN1cnNvcnMpICYmICFkYXRhLmRyYWcuZHJhZ2dpbmcpIHtcblxuXHRcdFx0XHRcdFx0aWYgKCFsYXllci5faG92ZXJlZCAmJiAhbGF5ZXIuX2ZpcmVkKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJldmVudCBldmVudHMgZnJvbSBmaXJpbmcgZXhjZXNzaXZlbHlcblx0XHRcdFx0XHRcdFx0bGF5ZXIuX2ZpcmVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0bGF5ZXIuX2hvdmVyZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRfdHJpZ2dlckxheWVyRXZlbnQoJGNhbnZhcywgZGF0YSwgbGF5ZXIsICdtb3VzZW92ZXInKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGV0ZWN0IGFueSBvdGhlciBtb3VzZSBldmVudFxuXHRcdFx0XHRcdGlmICghbGF5ZXIuX2ZpcmVkKSB7XG5cblx0XHRcdFx0XHRcdC8vIFByZXZlbnQgZXZlbnQgZnJvbSBmaXJpbmcgdHdpY2UgdW5pbnRlbnRpb25hbGx5XG5cdFx0XHRcdFx0XHRsYXllci5fZmlyZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0ZXZlbnRDYWNoZS50eXBlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0X3RyaWdnZXJMYXllckV2ZW50KCRjYW52YXMsIGRhdGEsIGxheWVyLCBldmVudFR5cGUpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gVXNlIHRoZSBtb3VzZWRvd24gZXZlbnQgdG8gc3RhcnQgZHJhZ1xuXHRcdFx0XHRcdGlmIChsYXllci5kcmFnZ2FibGUgJiYgIWxheWVyLmRpc2FibGVFdmVudHMgJiYgKGV2ZW50VHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZXZlbnRUeXBlID09PSAndG91Y2hzdGFydCcpKSB7XG5cblx0XHRcdFx0XHRcdC8vIEtlZXAgdHJhY2sgb2YgZHJhZyBzdGF0ZVxuXHRcdFx0XHRcdFx0ZGF0YS5kcmFnLmxheWVyID0gbGF5ZXI7XG5cdFx0XHRcdFx0XHRkYXRhLm9yaWdpbmFsUmVkcmF3T25Nb3VzZW1vdmUgPSBkYXRhLnJlZHJhd09uTW91c2Vtb3ZlO1xuXHRcdFx0XHRcdFx0ZGF0YS5yZWRyYXdPbk1vdXNlbW92ZSA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGN1cnNvciBpcyBub3QgaW50ZXJzZWN0aW5nIHdpdGggYW55IGxheWVyXG5cdFx0XHRpZiAobGF5ZXIgPT09IG51bGwgJiYgIWRhdGEuZHJhZy5kcmFnZ2luZykge1xuXHRcdFx0XHQvLyBSZXNldCBjdXJzb3IgdG8gcHJldmlvdXMgc3RhdGVcblx0XHRcdFx0X3Jlc2V0Q3Vyc29yKCRjYW52YXMsIGRhdGEpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgbGFzdCBsYXllciBoYXMgYmVlbiBkcmF3blxuXHRcdFx0aWYgKGxhc3RJbmRleCA9PT0gbGF5ZXJzLmxlbmd0aCkge1xuXG5cdFx0XHRcdC8vIFJlc2V0IGxpc3Qgb2YgaW50ZXJzZWN0aW5nIGxheWVyc1xuXHRcdFx0XHRkYXRhLmludGVyc2VjdGluZy5sZW5ndGggPSAwO1xuXHRcdFx0XHQvLyBSZXNldCB0cmFuc2Zvcm1hdGlvbiBzdGFja1xuXHRcdFx0XHRkYXRhLnRyYW5zZm9ybXMgPSBfY2xvbmVUcmFuc2Zvcm1zKGJhc2VUcmFuc2Zvcm1zKTtcblx0XHRcdFx0ZGF0YS5zYXZlZFRyYW5zZm9ybXMubGVuZ3RoID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXHR9XG5cdHJldHVybiAkY2FudmFzZXM7XG59O1xuXG4vLyBBZGQgYSBqQ2FudmFzIGxheWVyIChpbnRlcm5hbClcbmZ1bmN0aW9uIF9hZGRMYXllcihjYW52YXMsIHBhcmFtcywgYXJncywgbWV0aG9kKSB7XG5cdHZhciAkY2FudmFzLCBkYXRhLFxuXHRcdGxheWVycywgbGF5ZXIgPSAocGFyYW1zLl9sYXllciA/IGFyZ3MgOiBwYXJhbXMpO1xuXG5cdC8vIFN0b3JlIGFyZ3VtZW50cyBvYmplY3QgZm9yIGxhdGVyIHVzZVxuXHRwYXJhbXMuX2FyZ3MgPSBhcmdzO1xuXG5cdC8vIENvbnZlcnQgYWxsIGRyYWdnYWJsZSBkcmF3aW5ncyBpbnRvIGpDYW52YXMgbGF5ZXJzXG5cdGlmIChwYXJhbXMuZHJhZ2dhYmxlIHx8IHBhcmFtcy5kcmFnR3JvdXBzKSB7XG5cdFx0cGFyYW1zLmxheWVyID0gdHJ1ZTtcblx0XHRwYXJhbXMuZHJhZ2dhYmxlID0gdHJ1ZTtcblx0fVxuXG5cdC8vIERldGVybWluZSB0aGUgbGF5ZXIncyB0eXBlIHVzaW5nIHRoZSBhdmFpbGFibGUgaW5mb3JtYXRpb25cblx0aWYgKCFwYXJhbXMuX21ldGhvZCkge1xuXHRcdGlmIChtZXRob2QpIHtcblx0XHRcdHBhcmFtcy5fbWV0aG9kID0gbWV0aG9kO1xuXHRcdH0gZWxzZSBpZiAocGFyYW1zLm1ldGhvZCkge1xuXHRcdFx0cGFyYW1zLl9tZXRob2QgPSAkLmZuW3BhcmFtcy5tZXRob2RdO1xuXHRcdH0gZWxzZSBpZiAocGFyYW1zLnR5cGUpIHtcblx0XHRcdHBhcmFtcy5fbWV0aG9kID0gJC5mblttYXBzLmRyYXdpbmdzW3BhcmFtcy50eXBlXV07XG5cdFx0fVxuXHR9XG5cblx0Ly8gSWYgbGF5ZXIgaGFzbid0IGJlZW4gYWRkZWQgeWV0XG5cdGlmIChwYXJhbXMubGF5ZXIgJiYgIXBhcmFtcy5fbGF5ZXIpIHtcblx0XHQvLyBBZGQgbGF5ZXIgdG8gY2FudmFzXG5cblx0XHQkY2FudmFzID0gJChjYW52YXMpO1xuXG5cdFx0ZGF0YSA9IF9nZXRDYW52YXNEYXRhKGNhbnZhcyk7XG5cdFx0bGF5ZXJzID0gZGF0YS5sYXllcnM7XG5cblx0XHQvLyBEbyBub3QgYWRkIGR1cGxpY2F0ZSBsYXllcnMgb2Ygc2FtZSBuYW1lXG5cdFx0aWYgKGxheWVyLm5hbWUgPT09IG51bGwgfHwgKGlzU3RyaW5nKGxheWVyLm5hbWUpICYmIGRhdGEubGF5ZXIubmFtZXNbbGF5ZXIubmFtZV0gPT09IHVuZGVmaW5lZCkpIHtcblxuXHRcdFx0Ly8gQ29udmVydCBudW1iZXIgcHJvcGVydGllcyB0byBudW1iZXJzXG5cdFx0XHRfY29lcmNlTnVtZXJpY1Byb3BzKHBhcmFtcyk7XG5cblx0XHRcdC8vIEVuc3VyZSBsYXllcnMgYXJlIHVuaXF1ZSBhY3Jvc3MgY2FudmFzZXMgYnkgY2xvbmluZyB0aGVtXG5cdFx0XHRsYXllciA9IG5ldyBqQ2FudmFzT2JqZWN0KHBhcmFtcyk7XG5cdFx0XHRsYXllci5jYW52YXMgPSBjYW52YXM7XG5cdFx0XHQvLyBJbmRpY2F0ZSB0aGF0IHRoaXMgaXMgYSBsYXllciBmb3IgZnV0dXJlIGNoZWNrc1xuXHRcdFx0bGF5ZXIubGF5ZXIgPSB0cnVlO1xuXHRcdFx0bGF5ZXIuX2xheWVyID0gdHJ1ZTtcblx0XHRcdGxheWVyLl9ydW5uaW5nID0ge307XG5cdFx0XHQvLyBJZiBsYXllciBzdG9yZXMgdXNlci1kZWZpbmVkIGRhdGFcblx0XHRcdGlmIChsYXllci5kYXRhICE9PSBudWxsKSB7XG5cdFx0XHRcdC8vIENsb25lIG9iamVjdFxuXHRcdFx0XHRsYXllci5kYXRhID0gZXh0ZW5kT2JqZWN0KHt9LCBsYXllci5kYXRhKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGRhdGEgb2JqZWN0XG5cdFx0XHRcdGxheWVyLmRhdGEgPSB7fTtcblx0XHRcdH1cblx0XHRcdC8vIElmIGxheWVyIHN0b3JlcyBhIGxpc3Qgb2YgYXNzb2NpYXRlZCBncm91cHNcblx0XHRcdGlmIChsYXllci5ncm91cHMgIT09IG51bGwpIHtcblx0XHRcdFx0Ly8gQ2xvbmUgbGlzdFxuXHRcdFx0XHRsYXllci5ncm91cHMgPSBsYXllci5ncm91cHMuc2xpY2UoMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBlbXB0eSBsaXN0XG5cdFx0XHRcdGxheWVyLmdyb3VwcyA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgbGF5ZXIgZ3JvdXAgbWFwc1xuXHRcdFx0X3VwZGF0ZUxheWVyTmFtZSgkY2FudmFzLCBkYXRhLCBsYXllcik7XG5cdFx0XHRfdXBkYXRlTGF5ZXJHcm91cHMoJGNhbnZhcywgZGF0YSwgbGF5ZXIpO1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgYW55IGFzc29jaWF0ZWQgakNhbnZhcyBldmVudHMgYW5kIGVuYWJsZSB0aGVtXG5cdFx0XHRfYWRkTGF5ZXJFdmVudHMoJGNhbnZhcywgZGF0YSwgbGF5ZXIpO1xuXG5cdFx0XHQvLyBPcHRpb25hbGx5IGVuYWJsZSBkcmFnLWFuZC1kcm9wIHN1cHBvcnQgYW5kIGN1cnNvciBzdXBwb3J0XG5cdFx0XHRfZW5hYmxlRHJhZygkY2FudmFzLCBkYXRhLCBsYXllcik7XG5cblx0XHRcdC8vIENvcHkgX2V2ZW50IHByb3BlcnR5IHRvIHBhcmFtZXRlcnMgb2JqZWN0XG5cdFx0XHRwYXJhbXMuX2V2ZW50ID0gbGF5ZXIuX2V2ZW50O1xuXG5cdFx0XHQvLyBDYWxjdWxhdGUgd2lkdGgvaGVpZ2h0IGZvciB0ZXh0IGxheWVyc1xuXHRcdFx0aWYgKGxheWVyLl9tZXRob2QgPT09ICQuZm4uZHJhd1RleHQpIHtcblx0XHRcdFx0JGNhbnZhcy5tZWFzdXJlVGV4dChsYXllcik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBsYXllciB0byBlbmQgb2YgYXJyYXkgaWYgbm8gaW5kZXggaXMgc3BlY2lmaWVkXG5cdFx0XHRpZiAobGF5ZXIuaW5kZXggPT09IG51bGwpIHtcblx0XHRcdFx0bGF5ZXIuaW5kZXggPSBsYXllcnMubGVuZ3RoO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgbGF5ZXIgdG8gbGF5ZXJzIGFycmF5IGF0IHNwZWNpZmllZCBpbmRleFxuXHRcdFx0bGF5ZXJzLnNwbGljZShsYXllci5pbmRleCwgMCwgbGF5ZXIpO1xuXG5cdFx0XHQvLyBTdG9yZSBsYXllciBvbiBwYXJhbWV0ZXJzIG9iamVjdFxuXHRcdFx0cGFyYW1zLl9hcmdzID0gbGF5ZXI7XG5cblx0XHRcdC8vIFRyaWdnZXIgYW4gJ2FkZCcgZXZlbnRcblx0XHRcdF90cmlnZ2VyTGF5ZXJFdmVudCgkY2FudmFzLCBkYXRhLCBsYXllciwgJ2FkZCcpO1xuXG5cdFx0fVxuXG5cdH0gZWxzZSBpZiAoIXBhcmFtcy5sYXllcikge1xuXHRcdF9jb2VyY2VOdW1lcmljUHJvcHMocGFyYW1zKTtcblx0fVxuXG5cdHJldHVybiBsYXllcjtcbn1cblxuLy8gQWRkIGEgakNhbnZhcyBsYXllclxuJC5mbi5hZGRMYXllciA9IGZ1bmN0aW9uIGFkZExheWVyKGFyZ3MpIHtcblx0dmFyICRjYW52YXNlcyA9IHRoaXMsIGUsIGN0eCxcblx0XHRwYXJhbXM7XG5cblx0Zm9yIChlID0gMDsgZSA8ICRjYW52YXNlcy5sZW5ndGg7IGUgKz0gMSkge1xuXHRcdGN0eCA9IF9nZXRDb250ZXh0KCRjYW52YXNlc1tlXSk7XG5cdFx0aWYgKGN0eCkge1xuXG5cdFx0XHRwYXJhbXMgPSBuZXcgakNhbnZhc09iamVjdChhcmdzKTtcblx0XHRcdHBhcmFtcy5sYXllciA9IHRydWU7XG5cdFx0XHRfYWRkTGF5ZXIoJGNhbnZhc2VzW2VdLCBwYXJhbXMsIGFyZ3MpO1xuXG5cdFx0fVxuXHR9XG5cdHJldHVybiAkY2FudmFzZXM7XG59O1xuXG4vKiBBbmltYXRpb24gQVBJICovXG5cbi8vIERlZmluZSBwcm9wZXJ0aWVzIHVzZWQgaW4gYm90aCBDU1MgYW5kIGpDYW52YXNcbmNzcy5wcm9wcyA9IFtcblx0J3dpZHRoJyxcblx0J2hlaWdodCcsXG5cdCdvcGFjaXR5Jyxcblx0J2xpbmVIZWlnaHQnXG5dO1xuY3NzLnByb3BzT2JqID0ge307XG5cbi8vIEhpZGUvc2hvdyBqQ2FudmFzL0NTUyBwcm9wZXJ0aWVzIHNvIHRoZXkgY2FuIGJlIGFuaW1hdGVkIHVzaW5nIGpRdWVyeVxuZnVuY3Rpb24gX3Nob3dQcm9wcyhvYmopIHtcblx0dmFyIGNzc1Byb3AsIHA7XG5cdGZvciAocCA9IDA7IHAgPCBjc3MucHJvcHMubGVuZ3RoOyBwICs9IDEpIHtcblx0XHRjc3NQcm9wID0gY3NzLnByb3BzW3BdO1xuXHRcdG9ialtjc3NQcm9wXSA9IG9ialsnXycgKyBjc3NQcm9wXTtcblx0fVxufVxuZnVuY3Rpb24gX2hpZGVQcm9wcyhvYmosIHJlc2V0KSB7XG5cdHZhciBjc3NQcm9wLCBwO1xuXHRmb3IgKHAgPSAwOyBwIDwgY3NzLnByb3BzLmxlbmd0aDsgcCArPSAxKSB7XG5cdFx0Y3NzUHJvcCA9IGNzcy5wcm9wc1twXTtcblx0XHQvLyBIaWRlIHByb3BlcnR5IHVzaW5nIHNhbWUgbmFtZSB3aXRoIGxlYWRpbmcgdW5kZXJzY29yZVxuXHRcdGlmIChvYmpbY3NzUHJvcF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0b2JqWydfJyArIGNzc1Byb3BdID0gb2JqW2Nzc1Byb3BdO1xuXHRcdFx0Y3NzLnByb3BzT2JqW2Nzc1Byb3BdID0gdHJ1ZTtcblx0XHRcdGlmIChyZXNldCkge1xuXHRcdFx0XHRkZWxldGUgb2JqW2Nzc1Byb3BdO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vLyBFdmFsdWF0ZSBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCBhcmUgZnVuY3Rpb25zXG5mdW5jdGlvbiBfcGFyc2VFbmRWYWx1ZXMoY2FudmFzLCBsYXllciwgZW5kVmFsdWVzKSB7XG5cdHZhciBwcm9wTmFtZSwgcHJvcFZhbHVlLFxuXHRcdHN1YlByb3BOYW1lLCBzdWJQcm9wVmFsdWU7XG5cdC8vIExvb3AgdGhyb3VnaCBhbGwgcHJvcGVydGllcyBpbiBtYXAgb2YgZW5kIHZhbHVlc1xuXHRmb3IgKHByb3BOYW1lIGluIGVuZFZhbHVlcykge1xuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZW5kVmFsdWVzLCBwcm9wTmFtZSkpIHtcblx0XHRcdHByb3BWYWx1ZSA9IGVuZFZhbHVlc1twcm9wTmFtZV07XG5cdFx0XHQvLyBJZiBlbmQgdmFsdWUgaXMgZnVuY3Rpb25cblx0XHRcdGlmIChpc0Z1bmN0aW9uKHByb3BWYWx1ZSkpIHtcblx0XHRcdFx0Ly8gQ2FsbCBmdW5jdGlvbiBhbmQgdXNlIGl0cyB2YWx1ZSBhcyB0aGUgZW5kIHZhbHVlXG5cdFx0XHRcdGVuZFZhbHVlc1twcm9wTmFtZV0gPSBwcm9wVmFsdWUuY2FsbChjYW52YXMsIGxheWVyLCBwcm9wTmFtZSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiBlbmQgdmFsdWUgaXMgYW4gb2JqZWN0XG5cdFx0XHRpZiAodHlwZU9mKHByb3BWYWx1ZSkgPT09ICdvYmplY3QnICYmIGlzUGxhaW5PYmplY3QocHJvcFZhbHVlKSkge1xuXHRcdFx0XHQvLyBQcmVwYXJlIHRvIGFuaW1hdGUgcHJvcGVydGllcyBpbiBvYmplY3Rcblx0XHRcdFx0Zm9yIChzdWJQcm9wTmFtZSBpbiBwcm9wVmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BWYWx1ZSwgc3ViUHJvcE5hbWUpKSB7XG5cdFx0XHRcdFx0XHRzdWJQcm9wVmFsdWUgPSBwcm9wVmFsdWVbc3ViUHJvcE5hbWVdO1xuXHRcdFx0XHRcdFx0Ly8gU3RvcmUgcHJvcGVydHkncyBzdGFydCB2YWx1ZSBhdCB0b3AtbGV2ZWwgb2YgbGF5ZXJcblx0XHRcdFx0XHRcdGlmIChsYXllcltwcm9wTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRsYXllcltwcm9wTmFtZSArICcuJyArIHN1YlByb3BOYW1lXSA9IGxheWVyW3Byb3BOYW1lXVtzdWJQcm9wTmFtZV07XG5cdFx0XHRcdFx0XHRcdC8vIFN0b3JlIHByb3BlcnR5J3MgZW5kIHZhbHVlIGF0IHRvcC1sZXZlbCBvZiBlbmQgdmFsdWVzIG1hcFxuXHRcdFx0XHRcdFx0XHRlbmRWYWx1ZXNbcHJvcE5hbWUgKyAnLicgKyBzdWJQcm9wTmFtZV0gPSBzdWJQcm9wVmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIERlbGV0ZSBzdWItcHJvcGVydHkgb2Ygb2JqZWN0IGFzIGl0J3Mgbm8gbG9uZ2VyIG5lZWRlZFxuXHRcdFx0XHRkZWxldGUgZW5kVmFsdWVzW3Byb3BOYW1lXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGVuZFZhbHVlcztcbn1cblxuLy8gUmVtb3ZlIHN1Yi1wcm9wZXJ0eSBhbGlhc2VzIGZyb20gbGF5ZXIgb2JqZWN0XG5mdW5jdGlvbiBfcmVtb3ZlU3ViUHJvcEFsaWFzZXMobGF5ZXIpIHtcblx0dmFyIHByb3BOYW1lO1xuXHRmb3IgKHByb3BOYW1lIGluIGxheWVyKSB7XG5cdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsYXllciwgcHJvcE5hbWUpKSB7XG5cdFx0XHRpZiAocHJvcE5hbWUuaW5kZXhPZignLicpICE9PSAtMSkge1xuXHRcdFx0XHRkZWxldGUgbGF5ZXJbcHJvcE5hbWVdO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vLyBDb252ZXJ0IGEgY29sb3IgdmFsdWUgdG8gYW4gYXJyYXkgb2YgUkdCIHZhbHVlc1xuZnVuY3Rpb24gX2NvbG9yVG9SZ2JBcnJheShjb2xvcikge1xuXHR2YXIgb3JpZ2luYWxDb2xvciwgZWxlbSxcblx0XHRyZ2IgPSBbXSxcblx0XHRtdWx0aXBsZSA9IDE7XG5cblx0Ly8gRGVhbCB3aXRoIGNvbXBsZXRlIHRyYW5zcGFyZW5jeVxuXHRpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHtcblx0XHRjb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDApJztcblx0fSBlbHNlIGlmIChjb2xvci5tYXRjaCgvXihbYS16XSt8I1swLTlhLWZdKykkL2dpKSkge1xuXHRcdC8vIERlYWwgd2l0aCBoZXhhZGVjaW1hbCBjb2xvcnMgYW5kIGNvbG9yIG5hbWVzXG5cdFx0ZWxlbSA9IGRvY3VtZW50LmhlYWQ7XG5cdFx0b3JpZ2luYWxDb2xvciA9IGVsZW0uc3R5bGUuY29sb3I7XG5cdFx0ZWxlbS5zdHlsZS5jb2xvciA9IGNvbG9yO1xuXHRcdGNvbG9yID0gJC5jc3MoZWxlbSwgJ2NvbG9yJyk7XG5cdFx0ZWxlbS5zdHlsZS5jb2xvciA9IG9yaWdpbmFsQ29sb3I7XG5cdH1cblx0Ly8gUGFyc2UgUkdCIHN0cmluZ1xuXHRpZiAoY29sb3IubWF0Y2goL15yZ2IvZ2kpKSB7XG5cdFx0cmdiID0gY29sb3IubWF0Y2goLyhcXGQrKFxcLlxcZCspPykvZ2kpO1xuXHRcdC8vIERlYWwgd2l0aCBSR0IgcGVyY2VudGFnZXNcblx0XHRpZiAoY29sb3IubWF0Y2goLyUvZ2kpKSB7XG5cdFx0XHRtdWx0aXBsZSA9IDIuNTU7XG5cdFx0fVxuXHRcdHJnYlswXSAqPSBtdWx0aXBsZTtcblx0XHRyZ2JbMV0gKj0gbXVsdGlwbGU7XG5cdFx0cmdiWzJdICo9IG11bHRpcGxlO1xuXHRcdC8vIEFkIGFscGhhIGNoYW5uZWwgaWYgZ2l2ZW5cblx0XHRpZiAocmdiWzNdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJnYlszXSA9IHBhcnNlRmxvYXQocmdiWzNdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmdiWzNdID0gMTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJnYjtcbn1cblxuLy8gQW5pbWF0ZSBhIGhleCBvciBSR0IgY29sb3JcbmZ1bmN0aW9uIF9hbmltYXRlQ29sb3IoZngpIHtcblx0dmFyIG4gPSAzLFxuXHRcdGk7XG5cdC8vIE9ubHkgcGFyc2Ugc3RhcnQgYW5kIGVuZCBjb2xvcnMgb25jZVxuXHRpZiAodHlwZU9mKGZ4LnN0YXJ0KSAhPT0gJ2FycmF5Jykge1xuXHRcdGZ4LnN0YXJ0ID0gX2NvbG9yVG9SZ2JBcnJheShmeC5zdGFydCk7XG5cdFx0ZnguZW5kID0gX2NvbG9yVG9SZ2JBcnJheShmeC5lbmQpO1xuXHR9XG5cdGZ4Lm5vdyA9IFtdO1xuXG5cdC8vIElmIGNvbG9ycyBhcmUgUkdCQSwgYW5pbWF0ZSB0cmFuc3BhcmVuY3lcblx0aWYgKGZ4LnN0YXJ0WzNdICE9PSAxIHx8IGZ4LmVuZFszXSAhPT0gMSkge1xuXHRcdG4gPSA0O1xuXHR9XG5cblx0Ly8gQ2FsY3VsYXRlIGN1cnJlbnQgZnJhbWUgZm9yIHJlZCwgZ3JlZW4sIGJsdWUsIGFuZCBhbHBoYVxuXHRmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSAxKSB7XG5cdFx0Zngubm93W2ldID0gZnguc3RhcnRbaV0gKyAoKGZ4LmVuZFtpXSAtIGZ4LnN0YXJ0W2ldKSAqIGZ4LnBvcyk7XG5cdFx0Ly8gT25seSB0aGUgcmVkLCBncmVlbiwgYW5kIGJsdWUgdmFsdWVzIG11c3QgYmUgaW50ZWdlcnNcblx0XHRpZiAoaSA8IDMpIHtcblx0XHRcdGZ4Lm5vd1tpXSA9IHJvdW5kKGZ4Lm5vd1tpXSk7XG5cdFx0fVxuXHR9XG5cdGlmIChmeC5zdGFydFszXSAhPT0gMSB8fCBmeC5lbmRbM10gIT09IDEpIHtcblx0XHQvLyBPbmx5IHVzZSBSR0JBIGlmIFJHQkEgY29sb3JzIGFyZSBnaXZlblxuXHRcdGZ4Lm5vdyA9ICdyZ2JhKCcgKyBmeC5ub3cuam9pbignLCcpICsgJyknO1xuXHR9IGVsc2Uge1xuXHRcdC8vIE90aGVyd2lzZSwgYW5pbWF0ZSBhcyBzb2xpZCBjb2xvcnNcblx0XHRmeC5ub3cuc2xpY2UoMCwgMyk7XG5cdFx0Zngubm93ID0gJ3JnYignICsgZngubm93LmpvaW4oJywnKSArICcpJztcblx0fVxuXHQvLyBBbmltYXRlIGNvbG9ycyBmb3IgYm90aCBjYW52YXMgbGF5ZXJzIGFuZCBET00gZWxlbWVudHNcblx0aWYgKGZ4LmVsZW0ubm9kZU5hbWUpIHtcblx0XHRmeC5lbGVtLnN0eWxlW2Z4LnByb3BdID0gZngubm93O1xuXHR9IGVsc2Uge1xuXHRcdGZ4LmVsZW1bZngucHJvcF0gPSBmeC5ub3c7XG5cdH1cbn1cblxuLy8gQW5pbWF0ZSBqQ2FudmFzIGxheWVyXG4kLmZuLmFuaW1hdGVMYXllciA9IGZ1bmN0aW9uIGFuaW1hdGVMYXllcigpIHtcblx0dmFyICRjYW52YXNlcyA9IHRoaXMsICRjYW52YXMsIGUsIGN0eCxcblx0XHRhcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXG5cdFx0ZGF0YSwgbGF5ZXIsIHByb3BzO1xuXG5cdC8vIERlYWwgd2l0aCBhbGwgY2FzZXMgb2YgYXJndW1lbnQgcGxhY2VtZW50XG5cdC8qXG5cdFx0MC4gbGF5ZXIgbmFtZS9pbmRleFxuXHRcdDEuIHByb3BlcnRpZXNcblx0XHQyLiBkdXJhdGlvbi9vcHRpb25zXG5cdFx0My4gZWFzaW5nXG5cdFx0NC4gY29tcGxldGUgZnVuY3Rpb25cblx0XHQ1LiBzdGVwIGZ1bmN0aW9uXG5cdCovXG5cblx0aWYgKHR5cGVPZihhcmdzWzJdKSA9PT0gJ29iamVjdCcpIHtcblxuXHRcdC8vIEFjY2VwdCBhbiBvcHRpb25zIG9iamVjdCBmb3IgYW5pbWF0aW9uXG5cdFx0YXJncy5zcGxpY2UoMiwgMCwgYXJnc1syXS5kdXJhdGlvbiB8fCBudWxsKTtcblx0XHRhcmdzLnNwbGljZSgzLCAwLCBhcmdzWzNdLmVhc2luZyB8fCBudWxsKTtcblx0XHRhcmdzLnNwbGljZSg0LCAwLCBhcmdzWzRdLmNvbXBsZXRlIHx8IG51bGwpO1xuXHRcdGFyZ3Muc3BsaWNlKDUsIDAsIGFyZ3NbNV0uc3RlcCB8fCBudWxsKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0aWYgKGFyZ3NbMl0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gSWYgb2JqZWN0IGlzIHRoZSBsYXN0IGFyZ3VtZW50XG5cdFx0XHRhcmdzLnNwbGljZSgyLCAwLCBudWxsKTtcblx0XHRcdGFyZ3Muc3BsaWNlKDMsIDAsIG51bGwpO1xuXHRcdFx0YXJncy5zcGxpY2UoNCwgMCwgbnVsbCk7XG5cdFx0fSBlbHNlIGlmIChpc0Z1bmN0aW9uKGFyZ3NbMl0pKSB7XG5cdFx0XHQvLyBJZiBjYWxsYmFjayBjb21lcyBhZnRlciBvYmplY3Rcblx0XHRcdGFyZ3Muc3BsaWNlKDIsIDAsIG51bGwpO1xuXHRcdFx0YXJncy5zcGxpY2UoMywgMCwgbnVsbCk7XG5cdFx0fVxuXHRcdGlmIChhcmdzWzNdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIElmIGR1cmF0aW9uIGlzIHRoZSBsYXN0IGFyZ3VtZW50XG5cdFx0XHRhcmdzWzNdID0gbnVsbDtcblx0XHRcdGFyZ3Muc3BsaWNlKDQsIDAsIG51bGwpO1xuXHRcdH0gZWxzZSBpZiAoaXNGdW5jdGlvbihhcmdzWzNdKSkge1xuXHRcdFx0Ly8gSWYgY2FsbGJhY2sgY29tZXMgYWZ0ZXIgZHVyYXRpb25cblx0XHRcdGFyZ3Muc3BsaWNlKDMsIDAsIG51bGwpO1xuXHRcdH1cblxuXHR9XG5cblx0Ly8gUnVuIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gYW5pbWF0aW9uIGNvbXBsZXRlc1xuXHRmdW5jdGlvbiBjb21wbGV0ZSgkY2FudmFzLCBkYXRhLCBsYXllcikge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0X3Nob3dQcm9wcyhsYXllcik7XG5cdFx0XHRfcmVtb3ZlU3ViUHJvcEFsaWFzZXMobGF5ZXIpO1xuXG5cdFx0XHQvLyBQcmV2ZW50IG11bHRpcGxlIHJlZHJhdyBsb29wc1xuXHRcdFx0aWYgKCFkYXRhLmFuaW1hdGluZyB8fCBkYXRhLmFuaW1hdGVkID09PSBsYXllcikge1xuXHRcdFx0XHQvLyBSZWRyYXcgbGF5ZXJzIG9uIGxhc3QgZnJhbWVcblx0XHRcdFx0JGNhbnZhcy5kcmF3TGF5ZXJzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNpZ25pZnkgdGhlIGVuZCBvZiBhbiBhbmltYXRpb24gbG9vcFxuXHRcdFx0bGF5ZXIuX2FuaW1hdGluZyA9IGZhbHNlO1xuXHRcdFx0ZGF0YS5hbmltYXRpbmcgPSBmYWxzZTtcblx0XHRcdGRhdGEuYW5pbWF0ZWQgPSBudWxsO1xuXG5cdFx0XHQvLyBJZiBjYWxsYmFjayBpcyBkZWZpbmVkXG5cdFx0XHRpZiAoYXJnc1s0XSkge1xuXHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYXQgdGhlIGVuZCBvZiB0aGUgYW5pbWF0aW9uXG5cdFx0XHRcdGFyZ3NbNF0uY2FsbCgkY2FudmFzWzBdLCBsYXllcik7XG5cdFx0XHR9XG5cblx0XHRcdF90cmlnZ2VyTGF5ZXJFdmVudCgkY2FudmFzLCBkYXRhLCBsYXllciwgJ2FuaW1hdGVlbmQnKTtcblxuXHRcdH07XG5cblx0fVxuXG5cdC8vIFJlZHJhdyBsYXllcnMgb24gZXZlcnkgZnJhbWUgb2YgdGhlIGFuaW1hdGlvblxuXHRmdW5jdGlvbiBzdGVwKCRjYW52YXMsIGRhdGEsIGxheWVyKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKG5vdywgZngpIHtcblx0XHRcdHZhciBwYXJ0cywgcHJvcE5hbWUsIHN1YlByb3BOYW1lLFxuXHRcdFx0XHRoaWRkZW4gPSBmYWxzZTtcblxuXHRcdFx0Ly8gSWYgYW5pbWF0ZWQgcHJvcGVydHkgaGFzIGJlZW4gaGlkZGVuXG5cdFx0XHRpZiAoZngucHJvcFswXSA9PT0gJ18nKSB7XG5cdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cdFx0XHRcdC8vIFVuaGlkZSBwcm9wZXJ0eSB0ZW1wb3JhcmlseVxuXHRcdFx0XHRmeC5wcm9wID0gZngucHJvcC5yZXBsYWNlKCdfJywgJycpO1xuXHRcdFx0XHRsYXllcltmeC5wcm9wXSA9IGxheWVyWydfJyArIGZ4LnByb3BdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhbmltYXRpbmcgcHJvcGVydHkgb2Ygc3ViLW9iamVjdFxuXHRcdFx0aWYgKGZ4LnByb3AuaW5kZXhPZignLicpICE9PSAtMSkge1xuXHRcdFx0XHRwYXJ0cyA9IGZ4LnByb3Auc3BsaXQoJy4nKTtcblx0XHRcdFx0cHJvcE5hbWUgPSBwYXJ0c1swXTtcblx0XHRcdFx0c3ViUHJvcE5hbWUgPSBwYXJ0c1sxXTtcblx0XHRcdFx0aWYgKGxheWVyW3Byb3BOYW1lXSkge1xuXHRcdFx0XHRcdGxheWVyW3Byb3BOYW1lXVtzdWJQcm9wTmFtZV0gPSBmeC5ub3c7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhyb3R0bGUgYW5pbWF0aW9uIHRvIGltcHJvdmUgZWZmaWNpZW5jeVxuXHRcdFx0aWYgKGxheWVyLl9wb3MgIT09IGZ4LnBvcykge1xuXG5cdFx0XHRcdGxheWVyLl9wb3MgPSBmeC5wb3M7XG5cblx0XHRcdFx0Ly8gU2lnbmlmeSB0aGUgc3RhcnQgb2YgYW4gYW5pbWF0aW9uIGxvb3Bcblx0XHRcdFx0aWYgKCFsYXllci5fYW5pbWF0aW5nICYmICFkYXRhLmFuaW1hdGluZykge1xuXHRcdFx0XHRcdGxheWVyLl9hbmltYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdGRhdGEuYW5pbWF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRkYXRhLmFuaW1hdGVkID0gbGF5ZXI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcmV2ZW50IG11bHRpcGxlIHJlZHJhdyBsb29wc1xuXHRcdFx0XHRpZiAoIWRhdGEuYW5pbWF0aW5nIHx8IGRhdGEuYW5pbWF0ZWQgPT09IGxheWVyKSB7XG5cdFx0XHRcdFx0Ly8gUmVkcmF3IGxheWVycyBmb3IgZXZlcnkgZnJhbWVcblx0XHRcdFx0XHQkY2FudmFzLmRyYXdMYXllcnMoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGNhbGxiYWNrIGlzIGRlZmluZWRcblx0XHRcdGlmIChhcmdzWzVdKSB7XG5cdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBmb3IgZWFjaCBzdGVwIG9mIGFuaW1hdGlvblxuXHRcdFx0XHRhcmdzWzVdLmNhbGwoJGNhbnZhc1swXSwgbm93LCBmeCwgbGF5ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRfdHJpZ2dlckxheWVyRXZlbnQoJGNhbnZhcywgZGF0YSwgbGF5ZXIsICdhbmltYXRlJywgZngpO1xuXG5cdFx0XHQvLyBJZiBwcm9wZXJ0eSBzaG91bGQgYmUgaGlkZGVuIGR1cmluZyBhbmltYXRpb25cblx0XHRcdGlmIChoaWRkZW4pIHtcblx0XHRcdFx0Ly8gSGlkZSBwcm9wZXJ0eSBhZ2FpblxuXHRcdFx0XHRmeC5wcm9wID0gJ18nICsgZngucHJvcDtcblx0XHRcdH1cblxuXHRcdH07XG5cblx0fVxuXG5cdGZvciAoZSA9IDA7IGUgPCAkY2FudmFzZXMubGVuZ3RoOyBlICs9IDEpIHtcblx0XHQkY2FudmFzID0gJCgkY2FudmFzZXNbZV0pO1xuXHRcdGN0eCA9IF9nZXRDb250ZXh0KCRjYW52YXNlc1tlXSk7XG5cdFx0aWYgKGN0eCkge1xuXG5cdFx0XHRkYXRhID0gX2dldENhbnZhc0RhdGEoJGNhbnZhc2VzW2VdKTtcblxuXHRcdFx0Ly8gSWYgYSBsYXllciBvYmplY3Qgd2FzIHBhc3NlZCwgdXNlIGl0IHRoZSBsYXllciB0byBiZSBhbmltYXRlZFxuXHRcdFx0bGF5ZXIgPSAkY2FudmFzLmdldExheWVyKGFyZ3NbMF0pO1xuXG5cdFx0XHQvLyBJZ25vcmUgbGF5ZXJzIHRoYXQgYXJlIGZ1bmN0aW9uc1xuXHRcdFx0aWYgKGxheWVyICYmIGxheWVyLl9tZXRob2QgIT09ICQuZm4uZHJhdykge1xuXG5cdFx0XHRcdC8vIERvIG5vdCBtb2RpZnkgb3JpZ2luYWwgb2JqZWN0XG5cdFx0XHRcdHByb3BzID0gZXh0ZW5kT2JqZWN0KHt9LCBhcmdzWzFdKTtcblxuXHRcdFx0XHRwcm9wcyA9IF9wYXJzZUVuZFZhbHVlcygkY2FudmFzZXNbZV0sIGxheWVyLCBwcm9wcyk7XG5cblx0XHRcdFx0Ly8gQnlwYXNzIGpRdWVyeSBDU1MgSG9va3MgZm9yIENTUyBwcm9wZXJ0aWVzICh3aWR0aCwgb3BhY2l0eSwgZXRjLilcblx0XHRcdFx0X2hpZGVQcm9wcyhwcm9wcywgdHJ1ZSk7XG5cdFx0XHRcdF9oaWRlUHJvcHMobGF5ZXIpO1xuXG5cdFx0XHRcdC8vIEZpeCBmb3IgalF1ZXJ5J3MgdmVuZG9yIHByZWZpeGluZyBzdXBwb3J0LCB3aGljaCBhZmZlY3RzIGhvdyB3aWR0aC9oZWlnaHQvb3BhY2l0eSBhcmUgYW5pbWF0ZWRcblx0XHRcdFx0bGF5ZXIuc3R5bGUgPSBjc3MucHJvcHNPYmo7XG5cblx0XHRcdFx0Ly8gQW5pbWF0ZSBsYXllclxuXHRcdFx0XHQkKGxheWVyKS5hbmltYXRlKHByb3BzLCB7XG5cdFx0XHRcdFx0ZHVyYXRpb246IGFyZ3NbMl0sXG5cdFx0XHRcdFx0ZWFzaW5nOiAoJC5lYXNpbmdbYXJnc1szXV0gPyBhcmdzWzNdIDogbnVsbCksXG5cdFx0XHRcdFx0Ly8gV2hlbiBhbmltYXRpb24gY29tcGxldGVzXG5cdFx0XHRcdFx0Y29tcGxldGU6IGNvbXBsZXRlKCRjYW52YXMsIGRhdGEsIGxheWVyKSxcblx0XHRcdFx0XHQvLyBSZWRyYXcgY2FudmFzIGZvciBldmVyeSBhbmltYXRpb24gZnJhbWVcblx0XHRcdFx0XHRzdGVwOiBzdGVwKCRjYW52YXMsIGRhdGEsIGxheWVyKVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0X3RyaWdnZXJMYXllckV2ZW50KCRjYW52YXMsIGRhdGEsIGxheWVyLCAnYW5pbWF0ZXN0YXJ0Jyk7XG5cdFx0XHR9XG5cblx0XHR9XG5cdH1cblx0cmV0dXJuICRjYW52YXNlcztcbn07XG5cbi8vIEFuaW1hdGUgYWxsIGxheWVycyBpbiBhIGxheWVyIGdyb3VwXG4kLmZuLmFuaW1hdGVMYXllckdyb3VwID0gZnVuY3Rpb24gYW5pbWF0ZUxheWVyR3JvdXAoZ3JvdXBJZCkge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgJGNhbnZhcywgZSxcblx0XHRhcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXG5cdFx0Z3JvdXAsIGw7XG5cdGZvciAoZSA9IDA7IGUgPCAkY2FudmFzZXMubGVuZ3RoOyBlICs9IDEpIHtcblx0XHQkY2FudmFzID0gJCgkY2FudmFzZXNbZV0pO1xuXHRcdGdyb3VwID0gJGNhbnZhcy5nZXRMYXllckdyb3VwKGdyb3VwSWQpO1xuXHRcdGlmIChncm91cCkge1xuXG5cdFx0XHQvLyBBbmltYXRlIGFsbCBsYXllcnMgaW4gdGhlIGdyb3VwXG5cdFx0XHRmb3IgKGwgPSAwOyBsIDwgZ3JvdXAubGVuZ3RoOyBsICs9IDEpIHtcblxuXHRcdFx0XHQvLyBSZXBsYWNlIGZpcnN0IGFyZ3VtZW50IHdpdGggbGF5ZXJcblx0XHRcdFx0YXJnc1swXSA9IGdyb3VwW2xdO1xuXHRcdFx0XHQkY2FudmFzLmFuaW1hdGVMYXllci5hcHBseSgkY2FudmFzLCBhcmdzKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXHR9XG5cdHJldHVybiAkY2FudmFzZXM7XG59O1xuXG4vLyBEZWxheSBsYXllciBhbmltYXRpb24gYnkgYSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4kLmZuLmRlbGF5TGF5ZXIgPSBmdW5jdGlvbiBkZWxheUxheWVyKGxheWVySWQsIGR1cmF0aW9uKSB7XG5cdHZhciAkY2FudmFzZXMgPSB0aGlzLCAkY2FudmFzLCBlLFxuXHRcdGRhdGEsIGxheWVyO1xuXHRkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDA7XG5cblx0Zm9yIChlID0gMDsgZSA8ICRjYW52YXNlcy5sZW5ndGg7IGUgKz0gMSkge1xuXHRcdCRjYW52YXMgPSAkKCRjYW52YXNlc1tlXSk7XG5cdFx0ZGF0YSA9IF9nZXRDYW52YXNEYXRhKCRjYW52YXNlc1tlXSk7XG5cdFx0bGF5ZXIgPSAkY2FudmFzLmdldExheWVyKGxheWVySWQpO1xuXHRcdC8vIElmIGxheWVyIGV4aXN0c1xuXHRcdGlmIChsYXllcikge1xuXHRcdFx0Ly8gRGVsYXkgYW5pbWF0aW9uXG5cdFx0XHQkKGxheWVyKS5kZWxheShkdXJhdGlvbik7XG5cdFx0XHRfdHJpZ2dlckxheWVyRXZlbnQoJGNhbnZhcywgZGF0YSwgbGF5ZXIsICdkZWxheScpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gJGNhbnZhc2VzO1xufTtcblxuLy8gRGVsYXkgYW5pbWF0aW9uIGFsbCBsYXllcnMgaW4gYSBsYXllciBncm91cFxuJC5mbi5kZWxheUxheWVyR3JvdXAgPSBmdW5jdGlvbiBkZWxheUxheWVyR3JvdXAoZ3JvdXBJZCwgZHVyYXRpb24pIHtcblx0dmFyICRjYW52YXNlcyA9IHRoaXMsICRjYW52YXMsIGUsXG5cdFx0Z3JvdXAsIGxheWVyLCBsO1xuXHRkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDA7XG5cblx0Zm9yIChlID0gMDsgZSA8ICRjYW52YXNlcy5sZW5ndGg7IGUgKz0gMSkge1xuXHRcdCRjYW52YXMgPSAkKCRjYW52YXNlc1tlXSk7XG5cblx0XHRncm91cCA9ICRjYW52YXMuZ2V0TGF5ZXJHcm91cChncm91cElkKTtcblx0XHQvLyBEZWxheSBhbGwgbGF5ZXJzIGluIHRoZSBncm91cFxuXHRcdGlmIChncm91cCkge1xuXG5cdFx0XHRmb3IgKGwgPSAwOyBsIDwgZ3JvdXAubGVuZ3RoOyBsICs9IDEpIHtcblx0XHRcdFx0Ly8gRGVsYXkgZWFjaCBsYXllciBpbiB0aGUgZ3JvdXBcblx0XHRcdFx0bGF5ZXIgPSBncm91cFtsXTtcblx0XHRcdFx0JGNhbnZhcy5kZWxheUxheWVyKGxheWVyLCBkdXJhdGlvbik7XG5cdFx0XHR9XG5cblx0XHR9XG5cdH1cblx0cmV0dXJuICRjYW52YXNlcztcbn07XG5cbi8vIFN0b3AgbGF5ZXIgYW5pbWF0aW9uXG4kLmZuLnN0b3BMYXllciA9IGZ1bmN0aW9uIHN0b3BMYXllcihsYXllcklkLCBjbGVhclF1ZXVlKSB7XG5cdHZhciAkY2FudmFzZXMgPSB0aGlzLCAkY2FudmFzLCBlLFxuXHRcdGRhdGEsIGxheWVyO1xuXG5cdGZvciAoZSA9IDA7IGUgPCAkY2FudmFzZXMubGVuZ3RoOyBlICs9IDEpIHtcblx0XHQkY2FudmFzID0gJCgkY2FudmFzZXNbZV0pO1xuXHRcdGRhdGEgPSBfZ2V0Q2FudmFzRGF0YSgkY2FudmFzZXNbZV0pO1xuXHRcdGxheWVyID0gJGNhbnZhcy5nZXRMYXllcihsYXllcklkKTtcblx0XHQvLyBJZiBsYXllciBleGlzdHNcblx0XHRpZiAobGF5ZXIpIHtcblx0XHRcdC8vIFN0b3AgYW5pbWF0aW9uXG5cdFx0XHQkKGxheWVyKS5zdG9wKGNsZWFyUXVldWUpO1xuXHRcdFx0X3RyaWdnZXJMYXllckV2ZW50KCRjYW52YXMsIGRhdGEsIGxheWVyLCAnc3RvcCcpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gJGNhbnZhc2VzO1xufTtcblxuLy8gU3RvcCBhbmltYXRpb24gb2YgYWxsIGxheWVycyBpbiBhIGxheWVyIGdyb3VwXG4kLmZuLnN0b3BMYXllckdyb3VwID0gZnVuY3Rpb24gc3RvcExheWVyR3JvdXAoZ3JvdXBJZCwgY2xlYXJRdWV1ZSkge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgJGNhbnZhcywgZSxcblx0XHRncm91cCwgbGF5ZXIsIGw7XG5cblx0Zm9yIChlID0gMDsgZSA8ICRjYW52YXNlcy5sZW5ndGg7IGUgKz0gMSkge1xuXHRcdCRjYW52YXMgPSAkKCRjYW52YXNlc1tlXSk7XG5cblx0XHRncm91cCA9ICRjYW52YXMuZ2V0TGF5ZXJHcm91cChncm91cElkKTtcblx0XHQvLyBTdG9wIGFsbCBsYXllcnMgaW4gdGhlIGdyb3VwXG5cdFx0aWYgKGdyb3VwKSB7XG5cblx0XHRcdGZvciAobCA9IDA7IGwgPCBncm91cC5sZW5ndGg7IGwgKz0gMSkge1xuXHRcdFx0XHQvLyBTdG9wIGVhY2ggbGF5ZXIgaW4gdGhlIGdyb3VwXG5cdFx0XHRcdGxheWVyID0gZ3JvdXBbbF07XG5cdFx0XHRcdCRjYW52YXMuc3RvcExheWVyKGxheWVyLCBjbGVhclF1ZXVlKTtcblx0XHRcdH1cblxuXHRcdH1cblx0fVxuXHRyZXR1cm4gJGNhbnZhc2VzO1xufTtcblxuLy8gRW5hYmxlIGFuaW1hdGlvbiBmb3IgY29sb3IgcHJvcGVydGllc1xuZnVuY3Rpb24gX3N1cHBvcnRDb2xvclByb3BzKHByb3BzKSB7XG5cdHZhciBwO1xuXHRmb3IgKHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwICs9IDEpIHtcblx0XHQkLmZ4LnN0ZXBbcHJvcHNbcF1dID0gX2FuaW1hdGVDb2xvcjtcblx0fVxufVxuXG4vLyBFbmFibGUgYW5pbWF0aW9uIGZvciBjb2xvciBwcm9wZXJ0aWVzXG5fc3VwcG9ydENvbG9yUHJvcHMoW1xuXHQnY29sb3InLFxuXHQnYmFja2dyb3VuZENvbG9yJyxcblx0J2JvcmRlckNvbG9yJyxcblx0J2JvcmRlclRvcENvbG9yJyxcblx0J2JvcmRlclJpZ2h0Q29sb3InLFxuXHQnYm9yZGVyQm90dG9tQ29sb3InLFxuXHQnYm9yZGVyTGVmdENvbG9yJyxcblx0J2ZpbGxTdHlsZScsXG5cdCdvdXRsaW5lQ29sb3InLFxuXHQnc3Ryb2tlU3R5bGUnLFxuXHQnc2hhZG93Q29sb3InXG5dKTtcblxuLyogRXZlbnQgQVBJICovXG5cbi8vIE1hcCBzdGFuZGFyZCBtb3VzZSBldmVudHMgdG8gdG91Y2ggZXZlbnRzXG5tYXBzLnRvdWNoRXZlbnRzID0ge1xuXHQnbW91c2Vkb3duJzogJ3RvdWNoc3RhcnQnLFxuXHQnbW91c2V1cCc6ICd0b3VjaGVuZCcsXG5cdCdtb3VzZW1vdmUnOiAndG91Y2htb3ZlJ1xufTtcbi8vIE1hcCBzdGFuZGFyZCB0b3VjaCBldmVudHMgdG8gbW91c2UgZXZlbnRzXG5tYXBzLm1vdXNlRXZlbnRzID0ge1xuXHQndG91Y2hzdGFydCc6ICdtb3VzZWRvd24nLFxuXHQndG91Y2hlbmQnOiAnbW91c2V1cCcsXG5cdCd0b3VjaG1vdmUnOiAnbW91c2Vtb3ZlJ1xufTtcblxuLy8gQ29udmVydCBtb3VzZSBldmVudCBuYW1lIHRvIGEgY29ycmVzcG9uZGluZyB0b3VjaCBldmVudCBuYW1lIChpZiBwb3NzaWJsZSlcbmZ1bmN0aW9uIF9nZXRUb3VjaEV2ZW50TmFtZShldmVudE5hbWUpIHtcblx0Ly8gRGV0ZWN0IHRvdWNoIGV2ZW50IHN1cHBvcnRcblx0aWYgKG1hcHMudG91Y2hFdmVudHNbZXZlbnROYW1lXSkge1xuXHRcdGV2ZW50TmFtZSA9IG1hcHMudG91Y2hFdmVudHNbZXZlbnROYW1lXTtcblx0fVxuXHRyZXR1cm4gZXZlbnROYW1lO1xufVxuLy8gQ29udmVydCB0b3VjaCBldmVudCBuYW1lIHRvIGEgY29ycmVzcG9uZGluZyBtb3VzZSBldmVudCBuYW1lXG5mdW5jdGlvbiBfZ2V0TW91c2VFdmVudE5hbWUoZXZlbnROYW1lKSB7XG5cdGlmIChtYXBzLm1vdXNlRXZlbnRzW2V2ZW50TmFtZV0pIHtcblx0XHRldmVudE5hbWUgPSBtYXBzLm1vdXNlRXZlbnRzW2V2ZW50TmFtZV07XG5cdH1cblx0cmV0dXJuIGV2ZW50TmFtZTtcbn1cblxuLy8gQmluZCBldmVudCB0byBqQ2FudmFzIGxheWVyIHVzaW5nIHN0YW5kYXJkIGpRdWVyeSBldmVudHNcbmZ1bmN0aW9uIF9jcmVhdGVFdmVudChldmVudE5hbWUpIHtcblxuXHRqQ2FudmFzLmV2ZW50c1tldmVudE5hbWVdID0gZnVuY3Rpb24gKCRjYW52YXMsIGRhdGEpIHtcblx0XHR2YXIgaGVscGVyRXZlbnROYW1lLCB0b3VjaEV2ZW50TmFtZSwgZXZlbnRDYWNoZTtcblxuXHRcdC8vIFJldHJpZXZlIGNhbnZhcydzIGV2ZW50IGNhY2hlXG5cdFx0ZXZlbnRDYWNoZSA9IGRhdGEuZXZlbnQ7XG5cblx0XHQvLyBCb3RoIG1vdXNlb3Zlci9tb3VzZW91dCBldmVudHMgd2lsbCBiZSBtYW5hZ2VkIGJ5IGEgc2luZ2xlIG1vdXNlbW92ZSBldmVudFxuXHRcdGhlbHBlckV2ZW50TmFtZSA9IChldmVudE5hbWUgPT09ICdtb3VzZW92ZXInIHx8IGV2ZW50TmFtZSA9PT0gJ21vdXNlb3V0JykgPyAnbW91c2Vtb3ZlJyA6IGV2ZW50TmFtZTtcblx0XHR0b3VjaEV2ZW50TmFtZSA9IF9nZXRUb3VjaEV2ZW50TmFtZShoZWxwZXJFdmVudE5hbWUpO1xuXG5cdFx0ZnVuY3Rpb24gZXZlbnRDYWxsYmFjayhldmVudCkge1xuXHRcdFx0Ly8gQ2FjaGUgY3VycmVudCBtb3VzZSBwb3NpdGlvbiBhbmQgcmVkcmF3IGxheWVyc1xuXHRcdFx0ZXZlbnRDYWNoZS54ID0gZXZlbnQub2Zmc2V0WDtcblx0XHRcdGV2ZW50Q2FjaGUueSA9IGV2ZW50Lm9mZnNldFk7XG5cdFx0XHRldmVudENhY2hlLnR5cGUgPSBoZWxwZXJFdmVudE5hbWU7XG5cdFx0XHRldmVudENhY2hlLmV2ZW50ID0gZXZlbnQ7XG5cdFx0XHQvLyBSZWRyYXcgbGF5ZXJzIG9uIGV2ZXJ5IHRyaWdnZXIgb2YgdGhlIGV2ZW50OyBkb24ndCByZWRyYXcgaWYgYXRcblx0XHRcdC8vIGxlYXN0IG9uZSBsYXllciBpcyBkcmFnZ2FibGUgYW5kIHRoZXJlIGFyZSBubyBsYXllcnMgd2l0aFxuXHRcdFx0Ly8gZXhwbGljaXQgbW91c2VvdmVyL21vdXNlb3V0L21vdXNlbW92ZSBldmVudHNcblx0XHRcdGlmIChldmVudC50eXBlICE9PSAnbW91c2Vtb3ZlJyB8fCBkYXRhLnJlZHJhd09uTW91c2Vtb3ZlIHx8IGRhdGEuZHJhZy5kcmFnZ2luZykge1xuXHRcdFx0XHQkY2FudmFzLmRyYXdMYXllcnMoe1xuXHRcdFx0XHRcdHJlc2V0RmlyZTogdHJ1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdC8vIFByZXZlbnQgZGVmYXVsdCBldmVudCBiZWhhdmlvclxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhlIGV2ZW50IGlzIG5vdCBib3VuZCBtb3JlIHRoYW4gb25jZVxuXHRcdGlmICghZGF0YS5ldmVudHNbaGVscGVyRXZlbnROYW1lXSkge1xuXHRcdFx0Ly8gQmluZCBvbmUgY2FudmFzIGV2ZW50IHdoaWNoIGhhbmRsZXMgYWxsIGxheWVyIGV2ZW50cyBvZiB0aGF0IHR5cGVcblx0XHRcdGlmICh0b3VjaEV2ZW50TmFtZSAhPT0gaGVscGVyRXZlbnROYW1lKSB7XG5cdFx0XHRcdCRjYW52YXMuYmluZChoZWxwZXJFdmVudE5hbWUgKyAnLmpDYW52YXMgJyArIHRvdWNoRXZlbnROYW1lICsgJy5qQ2FudmFzJywgZXZlbnRDYWxsYmFjayk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkY2FudmFzLmJpbmQoaGVscGVyRXZlbnROYW1lICsgJy5qQ2FudmFzJywgZXZlbnRDYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0XHQvLyBQcmV2ZW50IHRoaXMgZXZlbnQgZnJvbSBiZWluZyBib3VuZCB0d2ljZVxuXHRcdFx0ZGF0YS5ldmVudHNbaGVscGVyRXZlbnROYW1lXSA9IHRydWU7XG5cdFx0fVxuXHR9O1xufVxuZnVuY3Rpb24gX2NyZWF0ZUV2ZW50cyhldmVudE5hbWVzKSB7XG5cdHZhciBuO1xuXHRmb3IgKG4gPSAwOyBuIDwgZXZlbnROYW1lcy5sZW5ndGg7IG4gKz0gMSkge1xuXHRcdF9jcmVhdGVFdmVudChldmVudE5hbWVzW25dKTtcblx0fVxufVxuLy8gUG9wdWxhdGUgakNhbnZhcyBldmVudHMgb2JqZWN0IHdpdGggc29tZSBzdGFuZGFyZCBldmVudHNcbl9jcmVhdGVFdmVudHMoW1xuXHQnY2xpY2snLFxuXHQnZGJsY2xpY2snLFxuXHQnbW91c2Vkb3duJyxcblx0J21vdXNldXAnLFxuXHQnbW91c2Vtb3ZlJyxcblx0J21vdXNlb3ZlcicsXG5cdCdtb3VzZW91dCcsXG5cdCd0b3VjaHN0YXJ0Jyxcblx0J3RvdWNobW92ZScsXG5cdCd0b3VjaGVuZCcsXG5cdCdwb2ludGVyZG93bicsXG5cdCdwb2ludGVybW92ZScsXG5cdCdwb2ludGVydXAnLFxuXHQnY29udGV4dG1lbnUnXG5dKTtcblxuLy8gQ2hlY2sgaWYgZXZlbnQgZmlyZXMgd2hlbiBhIGRyYXdpbmcgaXMgZHJhd25cbmZ1bmN0aW9uIF9kZXRlY3RFdmVudHMoY2FudmFzLCBjdHgsIHBhcmFtcykge1xuXHR2YXIgbGF5ZXIsIGRhdGEsIGV2ZW50Q2FjaGUsIGludGVyc2VjdHMsXG5cdFx0dHJhbnNmb3JtcywgeCwgeSwgYW5nbGU7XG5cblx0Ly8gVXNlIHRoZSBsYXllciBvYmplY3Qgc3RvcmVkIGJ5IHRoZSBnaXZlbiBwYXJhbWV0ZXJzIG9iamVjdFxuXHRsYXllciA9IHBhcmFtcy5fYXJncztcblx0Ly8gQ2FudmFzIG11c3QgaGF2ZSBldmVudCBiaW5kaW5nc1xuXHRpZiAobGF5ZXIpIHtcblxuXHRcdGRhdGEgPSBfZ2V0Q2FudmFzRGF0YShjYW52YXMpO1xuXHRcdGV2ZW50Q2FjaGUgPSBkYXRhLmV2ZW50O1xuXHRcdGlmIChldmVudENhY2hlLnggIT09IG51bGwgJiYgZXZlbnRDYWNoZS55ICE9PSBudWxsKSB7XG5cdFx0XHQvLyBSZXNwZWN0IHVzZXItZGVmaW5lZCBwaXhlbCByYXRpb1xuXHRcdFx0eCA9IGV2ZW50Q2FjaGUueCAqIGRhdGEucGl4ZWxSYXRpbztcblx0XHRcdHkgPSBldmVudENhY2hlLnkgKiBkYXRhLnBpeGVsUmF0aW87XG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgdGhlIGdpdmVuIGNvb3JkaW5hdGVzIGFyZSBpbiB0aGUgY3VycmVudCBwYXRoXG5cdFx0XHRpbnRlcnNlY3RzID0gY3R4LmlzUG9pbnRJblBhdGgoeCwgeSkgfHwgKGN0eC5pc1BvaW50SW5TdHJva2UgJiYgY3R4LmlzUG9pbnRJblN0cm9rZSh4LCB5KSk7XG5cdFx0fVxuXHRcdHRyYW5zZm9ybXMgPSBkYXRhLnRyYW5zZm9ybXM7XG5cblx0XHQvLyBBbGxvdyBjYWxsYmFjayBmdW5jdGlvbnMgdG8gcmV0cmlldmUgdGhlIG1vdXNlIGNvb3JkaW5hdGVzXG5cdFx0bGF5ZXIuZXZlbnRYID0gZXZlbnRDYWNoZS54O1xuXHRcdGxheWVyLmV2ZW50WSA9IGV2ZW50Q2FjaGUueTtcblx0XHRsYXllci5ldmVudCA9IGV2ZW50Q2FjaGUuZXZlbnQ7XG5cblx0XHQvLyBBZGp1c3QgY29vcmRpbmF0ZXMgdG8gbWF0Y2ggY3VycmVudCBjYW52YXMgdHJhbnNmb3JtYXRpb25cblxuXHRcdC8vIEtlZXAgdHJhY2sgb2Ygc29tZSB0cmFuc2Zvcm1hdGlvbiB2YWx1ZXNcblx0XHRhbmdsZSA9IGRhdGEudHJhbnNmb3Jtcy5yb3RhdGU7XG5cdFx0eCA9IGxheWVyLmV2ZW50WDtcblx0XHR5ID0gbGF5ZXIuZXZlbnRZO1xuXG5cdFx0aWYgKGFuZ2xlICE9PSAwKSB7XG5cdFx0XHQvLyBSb3RhdGUgY29vcmRpbmF0ZXMgaWYgY29vcmRpbmF0ZSBzcGFjZSBoYXMgYmVlbiByb3RhdGVkXG5cdFx0XHRsYXllci5fZXZlbnRYID0gKHggKiBjb3MoLWFuZ2xlKSkgLSAoeSAqIHNpbigtYW5nbGUpKTtcblx0XHRcdGxheWVyLl9ldmVudFkgPSAoeSAqIGNvcygtYW5nbGUpKSArICh4ICogc2luKC1hbmdsZSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBPdGhlcndpc2UsIG5vIGNhbGN1bGF0aW9ucyBuZWVkIHRvIGJlIG1hZGVcblx0XHRcdGxheWVyLl9ldmVudFggPSB4O1xuXHRcdFx0bGF5ZXIuX2V2ZW50WSA9IHk7XG5cdFx0fVxuXG5cdFx0Ly8gU2NhbGUgY29vcmRpbmF0ZXNcblx0XHRsYXllci5fZXZlbnRYIC89IHRyYW5zZm9ybXMuc2NhbGVYO1xuXHRcdGxheWVyLl9ldmVudFkgLz0gdHJhbnNmb3Jtcy5zY2FsZVk7XG5cblx0XHQvLyBJZiBsYXllciBpbnRlcnNlY3RzIHdpdGggY3Vyc29yXG5cdFx0aWYgKGludGVyc2VjdHMpIHtcblx0XHRcdC8vIEFkZCBpdCB0byBhIGxpc3Qgb2YgbGF5ZXJzIHRoYXQgaW50ZXJzZWN0IHdpdGggY3Vyc29yXG5cdFx0XHRkYXRhLmludGVyc2VjdGluZy5wdXNoKGxheWVyKTtcblx0XHR9XG5cdFx0bGF5ZXIuaW50ZXJzZWN0cyA9IEJvb2xlYW4oaW50ZXJzZWN0cyk7XG5cdH1cbn1cblxuLy8gTm9ybWFsaXplIG9mZnNldFggYW5kIG9mZnNldFkgZm9yIGFsbCBicm93c2Vyc1xuJC5ldmVudC5maXggPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0dmFyIG9mZnNldCwgb3JpZ2luYWxFdmVudCwgdG91Y2hlcztcblxuXHRldmVudCA9IGpRdWVyeUV2ZW50Rml4LmNhbGwoJC5ldmVudCwgZXZlbnQpO1xuXHRvcmlnaW5hbEV2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudDtcblxuXHQvLyBvcmlnaW5hbEV2ZW50IGRvZXMgbm90IGV4aXN0IGZvciBtYW51YWxseS10cmlnZ2VyZWQgZXZlbnRzXG5cdGlmIChvcmlnaW5hbEV2ZW50KSB7XG5cblx0XHR0b3VjaGVzID0gb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcztcblxuXHRcdC8vIElmIG9mZnNldFggYW5kIG9mZnNldFkgYXJlIG5vdCBzdXBwb3J0ZWQsIGRlZmluZSB0aGVtXG5cdFx0aWYgKGV2ZW50LnBhZ2VYICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRvZmZzZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLm9mZnNldCgpO1xuXHRcdFx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRcdFx0ZXZlbnQub2Zmc2V0WCA9IGV2ZW50LnBhZ2VYIC0gb2Zmc2V0LmxlZnQ7XG5cdFx0XHRcdFx0ZXZlbnQub2Zmc2V0WSA9IGV2ZW50LnBhZ2VZIC0gb2Zmc2V0LnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0Ly8gRmFpbCBzaWxlbnRseVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodG91Y2hlcykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gRW5hYmxlIG9mZnNldFggYW5kIG9mZnNldFkgZm9yIG1vYmlsZSBkZXZpY2VzXG5cdFx0XHRcdG9mZnNldCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkub2Zmc2V0KCk7XG5cdFx0XHRcdGlmIChvZmZzZXQpIHtcblx0XHRcdFx0XHRldmVudC5vZmZzZXRYID0gdG91Y2hlc1swXS5wYWdlWCAtIG9mZnNldC5sZWZ0O1xuXHRcdFx0XHRcdGV2ZW50Lm9mZnNldFkgPSB0b3VjaGVzWzBdLnBhZ2VZIC0gb2Zmc2V0LnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0Ly8gRmFpbCBzaWxlbnRseVxuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cdHJldHVybiBldmVudDtcbn07XG5cbi8qIERyYXdpbmcgQVBJICovXG5cbi8vIE1hcCBkcmF3aW5nIG5hbWVzIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBtZXRob2QgbmFtZXNcbm1hcHMuZHJhd2luZ3MgPSB7XG5cdCdhcmMnOiAnZHJhd0FyYycsXG5cdCdiZXppZXInOiAnZHJhd0JlemllcicsXG5cdCdlbGxpcHNlJzogJ2RyYXdFbGxpcHNlJyxcblx0J2Z1bmN0aW9uJzogJ2RyYXcnLFxuXHQnaW1hZ2UnOiAnZHJhd0ltYWdlJyxcblx0J2xpbmUnOiAnZHJhd0xpbmUnLFxuXHQncGF0aCc6ICdkcmF3UGF0aCcsXG5cdCdwb2x5Z29uJzogJ2RyYXdQb2x5Z29uJyxcblx0J3NsaWNlJzogJ2RyYXdTbGljZScsXG5cdCdxdWFkcmF0aWMnOiAnZHJhd1F1YWRyYXRpYycsXG5cdCdyZWN0YW5nbGUnOiAnZHJhd1JlY3QnLFxuXHQndGV4dCc6ICdkcmF3VGV4dCcsXG5cdCd2ZWN0b3InOiAnZHJhd1ZlY3RvcicsXG5cdCdzYXZlJzogJ3NhdmVDYW52YXMnLFxuXHQncmVzdG9yZSc6ICdyZXN0b3JlQ2FudmFzJyxcblx0J3JvdGF0ZSc6ICdyb3RhdGVDYW52YXMnLFxuXHQnc2NhbGUnOiAnc2NhbGVDYW52YXMnLFxuXHQndHJhbnNsYXRlJzogJ3RyYW5zbGF0ZUNhbnZhcydcbn07XG5cbi8vIERyYXdzIG9uIGNhbnZhcyB1c2luZyBhIGZ1bmN0aW9uXG4kLmZuLmRyYXcgPSBmdW5jdGlvbiBkcmF3KGFyZ3MpIHtcblx0dmFyICRjYW52YXNlcyA9IHRoaXMsIGUsIGN0eCxcblx0XHRwYXJhbXMgPSBuZXcgakNhbnZhc09iamVjdChhcmdzKTtcblxuXHQvLyBEcmF3IHVzaW5nIGFueSBvdGhlciBtZXRob2Rcblx0aWYgKG1hcHMuZHJhd2luZ3NbcGFyYW1zLnR5cGVdICYmIHBhcmFtcy50eXBlICE9PSAnZnVuY3Rpb24nKSB7XG5cblx0XHQkY2FudmFzZXNbbWFwcy5kcmF3aW5nc1twYXJhbXMudHlwZV1dKGFyZ3MpO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0XHRjdHggPSBfZ2V0Q29udGV4dCgkY2FudmFzZXNbZV0pO1xuXHRcdFx0aWYgKGN0eCkge1xuXG5cdFx0XHRcdHBhcmFtcyA9IG5ldyBqQ2FudmFzT2JqZWN0KGFyZ3MpO1xuXHRcdFx0XHRfYWRkTGF5ZXIoJGNhbnZhc2VzW2VdLCBwYXJhbXMsIGFyZ3MsIGRyYXcpO1xuXHRcdFx0XHRpZiAocGFyYW1zLnZpc2libGUpIHtcblxuXHRcdFx0XHRcdGlmIChwYXJhbXMuZm4pIHtcblx0XHRcdFx0XHRcdC8vIENhbGwgdGhlIGdpdmVuIHVzZXItZGVmaW5lZCBmdW5jdGlvblxuXHRcdFx0XHRcdFx0cGFyYW1zLmZuLmNhbGwoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cdHJldHVybiAkY2FudmFzZXM7XG59O1xuXG4vLyBDbGVhcnMgY2FudmFzXG4kLmZuLmNsZWFyQ2FudmFzID0gZnVuY3Rpb24gY2xlYXJDYW52YXMoYXJncykge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgZSwgY3R4LFxuXHRcdHBhcmFtcyA9IG5ldyBqQ2FudmFzT2JqZWN0KGFyZ3MpO1xuXG5cdGZvciAoZSA9IDA7IGUgPCAkY2FudmFzZXMubGVuZ3RoOyBlICs9IDEpIHtcblx0XHRjdHggPSBfZ2V0Q29udGV4dCgkY2FudmFzZXNbZV0pO1xuXHRcdGlmIChjdHgpIHtcblxuXHRcdFx0aWYgKHBhcmFtcy53aWR0aCA9PT0gbnVsbCB8fCBwYXJhbXMuaGVpZ2h0ID09PSBudWxsKSB7XG5cdFx0XHRcdC8vIENsZWFyIGVudGlyZSBjYW52YXMgaWYgd2lkdGgvaGVpZ2h0IGlzIG5vdCBnaXZlblxuXG5cdFx0XHRcdC8vIFJlc2V0IGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gdGVtcG9yYXJpbHkgdG8gZW5zdXJlIHRoYXQgdGhlIGVudGlyZSBjYW52YXMgaXMgY2xlYXJlZFxuXHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsICRjYW52YXNlc1tlXS53aWR0aCwgJGNhbnZhc2VzW2VdLmhlaWdodCk7XG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY2xlYXIgdGhlIGRlZmluZWQgc2VjdGlvbiBvZiB0aGUgY2FudmFzXG5cblx0XHRcdFx0Ly8gVHJhbnNmb3JtIGNsZWFyIHJlY3RhbmdsZVxuXHRcdFx0XHRfYWRkTGF5ZXIoJGNhbnZhc2VzW2VdLCBwYXJhbXMsIGFyZ3MsIGNsZWFyQ2FudmFzKTtcblx0XHRcdFx0X3RyYW5zZm9ybVNoYXBlKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMsIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XG5cdFx0XHRcdGN0eC5jbGVhclJlY3QocGFyYW1zLnggLSAocGFyYW1zLndpZHRoIC8gMiksIHBhcmFtcy55IC0gKHBhcmFtcy5oZWlnaHQgLyAyKSwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcblx0XHRcdFx0Ly8gUmVzdG9yZSBwcmV2aW91cyB0cmFuc2Zvcm1hdGlvblxuXHRcdFx0XHRfcmVzdG9yZVRyYW5zZm9ybShjdHgsIHBhcmFtcyk7XG5cblx0XHRcdH1cblxuXHRcdH1cblx0fVxuXHRyZXR1cm4gJGNhbnZhc2VzO1xufTtcblxuLyogVHJhbnNmb3JtYXRpb24gQVBJICovXG5cbi8vIFJlc3RvcmVzIGNhbnZhc1xuJC5mbi5zYXZlQ2FudmFzID0gZnVuY3Rpb24gc2F2ZUNhbnZhcyhhcmdzKSB7XG5cdHZhciAkY2FudmFzZXMgPSB0aGlzLCBlLCBjdHgsXG5cdFx0cGFyYW1zLCBkYXRhLCBpO1xuXG5cdGZvciAoZSA9IDA7IGUgPCAkY2FudmFzZXMubGVuZ3RoOyBlICs9IDEpIHtcblx0XHRjdHggPSBfZ2V0Q29udGV4dCgkY2FudmFzZXNbZV0pO1xuXHRcdGlmIChjdHgpIHtcblxuXHRcdFx0ZGF0YSA9IF9nZXRDYW52YXNEYXRhKCRjYW52YXNlc1tlXSk7XG5cblx0XHRcdHBhcmFtcyA9IG5ldyBqQ2FudmFzT2JqZWN0KGFyZ3MpO1xuXHRcdFx0X2FkZExheWVyKCRjYW52YXNlc1tlXSwgcGFyYW1zLCBhcmdzLCBzYXZlQ2FudmFzKTtcblxuXHRcdFx0Ly8gUmVzdG9yZSBhIG51bWJlciBvZiB0aW1lcyB1c2luZyB0aGUgZ2l2ZW4gY291bnRcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBwYXJhbXMuY291bnQ7IGkgKz0gMSkge1xuXHRcdFx0XHRfc2F2ZUNhbnZhcyhjdHgsIGRhdGEpO1xuXHRcdFx0fVxuXG5cdFx0fVxuXHR9XG5cdHJldHVybiAkY2FudmFzZXM7XG59O1xuXG4vLyBSZXN0b3JlcyBjYW52YXNcbiQuZm4ucmVzdG9yZUNhbnZhcyA9IGZ1bmN0aW9uIHJlc3RvcmVDYW52YXMoYXJncykge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgZSwgY3R4LFxuXHRcdHBhcmFtcywgZGF0YSwgaTtcblxuXHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0Y3R4ID0gX2dldENvbnRleHQoJGNhbnZhc2VzW2VdKTtcblx0XHRpZiAoY3R4KSB7XG5cblx0XHRcdGRhdGEgPSBfZ2V0Q2FudmFzRGF0YSgkY2FudmFzZXNbZV0pO1xuXG5cdFx0XHRwYXJhbXMgPSBuZXcgakNhbnZhc09iamVjdChhcmdzKTtcblx0XHRcdF9hZGRMYXllcigkY2FudmFzZXNbZV0sIHBhcmFtcywgYXJncywgcmVzdG9yZUNhbnZhcyk7XG5cblx0XHRcdC8vIFJlc3RvcmUgYSBudW1iZXIgb2YgdGltZXMgdXNpbmcgdGhlIGdpdmVuIGNvdW50XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGFyYW1zLmNvdW50OyBpICs9IDEpIHtcblx0XHRcdFx0X3Jlc3RvcmVDYW52YXMoY3R4LCBkYXRhKTtcblx0XHRcdH1cblxuXHRcdH1cblx0fVxuXHRyZXR1cm4gJGNhbnZhc2VzO1xufTtcblxuLy8gUm90YXRlcyBjYW52YXMgKGludGVybmFsKVxuZnVuY3Rpb24gX3JvdGF0ZUNhbnZhcyhjdHgsIHBhcmFtcywgdHJhbnNmb3Jtcykge1xuXG5cdC8vIEdldCBjb252ZXJzaW9uIGZhY3RvciBmb3IgcmFkaWFuc1xuXHRwYXJhbXMuX3RvUmFkID0gKHBhcmFtcy5pbkRlZ3JlZXMgPyAoUEkgLyAxODApIDogMSk7XG5cblx0Ly8gUm90YXRlIGNhbnZhcyB1c2luZyBzaGFwZSBhcyBjZW50ZXIgb2Ygcm90YXRpb25cblx0Y3R4LnRyYW5zbGF0ZShwYXJhbXMueCwgcGFyYW1zLnkpO1xuXHRjdHgucm90YXRlKHBhcmFtcy5yb3RhdGUgKiBwYXJhbXMuX3RvUmFkKTtcblx0Y3R4LnRyYW5zbGF0ZSgtcGFyYW1zLngsIC1wYXJhbXMueSk7XG5cblx0Ly8gSWYgdHJhbnNmb3JtYXRpb24gZGF0YSB3YXMgZ2l2ZW5cblx0aWYgKHRyYW5zZm9ybXMpIHtcblx0XHQvLyBVcGRhdGUgdHJhbnNmb3JtYXRpb24gZGF0YVxuXHRcdHRyYW5zZm9ybXMucm90YXRlICs9IChwYXJhbXMucm90YXRlICogcGFyYW1zLl90b1JhZCk7XG5cdH1cbn1cblxuLy8gU2NhbGVzIGNhbnZhcyAoaW50ZXJuYWwpXG5mdW5jdGlvbiBfc2NhbGVDYW52YXMoY3R4LCBwYXJhbXMsIHRyYW5zZm9ybXMpIHtcblxuXHQvLyBTY2FsZSBib3RoIHRoZSB4LSBhbmQgeS0gYXhpcyB1c2luZyB0aGUgJ3NjYWxlJyBwcm9wZXJ0eVxuXHRpZiAocGFyYW1zLnNjYWxlICE9PSAxKSB7XG5cdFx0cGFyYW1zLnNjYWxlWCA9IHBhcmFtcy5zY2FsZVkgPSBwYXJhbXMuc2NhbGU7XG5cdH1cblxuXHQvLyBTY2FsZSBjYW52YXMgdXNpbmcgc2hhcGUgYXMgY2VudGVyIG9mIHJvdGF0aW9uXG5cdGN0eC50cmFuc2xhdGUocGFyYW1zLngsIHBhcmFtcy55KTtcblx0Y3R4LnNjYWxlKHBhcmFtcy5zY2FsZVgsIHBhcmFtcy5zY2FsZVkpO1xuXHRjdHgudHJhbnNsYXRlKC1wYXJhbXMueCwgLXBhcmFtcy55KTtcblxuXHQvLyBJZiB0cmFuc2Zvcm1hdGlvbiBkYXRhIHdhcyBnaXZlblxuXHRpZiAodHJhbnNmb3Jtcykge1xuXHRcdC8vIFVwZGF0ZSB0cmFuc2Zvcm1hdGlvbiBkYXRhXG5cdFx0dHJhbnNmb3Jtcy5zY2FsZVggKj0gcGFyYW1zLnNjYWxlWDtcblx0XHR0cmFuc2Zvcm1zLnNjYWxlWSAqPSBwYXJhbXMuc2NhbGVZO1xuXHR9XG59XG5cbi8vIFRyYW5zbGF0ZXMgY2FudmFzIChpbnRlcm5hbClcbmZ1bmN0aW9uIF90cmFuc2xhdGVDYW52YXMoY3R4LCBwYXJhbXMsIHRyYW5zZm9ybXMpIHtcblxuXHQvLyBUcmFuc2xhdGUgYm90aCB0aGUgeC0gYW5kIHktYXhpcyB1c2luZyB0aGUgJ3RyYW5zbGF0ZScgcHJvcGVydHlcblx0aWYgKHBhcmFtcy50cmFuc2xhdGUpIHtcblx0XHRwYXJhbXMudHJhbnNsYXRlWCA9IHBhcmFtcy50cmFuc2xhdGVZID0gcGFyYW1zLnRyYW5zbGF0ZTtcblx0fVxuXG5cdC8vIFRyYW5zbGF0ZSBjYW52YXNcblx0Y3R4LnRyYW5zbGF0ZShwYXJhbXMudHJhbnNsYXRlWCwgcGFyYW1zLnRyYW5zbGF0ZVkpO1xuXG5cdC8vIElmIHRyYW5zZm9ybWF0aW9uIGRhdGEgd2FzIGdpdmVuXG5cdGlmICh0cmFuc2Zvcm1zKSB7XG5cdFx0Ly8gVXBkYXRlIHRyYW5zZm9ybWF0aW9uIGRhdGFcblx0XHR0cmFuc2Zvcm1zLnRyYW5zbGF0ZVggKz0gcGFyYW1zLnRyYW5zbGF0ZVg7XG5cdFx0dHJhbnNmb3Jtcy50cmFuc2xhdGVZICs9IHBhcmFtcy50cmFuc2xhdGVZO1xuXHR9XG59XG5cbi8vIFJvdGF0ZXMgY2FudmFzXG4kLmZuLnJvdGF0ZUNhbnZhcyA9IGZ1bmN0aW9uIHJvdGF0ZUNhbnZhcyhhcmdzKSB7XG5cdHZhciAkY2FudmFzZXMgPSB0aGlzLCBlLCBjdHgsXG5cdFx0cGFyYW1zLCBkYXRhO1xuXG5cdGZvciAoZSA9IDA7IGUgPCAkY2FudmFzZXMubGVuZ3RoOyBlICs9IDEpIHtcblx0XHRjdHggPSBfZ2V0Q29udGV4dCgkY2FudmFzZXNbZV0pO1xuXHRcdGlmIChjdHgpIHtcblxuXHRcdFx0ZGF0YSA9IF9nZXRDYW52YXNEYXRhKCRjYW52YXNlc1tlXSk7XG5cblx0XHRcdHBhcmFtcyA9IG5ldyBqQ2FudmFzT2JqZWN0KGFyZ3MpO1xuXHRcdFx0X2FkZExheWVyKCRjYW52YXNlc1tlXSwgcGFyYW1zLCBhcmdzLCByb3RhdGVDYW52YXMpO1xuXG5cdFx0XHQvLyBBdXRvc2F2ZSB0cmFuc2Zvcm1hdGlvbiBzdGF0ZSBieSBkZWZhdWx0XG5cdFx0XHRpZiAocGFyYW1zLmF1dG9zYXZlKSB7XG5cdFx0XHRcdC8vIEF1dG9tYXRpY2FsbHkgc2F2ZSB0cmFuc2Zvcm1hdGlvbiBzdGF0ZSBieSBkZWZhdWx0XG5cdFx0XHRcdF9zYXZlQ2FudmFzKGN0eCwgZGF0YSk7XG5cdFx0XHR9XG5cdFx0XHRfcm90YXRlQ2FudmFzKGN0eCwgcGFyYW1zLCBkYXRhLnRyYW5zZm9ybXMpO1xuXHRcdH1cblxuXHR9XG5cdHJldHVybiAkY2FudmFzZXM7XG59O1xuXG4vLyBTY2FsZXMgY2FudmFzXG4kLmZuLnNjYWxlQ2FudmFzID0gZnVuY3Rpb24gc2NhbGVDYW52YXMoYXJncykge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgZSwgY3R4LFxuXHRcdHBhcmFtcywgZGF0YTtcblxuXHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0Y3R4ID0gX2dldENvbnRleHQoJGNhbnZhc2VzW2VdKTtcblx0XHRpZiAoY3R4KSB7XG5cblx0XHRcdGRhdGEgPSBfZ2V0Q2FudmFzRGF0YSgkY2FudmFzZXNbZV0pO1xuXG5cdFx0XHRwYXJhbXMgPSBuZXcgakNhbnZhc09iamVjdChhcmdzKTtcblx0XHRcdF9hZGRMYXllcigkY2FudmFzZXNbZV0sIHBhcmFtcywgYXJncywgc2NhbGVDYW52YXMpO1xuXG5cdFx0XHQvLyBBdXRvc2F2ZSB0cmFuc2Zvcm1hdGlvbiBzdGF0ZSBieSBkZWZhdWx0XG5cdFx0XHRpZiAocGFyYW1zLmF1dG9zYXZlKSB7XG5cdFx0XHRcdC8vIEF1dG9tYXRpY2FsbHkgc2F2ZSB0cmFuc2Zvcm1hdGlvbiBzdGF0ZSBieSBkZWZhdWx0XG5cdFx0XHRcdF9zYXZlQ2FudmFzKGN0eCwgZGF0YSk7XG5cdFx0XHR9XG5cdFx0XHRfc2NhbGVDYW52YXMoY3R4LCBwYXJhbXMsIGRhdGEudHJhbnNmb3Jtcyk7XG5cblx0XHR9XG5cdH1cblx0cmV0dXJuICRjYW52YXNlcztcbn07XG5cbi8vIFRyYW5zbGF0ZXMgY2FudmFzXG4kLmZuLnRyYW5zbGF0ZUNhbnZhcyA9IGZ1bmN0aW9uIHRyYW5zbGF0ZUNhbnZhcyhhcmdzKSB7XG5cdHZhciAkY2FudmFzZXMgPSB0aGlzLCBlLCBjdHgsXG5cdFx0cGFyYW1zLCBkYXRhO1xuXG5cdGZvciAoZSA9IDA7IGUgPCAkY2FudmFzZXMubGVuZ3RoOyBlICs9IDEpIHtcblx0XHRjdHggPSBfZ2V0Q29udGV4dCgkY2FudmFzZXNbZV0pO1xuXHRcdGlmIChjdHgpIHtcblxuXHRcdFx0ZGF0YSA9IF9nZXRDYW52YXNEYXRhKCRjYW52YXNlc1tlXSk7XG5cblx0XHRcdHBhcmFtcyA9IG5ldyBqQ2FudmFzT2JqZWN0KGFyZ3MpO1xuXHRcdFx0X2FkZExheWVyKCRjYW52YXNlc1tlXSwgcGFyYW1zLCBhcmdzLCB0cmFuc2xhdGVDYW52YXMpO1xuXG5cdFx0XHQvLyBBdXRvc2F2ZSB0cmFuc2Zvcm1hdGlvbiBzdGF0ZSBieSBkZWZhdWx0XG5cdFx0XHRpZiAocGFyYW1zLmF1dG9zYXZlKSB7XG5cdFx0XHRcdC8vIEF1dG9tYXRpY2FsbHkgc2F2ZSB0cmFuc2Zvcm1hdGlvbiBzdGF0ZSBieSBkZWZhdWx0XG5cdFx0XHRcdF9zYXZlQ2FudmFzKGN0eCwgZGF0YSk7XG5cdFx0XHR9XG5cdFx0XHRfdHJhbnNsYXRlQ2FudmFzKGN0eCwgcGFyYW1zLCBkYXRhLnRyYW5zZm9ybXMpO1xuXG5cdFx0fVxuXHR9XG5cdHJldHVybiAkY2FudmFzZXM7XG59O1xuXG4vKiBTaGFwZSBBUEkgKi9cblxuLy8gRHJhd3MgcmVjdGFuZ2xlXG4kLmZuLmRyYXdSZWN0ID0gZnVuY3Rpb24gZHJhd1JlY3QoYXJncykge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgZSwgY3R4LFxuXHRcdHBhcmFtcyxcblx0XHR4MSwgeTEsXG5cdFx0eDIsIHkyLFxuXHRcdHIsIHRlbXA7XG5cblx0Zm9yIChlID0gMDsgZSA8ICRjYW52YXNlcy5sZW5ndGg7IGUgKz0gMSkge1xuXHRcdGN0eCA9IF9nZXRDb250ZXh0KCRjYW52YXNlc1tlXSk7XG5cdFx0aWYgKGN0eCkge1xuXG5cdFx0XHRwYXJhbXMgPSBuZXcgakNhbnZhc09iamVjdChhcmdzKTtcblx0XHRcdF9hZGRMYXllcigkY2FudmFzZXNbZV0sIHBhcmFtcywgYXJncywgZHJhd1JlY3QpO1xuXHRcdFx0aWYgKHBhcmFtcy52aXNpYmxlKSB7XG5cblx0XHRcdFx0X3RyYW5zZm9ybVNoYXBlKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMsIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XG5cdFx0XHRcdF9zZXRHbG9iYWxQcm9wcygkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zKTtcblxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGlmIChwYXJhbXMud2lkdGggJiYgcGFyYW1zLmhlaWdodCkge1xuXHRcdFx0XHRcdHgxID0gcGFyYW1zLnggLSAocGFyYW1zLndpZHRoIC8gMik7XG5cdFx0XHRcdFx0eTEgPSBwYXJhbXMueSAtIChwYXJhbXMuaGVpZ2h0IC8gMik7XG5cdFx0XHRcdFx0ciA9IGFicyhwYXJhbXMuY29ybmVyUmFkaXVzKTtcblx0XHRcdFx0XHQvLyBJZiBjb3JuZXIgcmFkaXVzIGlzIGRlZmluZWQgYW5kIGlzIG5vdCB6ZXJvXG5cdFx0XHRcdFx0aWYgKHIpIHtcblx0XHRcdFx0XHRcdC8vIERyYXcgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzIGlmIGNvcm5lclJhZGl1cyBpcyBkZWZpbmVkXG5cblx0XHRcdFx0XHRcdHgyID0gcGFyYW1zLnggKyAocGFyYW1zLndpZHRoIC8gMik7XG5cdFx0XHRcdFx0XHR5MiA9IHBhcmFtcy55ICsgKHBhcmFtcy5oZWlnaHQgLyAyKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIG5lZ2F0aXZlIHdpZHRoXG5cdFx0XHRcdFx0XHRpZiAocGFyYW1zLndpZHRoIDwgMCkge1xuXHRcdFx0XHRcdFx0XHR0ZW1wID0geDE7XG5cdFx0XHRcdFx0XHRcdHgxID0geDI7XG5cdFx0XHRcdFx0XHRcdHgyID0gdGVtcDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBuZWdhdGl2ZSBoZWlnaHRcblx0XHRcdFx0XHRcdGlmIChwYXJhbXMuaGVpZ2h0IDwgMCkge1xuXHRcdFx0XHRcdFx0XHR0ZW1wID0geTE7XG5cdFx0XHRcdFx0XHRcdHkxID0geTI7XG5cdFx0XHRcdFx0XHRcdHkyID0gdGVtcDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gUHJldmVudCBvdmVyLXJvdW5kZWQgY29ybmVyc1xuXHRcdFx0XHRcdFx0aWYgKCh4MiAtIHgxKSAtICgyICogcikgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdHIgPSAoeDIgLSB4MSkgLyAyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCh5MiAtIHkxKSAtICgyICogcikgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdHIgPSAoeTIgLSB5MSkgLyAyO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBEcmF3IHJlY3RhbmdsZVxuXHRcdFx0XHRcdFx0Y3R4Lm1vdmVUbyh4MSArIHIsIHkxKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oeDIgLSByLCB5MSk7XG5cdFx0XHRcdFx0XHRjdHguYXJjKHgyIC0gciwgeTEgKyByLCByLCAzICogUEkgLyAyLCBQSSAqIDIsIGZhbHNlKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oeDIsIHkyIC0gcik7XG5cdFx0XHRcdFx0XHRjdHguYXJjKHgyIC0gciwgeTIgLSByLCByLCAwLCBQSSAvIDIsIGZhbHNlKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oeDEgKyByLCB5Mik7XG5cdFx0XHRcdFx0XHRjdHguYXJjKHgxICsgciwgeTIgLSByLCByLCBQSSAvIDIsIFBJLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKHgxLCB5MSArIHIpO1xuXHRcdFx0XHRcdFx0Y3R4LmFyYyh4MSArIHIsIHkxICsgciwgciwgUEksIDMgKiBQSSAvIDIsIGZhbHNlKTtcblx0XHRcdFx0XHRcdC8vIEFsd2F5cyBjbG9zZSBwYXRoXG5cdFx0XHRcdFx0XHRwYXJhbXMuY2xvc2VkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgZHJhdyByZWN0YW5nbGUgd2l0aCBzcXVhcmUgY29ybmVyc1xuXHRcdFx0XHRcdFx0Y3R4LnJlY3QoeDEsIHkxLCBwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQpO1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIENoZWNrIGZvciBqQ2FudmFzIGV2ZW50c1xuXHRcdFx0XHRfZGV0ZWN0RXZlbnRzKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMpO1xuXHRcdFx0XHQvLyBDbG9zZSByZWN0YW5nbGUgcGF0aFxuXHRcdFx0XHRfY2xvc2VQYXRoKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gJGNhbnZhc2VzO1xufTtcblxuLy8gUmV0cmlldmVzIGEgY290ZXJtaW5hbCBhbmdsZSBiZXR3ZWVuIDAgYW5kIDJwaSBmb3IgdGhlIGdpdmVuIGFuZ2xlXG5mdW5jdGlvbiBfZ2V0Q290ZXJtaW5hbChhbmdsZSkge1xuXHR3aGlsZSAoYW5nbGUgPCAwKSB7XG5cdFx0YW5nbGUgKz0gKDIgKiBQSSk7XG5cdH1cblx0cmV0dXJuIGFuZ2xlO1xufVxuXG4vLyBSZXRyaWV2ZXMgdGhlIHgtY29vcmRpbmF0ZSBmb3IgdGhlIGdpdmVuIGFuZ2xlIGluIGEgY2lyY2xlXG5mdW5jdGlvbiBfZ2V0QXJjWChwYXJhbXMsIGFuZ2xlKSB7XG5cdHJldHVybiBwYXJhbXMueCArIChwYXJhbXMucmFkaXVzICogY29zKGFuZ2xlKSk7XG59XG4vLyBSZXRyaWV2ZXMgdGhlIHktY29vcmRpbmF0ZSBmb3IgdGhlIGdpdmVuIGFuZ2xlIGluIGEgY2lyY2xlXG5mdW5jdGlvbiBfZ2V0QXJjWShwYXJhbXMsIGFuZ2xlKSB7XG5cdHJldHVybiBwYXJhbXMueSArIChwYXJhbXMucmFkaXVzICogc2luKGFuZ2xlKSk7XG59XG5cbi8vIERyYXdzIGFyYyAoaW50ZXJuYWwpXG5mdW5jdGlvbiBfZHJhd0FyYyhjYW52YXMsIGN0eCwgcGFyYW1zLCBwYXRoKSB7XG5cdHZhciB4MSwgeTEsIHgyLCB5Mixcblx0XHR4MywgeTMsIHg0LCB5NCxcblx0XHRvZmZzZXRYLCBvZmZzZXRZLFxuXHRcdGRpZmY7XG5cblx0Ly8gRGV0ZXJtaW5lIG9mZnNldCBmcm9tIGRyYWdnaW5nXG5cdGlmIChwYXJhbXMgPT09IHBhdGgpIHtcblx0XHRvZmZzZXRYID0gMDtcblx0XHRvZmZzZXRZID0gMDtcblx0fSBlbHNlIHtcblx0XHRvZmZzZXRYID0gcGFyYW1zLng7XG5cdFx0b2Zmc2V0WSA9IHBhcmFtcy55O1xuXHR9XG5cblx0Ly8gQ29udmVydCBkZWZhdWx0IGVuZCBhbmdsZSB0byByYWRpYW5zXG5cdGlmICghcGF0aC5pbkRlZ3JlZXMgJiYgcGF0aC5lbmQgPT09IDM2MCkge1xuXHRcdHBhdGguZW5kID0gUEkgKiAyO1xuXHR9XG5cblx0Ly8gQ29udmVydCBhbmdsZXMgdG8gcmFkaWFuc1xuXHRwYXRoLnN0YXJ0ICo9IHBhcmFtcy5fdG9SYWQ7XG5cdHBhdGguZW5kICo9IHBhcmFtcy5fdG9SYWQ7XG5cdC8vIENvbnNpZGVyIDBkZWcgZHVlIG5vcnRoIG9mIGFyY1xuXHRwYXRoLnN0YXJ0IC09IChQSSAvIDIpO1xuXHRwYXRoLmVuZCAtPSAoUEkgLyAyKTtcblxuXHQvLyBFbnN1cmUgYXJyb3dzIGFyZSBwb2ludGVkIGNvcnJlY3RseSBmb3IgQ0NXIGFyY3Ncblx0ZGlmZiA9IFBJIC8gMTgwO1xuXHRpZiAocGF0aC5jY3cpIHtcblx0XHRkaWZmICo9IC0xO1xuXHR9XG5cblx0Ly8gQ2FsY3VsYXRlIGNvb3JkaW5hdGVzIGZvciBzdGFydCBhcnJvd1xuXHR4MSA9IF9nZXRBcmNYKHBhdGgsIHBhdGguc3RhcnQgKyBkaWZmKTtcblx0eTEgPSBfZ2V0QXJjWShwYXRoLCBwYXRoLnN0YXJ0ICsgZGlmZik7XG5cdHgyID0gX2dldEFyY1gocGF0aCwgcGF0aC5zdGFydCk7XG5cdHkyID0gX2dldEFyY1kocGF0aCwgcGF0aC5zdGFydCk7XG5cblx0X2FkZFN0YXJ0QXJyb3coXG5cdFx0Y2FudmFzLCBjdHgsXG5cdFx0cGFyYW1zLCBwYXRoLFxuXHRcdHgxLCB5MSxcblx0XHR4MiwgeTJcblx0KTtcblxuXHQvLyBEcmF3IGFyY1xuXHRjdHguYXJjKHBhdGgueCArIG9mZnNldFgsIHBhdGgueSArIG9mZnNldFksIHBhdGgucmFkaXVzLCBwYXRoLnN0YXJ0LCBwYXRoLmVuZCwgcGF0aC5jY3cpO1xuXG5cdC8vIENhbGN1bGF0ZSBjb29yZGluYXRlcyBmb3IgZW5kIGFycm93XG5cdHgzID0gX2dldEFyY1gocGF0aCwgcGF0aC5lbmQgKyBkaWZmKTtcblx0eTMgPSBfZ2V0QXJjWShwYXRoLCBwYXRoLmVuZCArIGRpZmYpO1xuXHR4NCA9IF9nZXRBcmNYKHBhdGgsIHBhdGguZW5kKTtcblx0eTQgPSBfZ2V0QXJjWShwYXRoLCBwYXRoLmVuZCk7XG5cblx0X2FkZEVuZEFycm93KFxuXHRcdGNhbnZhcywgY3R4LFxuXHRcdHBhcmFtcywgcGF0aCxcblx0XHR4NCwgeTQsXG5cdFx0eDMsIHkzXG5cdCk7XG59XG5cbi8vIERyYXdzIGFyYyBvciBjaXJjbGVcbiQuZm4uZHJhd0FyYyA9IGZ1bmN0aW9uIGRyYXdBcmMoYXJncykge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgZSwgY3R4LFxuXHRcdHBhcmFtcztcblxuXHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0Y3R4ID0gX2dldENvbnRleHQoJGNhbnZhc2VzW2VdKTtcblx0XHRpZiAoY3R4KSB7XG5cblx0XHRcdHBhcmFtcyA9IG5ldyBqQ2FudmFzT2JqZWN0KGFyZ3MpO1xuXHRcdFx0X2FkZExheWVyKCRjYW52YXNlc1tlXSwgcGFyYW1zLCBhcmdzLCBkcmF3QXJjKTtcblx0XHRcdGlmIChwYXJhbXMudmlzaWJsZSkge1xuXG5cdFx0XHRcdF90cmFuc2Zvcm1TaGFwZSgkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zLCBwYXJhbXMucmFkaXVzICogMik7XG5cdFx0XHRcdF9zZXRHbG9iYWxQcm9wcygkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zKTtcblxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdF9kcmF3QXJjKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMsIHBhcmFtcyk7XG5cdFx0XHRcdC8vIENoZWNrIGZvciBqQ2FudmFzIGV2ZW50c1xuXHRcdFx0XHRfZGV0ZWN0RXZlbnRzKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMpO1xuXHRcdFx0XHQvLyBPcHRpb25hbGx5IGNsb3NlIHBhdGhcblx0XHRcdFx0X2Nsb3NlUGF0aCgkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXHR9XG5cdHJldHVybiAkY2FudmFzZXM7XG59O1xuXG4vLyBEcmF3cyBlbGxpcHNlXG4kLmZuLmRyYXdFbGxpcHNlID0gZnVuY3Rpb24gZHJhd0VsbGlwc2UoYXJncykge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgZSwgY3R4LFxuXHRcdHBhcmFtcyxcblx0XHRjb250cm9sVyxcblx0XHRjb250cm9sSDtcblxuXHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0Y3R4ID0gX2dldENvbnRleHQoJGNhbnZhc2VzW2VdKTtcblx0XHRpZiAoY3R4KSB7XG5cblx0XHRcdHBhcmFtcyA9IG5ldyBqQ2FudmFzT2JqZWN0KGFyZ3MpO1xuXHRcdFx0X2FkZExheWVyKCRjYW52YXNlc1tlXSwgcGFyYW1zLCBhcmdzLCBkcmF3RWxsaXBzZSk7XG5cdFx0XHRpZiAocGFyYW1zLnZpc2libGUpIHtcblxuXHRcdFx0XHRfdHJhbnNmb3JtU2hhcGUoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcywgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcblx0XHRcdFx0X3NldEdsb2JhbFByb3BzKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMpO1xuXG5cdFx0XHRcdC8vIENhbGN1bGF0ZSBjb250cm9sIHdpZHRoIGFuZCBoZWlnaHRcblx0XHRcdFx0Y29udHJvbFcgPSBwYXJhbXMud2lkdGggKiAoNCAvIDMpO1xuXHRcdFx0XHRjb250cm9sSCA9IHBhcmFtcy5oZWlnaHQ7XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIGVsbGlwc2UgdXNpbmcgY3VydmVzXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4Lm1vdmVUbyhwYXJhbXMueCwgcGFyYW1zLnkgLSAoY29udHJvbEggLyAyKSk7XG5cdFx0XHRcdC8vIExlZnQgc2lkZVxuXHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhwYXJhbXMueCAtIChjb250cm9sVyAvIDIpLCBwYXJhbXMueSAtIChjb250cm9sSCAvIDIpLCBwYXJhbXMueCAtIChjb250cm9sVyAvIDIpLCBwYXJhbXMueSArIChjb250cm9sSCAvIDIpLCBwYXJhbXMueCwgcGFyYW1zLnkgKyAoY29udHJvbEggLyAyKSk7XG5cdFx0XHRcdC8vIFJpZ2h0IHNpZGVcblx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8ocGFyYW1zLnggKyAoY29udHJvbFcgLyAyKSwgcGFyYW1zLnkgKyAoY29udHJvbEggLyAyKSwgcGFyYW1zLnggKyAoY29udHJvbFcgLyAyKSwgcGFyYW1zLnkgLSAoY29udHJvbEggLyAyKSwgcGFyYW1zLngsIHBhcmFtcy55IC0gKGNvbnRyb2xIIC8gMikpO1xuXHRcdFx0XHQvLyBDaGVjayBmb3IgakNhbnZhcyBldmVudHNcblx0XHRcdFx0X2RldGVjdEV2ZW50cygkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zKTtcblx0XHRcdFx0Ly8gQWx3YXlzIGNsb3NlIHBhdGhcblx0XHRcdFx0cGFyYW1zLmNsb3NlZCA9IHRydWU7XG5cdFx0XHRcdF9jbG9zZVBhdGgoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcyk7XG5cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuICRjYW52YXNlcztcbn07XG5cbi8vIERyYXdzIGEgcmVndWxhciAoZXF1YWwtYW5nbGVkKSBwb2x5Z29uXG4kLmZuLmRyYXdQb2x5Z29uID0gZnVuY3Rpb24gZHJhd1BvbHlnb24oYXJncykge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgZSwgY3R4LFxuXHRcdHBhcmFtcyxcblx0XHR0aGV0YSwgZHRoZXRhLCBoZHRoZXRhLFxuXHRcdGFwb3RoZW0sXG5cdFx0eCwgeSwgaTtcblxuXHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0Y3R4ID0gX2dldENvbnRleHQoJGNhbnZhc2VzW2VdKTtcblx0XHRpZiAoY3R4KSB7XG5cblx0XHRcdHBhcmFtcyA9IG5ldyBqQ2FudmFzT2JqZWN0KGFyZ3MpO1xuXHRcdFx0X2FkZExheWVyKCRjYW52YXNlc1tlXSwgcGFyYW1zLCBhcmdzLCBkcmF3UG9seWdvbik7XG5cdFx0XHRpZiAocGFyYW1zLnZpc2libGUpIHtcblxuXHRcdFx0XHRfdHJhbnNmb3JtU2hhcGUoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcywgcGFyYW1zLnJhZGl1cyAqIDIpO1xuXHRcdFx0XHRfc2V0R2xvYmFsUHJvcHMoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcyk7XG5cblx0XHRcdFx0Ly8gUG9seWdvbidzIGNlbnRyYWwgYW5nbGVcblx0XHRcdFx0ZHRoZXRhID0gKDIgKiBQSSkgLyBwYXJhbXMuc2lkZXM7XG5cdFx0XHRcdC8vIEhhbGYgb2YgZHRoZXRhXG5cdFx0XHRcdGhkdGhldGEgPSBkdGhldGEgLyAyO1xuXHRcdFx0XHQvLyBQb2x5Z29uJ3Mgc3RhcnRpbmcgYW5nbGVcblx0XHRcdFx0dGhldGEgPSBoZHRoZXRhICsgKFBJIC8gMik7XG5cdFx0XHRcdC8vIERpc3RhbmNlIGZyb20gcG9seWdvbidzIGNlbnRlciB0byB0aGUgbWlkZGxlIG9mIGl0cyBzaWRlXG5cdFx0XHRcdGFwb3RoZW0gPSBwYXJhbXMucmFkaXVzICogY29zKGhkdGhldGEpO1xuXG5cdFx0XHRcdC8vIENhbGN1bGF0ZSBwYXRoIGFuZCBkcmF3XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhcmFtcy5zaWRlczsgaSArPSAxKSB7XG5cblx0XHRcdFx0XHQvLyBEcmF3IHNpZGUgb2YgcG9seWdvblxuXHRcdFx0XHRcdHggPSBwYXJhbXMueCArIChwYXJhbXMucmFkaXVzICogY29zKHRoZXRhKSk7XG5cdFx0XHRcdFx0eSA9IHBhcmFtcy55ICsgKHBhcmFtcy5yYWRpdXMgKiBzaW4odGhldGEpKTtcblxuXHRcdFx0XHRcdC8vIFBsb3QgcG9pbnQgb24gcG9seWdvblxuXHRcdFx0XHRcdGN0eC5saW5lVG8oeCwgeSk7XG5cblx0XHRcdFx0XHQvLyBQcm9qZWN0IHNpZGUgaWYgY2hvc2VuXG5cdFx0XHRcdFx0aWYgKHBhcmFtcy5jb25jYXZpdHkpIHtcblx0XHRcdFx0XHRcdC8vIFNpZGVzIGFyZSBwcm9qZWN0ZWQgZnJvbSB0aGUgcG9seWdvbidzIGFwb3RoZW1cblx0XHRcdFx0XHRcdHggPSBwYXJhbXMueCArICgoYXBvdGhlbSArICgtYXBvdGhlbSAqIHBhcmFtcy5jb25jYXZpdHkpKSAqIGNvcyh0aGV0YSArIGhkdGhldGEpKTtcblx0XHRcdFx0XHRcdHkgPSBwYXJhbXMueSArICgoYXBvdGhlbSArICgtYXBvdGhlbSAqIHBhcmFtcy5jb25jYXZpdHkpKSAqIHNpbih0aGV0YSArIGhkdGhldGEpKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oeCwgeSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSW5jcmVtZW50IHRoZXRhIGJ5IGRlbHRhIHRoZXRhXG5cdFx0XHRcdFx0dGhldGEgKz0gZHRoZXRhO1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gQ2hlY2sgZm9yIGpDYW52YXMgZXZlbnRzXG5cdFx0XHRcdF9kZXRlY3RFdmVudHMoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcyk7XG5cdFx0XHRcdC8vIEFsd2F5cyBjbG9zZSBwYXRoXG5cdFx0XHRcdHBhcmFtcy5jbG9zZWQgPSB0cnVlO1xuXHRcdFx0XHRfY2xvc2VQYXRoKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMpO1xuXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiAkY2FudmFzZXM7XG59O1xuXG4vLyBEcmF3cyBwaWUtc2hhcGVkIHNsaWNlXG4kLmZuLmRyYXdTbGljZSA9IGZ1bmN0aW9uIGRyYXdTbGljZShhcmdzKSB7XG5cdHZhciAkY2FudmFzZXMgPSB0aGlzLCBlLCBjdHgsXG5cdFx0cGFyYW1zLFxuXHRcdGFuZ2xlLCBkeCwgZHk7XG5cblx0Zm9yIChlID0gMDsgZSA8ICRjYW52YXNlcy5sZW5ndGg7IGUgKz0gMSkge1xuXHRcdGN0eCA9IF9nZXRDb250ZXh0KCRjYW52YXNlc1tlXSk7XG5cdFx0aWYgKGN0eCkge1xuXG5cdFx0XHRwYXJhbXMgPSBuZXcgakNhbnZhc09iamVjdChhcmdzKTtcblx0XHRcdF9hZGRMYXllcigkY2FudmFzZXNbZV0sIHBhcmFtcywgYXJncywgZHJhd1NsaWNlKTtcblx0XHRcdGlmIChwYXJhbXMudmlzaWJsZSkge1xuXG5cdFx0XHRcdF90cmFuc2Zvcm1TaGFwZSgkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zLCBwYXJhbXMucmFkaXVzICogMik7XG5cdFx0XHRcdF9zZXRHbG9iYWxQcm9wcygkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zKTtcblxuXHRcdFx0XHQvLyBQZXJmb3JtIGV4dHJhIGNhbGN1bGF0aW9uc1xuXG5cdFx0XHRcdC8vIENvbnZlcnQgYW5nbGVzIHRvIHJhZGlhbnNcblx0XHRcdFx0cGFyYW1zLnN0YXJ0ICo9IHBhcmFtcy5fdG9SYWQ7XG5cdFx0XHRcdHBhcmFtcy5lbmQgKj0gcGFyYW1zLl90b1JhZDtcblx0XHRcdFx0Ly8gQ29uc2lkZXIgMGRlZyBhdCBub3J0aCBvZiBhcmNcblx0XHRcdFx0cGFyYW1zLnN0YXJ0IC09IChQSSAvIDIpO1xuXHRcdFx0XHRwYXJhbXMuZW5kIC09IChQSSAvIDIpO1xuXG5cdFx0XHRcdC8vIEZpbmQgcG9zaXRpdmUgZXF1aXZhbGVudHMgb2YgYW5nbGVzXG5cdFx0XHRcdHBhcmFtcy5zdGFydCA9IF9nZXRDb3Rlcm1pbmFsKHBhcmFtcy5zdGFydCk7XG5cdFx0XHRcdHBhcmFtcy5lbmQgPSBfZ2V0Q290ZXJtaW5hbChwYXJhbXMuZW5kKTtcblx0XHRcdFx0Ly8gRW5zdXJlIHN0YXJ0IGFuZ2xlIGlzIGxlc3MgdGhhbiBlbmQgYW5nbGVcblx0XHRcdFx0aWYgKHBhcmFtcy5lbmQgPCBwYXJhbXMuc3RhcnQpIHtcblx0XHRcdFx0XHRwYXJhbXMuZW5kICs9ICgyICogUEkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsY3VsYXRlIGFuZ3VsYXIgcG9zaXRpb24gb2Ygc2xpY2Vcblx0XHRcdFx0YW5nbGUgPSAoKHBhcmFtcy5zdGFydCArIHBhcmFtcy5lbmQpIC8gMik7XG5cblx0XHRcdFx0Ly8gQ2FsY3VsYXRlIHJhdGlvcyBmb3Igc2xpY2UncyBhbmdsZVxuXHRcdFx0XHRkeCA9IChwYXJhbXMucmFkaXVzICogcGFyYW1zLnNwcmVhZCAqIGNvcyhhbmdsZSkpO1xuXHRcdFx0XHRkeSA9IChwYXJhbXMucmFkaXVzICogcGFyYW1zLnNwcmVhZCAqIHNpbihhbmdsZSkpO1xuXG5cdFx0XHRcdC8vIEFkanVzdCBwb3NpdGlvbiBvZiBzbGljZVxuXHRcdFx0XHRwYXJhbXMueCArPSBkeDtcblx0XHRcdFx0cGFyYW1zLnkgKz0gZHk7XG5cblx0XHRcdFx0Ly8gRHJhdyBzbGljZVxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5hcmMocGFyYW1zLngsIHBhcmFtcy55LCBwYXJhbXMucmFkaXVzLCBwYXJhbXMuc3RhcnQsIHBhcmFtcy5lbmQsIHBhcmFtcy5jY3cpO1xuXHRcdFx0XHRjdHgubGluZVRvKHBhcmFtcy54LCBwYXJhbXMueSk7XG5cdFx0XHRcdC8vIENoZWNrIGZvciBqQ2FudmFzIGV2ZW50c1xuXHRcdFx0XHRfZGV0ZWN0RXZlbnRzKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMpO1xuXHRcdFx0XHQvLyBBbHdheXMgY2xvc2UgcGF0aFxuXHRcdFx0XHRwYXJhbXMuY2xvc2VkID0gdHJ1ZTtcblx0XHRcdFx0X2Nsb3NlUGF0aCgkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXHR9XG5cdHJldHVybiAkY2FudmFzZXM7XG59O1xuXG4vKiBQYXRoIEFQSSAqL1xuXG4vLyBBZGRzIGFycm93IHRvIHBhdGggdXNpbmcgdGhlIGdpdmVuIHByb3BlcnRpZXNcbmZ1bmN0aW9uIF9hZGRBcnJvdyhjYW52YXMsIGN0eCwgcGFyYW1zLCBwYXRoLCB4MSwgeTEsIHgyLCB5Mikge1xuXHR2YXIgbGVmdFgsIGxlZnRZLFxuXHRcdHJpZ2h0WCwgcmlnaHRZLFxuXHRcdG9mZnNldFgsIG9mZnNldFksXG5cdFx0YW5nbGU7XG5cblx0Ly8gSWYgYXJyb3cgcmFkaXVzIGlzIGdpdmVuIGFuZCBwYXRoIGlzIG5vdCBjbG9zZWRcblx0aWYgKHBhdGguYXJyb3dSYWRpdXMgJiYgIXBhcmFtcy5jbG9zZWQpIHtcblxuXHRcdC8vIENhbGN1bGF0ZSBhbmdsZVxuXHRcdGFuZ2xlID0gYXRhbjIoKHkyIC0geTEpLCAoeDIgLSB4MSkpO1xuXHRcdC8vIEFkanVzdCBhbmdsZSBjb3JyZWN0bHlcblx0XHRhbmdsZSAtPSBQSTtcblx0XHQvLyBDYWxjdWxhdGUgb2Zmc2V0IHRvIHBsYWNlIGFycm93IGF0IGVkZ2Ugb2YgcGF0aFxuXHRcdG9mZnNldFggPSAocGFyYW1zLnN0cm9rZVdpZHRoICogY29zKGFuZ2xlKSk7XG5cdFx0b2Zmc2V0WSA9IChwYXJhbXMuc3Ryb2tlV2lkdGggKiBzaW4oYW5nbGUpKTtcblxuXHRcdC8vIENhbGN1bGF0ZSBjb29yZGluYXRlcyBmb3IgbGVmdCBoYWxmIG9mIGFycm93XG5cdFx0bGVmdFggPSB4MiArIChwYXRoLmFycm93UmFkaXVzICogY29zKGFuZ2xlICsgKHBhdGguYXJyb3dBbmdsZSAvIDIpKSk7XG5cdFx0bGVmdFkgPSB5MiArIChwYXRoLmFycm93UmFkaXVzICogc2luKGFuZ2xlICsgKHBhdGguYXJyb3dBbmdsZSAvIDIpKSk7XG5cdFx0Ly8gQ2FsY3VsYXRlIGNvb3JkaW5hdGVzIGZvciByaWdodCBoYWxmIG9mIGFycm93XG5cdFx0cmlnaHRYID0geDIgKyAocGF0aC5hcnJvd1JhZGl1cyAqIGNvcyhhbmdsZSAtIChwYXRoLmFycm93QW5nbGUgLyAyKSkpO1xuXHRcdHJpZ2h0WSA9IHkyICsgKHBhdGguYXJyb3dSYWRpdXMgKiBzaW4oYW5nbGUgLSAocGF0aC5hcnJvd0FuZ2xlIC8gMikpKTtcblxuXHRcdC8vIERyYXcgbGVmdCBoYWxmIG9mIGFycm93XG5cdFx0Y3R4Lm1vdmVUbyhsZWZ0WCAtIG9mZnNldFgsIGxlZnRZIC0gb2Zmc2V0WSk7XG5cdFx0Y3R4LmxpbmVUbyh4MiAtIG9mZnNldFgsIHkyIC0gb2Zmc2V0WSk7XG5cdFx0Ly8gRHJhdyByaWdodCBoYWxmIG9mIGFycm93XG5cdFx0Y3R4LmxpbmVUbyhyaWdodFggLSBvZmZzZXRYLCByaWdodFkgLSBvZmZzZXRZKTtcblxuXHRcdC8vIFZpc3VhbGx5IGNvbm5lY3QgYXJyb3cgdG8gcGF0aFxuXHRcdGN0eC5tb3ZlVG8oeDIgLSBvZmZzZXRYLCB5MiAtIG9mZnNldFkpO1xuXHRcdGN0eC5saW5lVG8oeDIgKyBvZmZzZXRYLCB5MiArIG9mZnNldFkpO1xuXHRcdC8vIE1vdmUgYmFjayB0byBlbmQgb2YgcGF0aFxuXHRcdGN0eC5tb3ZlVG8oeDIsIHkyKTtcblxuXHR9XG59XG5cbi8vIE9wdGlvbmFsbHkgYWRkcyBhcnJvdyB0byBzdGFydCBvZiBwYXRoXG5mdW5jdGlvbiBfYWRkU3RhcnRBcnJvdyhjYW52YXMsIGN0eCwgcGFyYW1zLCBwYXRoLCB4MSwgeTEsIHgyLCB5Mikge1xuXHRpZiAoIXBhdGguX2Fycm93QW5nbGVDb252ZXJ0ZWQpIHtcblx0XHRwYXRoLmFycm93QW5nbGUgKj0gcGFyYW1zLl90b1JhZDtcblx0XHRwYXRoLl9hcnJvd0FuZ2xlQ29udmVydGVkID0gdHJ1ZTtcblx0fVxuXHRpZiAocGF0aC5zdGFydEFycm93KSB7XG5cdFx0X2FkZEFycm93KGNhbnZhcywgY3R4LCBwYXJhbXMsIHBhdGgsIHgxLCB5MSwgeDIsIHkyKTtcblx0fVxufVxuXG4vLyBPcHRpb25hbGx5IGFkZHMgYXJyb3cgdG8gZW5kIG9mIHBhdGhcbmZ1bmN0aW9uIF9hZGRFbmRBcnJvdyhjYW52YXMsIGN0eCwgcGFyYW1zLCBwYXRoLCB4MSwgeTEsIHgyLCB5Mikge1xuXHRpZiAoIXBhdGguX2Fycm93QW5nbGVDb252ZXJ0ZWQpIHtcblx0XHRwYXRoLmFycm93QW5nbGUgKj0gcGFyYW1zLl90b1JhZDtcblx0XHRwYXRoLl9hcnJvd0FuZ2xlQ29udmVydGVkID0gdHJ1ZTtcblx0fVxuXHRpZiAocGF0aC5lbmRBcnJvdykge1xuXHRcdF9hZGRBcnJvdyhjYW52YXMsIGN0eCwgcGFyYW1zLCBwYXRoLCB4MSwgeTEsIHgyLCB5Mik7XG5cdH1cbn1cblxuLy8gRHJhd3MgbGluZSAoaW50ZXJuYWwpXG5mdW5jdGlvbiBfZHJhd0xpbmUoY2FudmFzLCBjdHgsIHBhcmFtcywgcGF0aCkge1xuXHR2YXIgbCxcblx0XHRseCwgbHk7XG5cdGwgPSAyO1xuXHRfYWRkU3RhcnRBcnJvdyhcblx0XHRjYW52YXMsIGN0eCxcblx0XHRwYXJhbXMsIHBhdGgsXG5cdFx0cGF0aC54MiArIHBhcmFtcy54LFxuXHRcdHBhdGgueTIgKyBwYXJhbXMueSxcblx0XHRwYXRoLngxICsgcGFyYW1zLngsXG5cdFx0cGF0aC55MSArIHBhcmFtcy55XG5cdCk7XG5cdGlmIChwYXRoLngxICE9PSB1bmRlZmluZWQgJiYgcGF0aC55MSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Y3R4Lm1vdmVUbyhwYXRoLngxICsgcGFyYW1zLngsIHBhdGgueTEgKyBwYXJhbXMueSk7XG5cdH1cblx0d2hpbGUgKHRydWUpIHtcblx0XHQvLyBDYWxjdWxhdGUgbmV4dCBjb29yZGluYXRlc1xuXHRcdGx4ID0gcGF0aFsneCcgKyBsXTtcblx0XHRseSA9IHBhdGhbJ3knICsgbF07XG5cdFx0Ly8gSWYgY29vcmRpbmF0ZXMgYXJlIGdpdmVuXG5cdFx0aWYgKGx4ICE9PSB1bmRlZmluZWQgJiYgbHkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gRHJhdyBuZXh0IGxpbmVcblx0XHRcdGN0eC5saW5lVG8obHggKyBwYXJhbXMueCwgbHkgKyBwYXJhbXMueSk7XG5cdFx0XHRsICs9IDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIE90aGVyd2lzZSwgc3RvcCBkcmF3aW5nXG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblx0bCAtPSAxO1xuXHQvLyBPcHRpb25hbGx5IGFkZCBhcnJvd3MgdG8gcGF0aFxuXHRfYWRkRW5kQXJyb3coXG5cdFx0Y2FudmFzLCBjdHgsXG5cdFx0cGFyYW1zLFxuXHRcdHBhdGgsXG5cdFx0cGF0aFsneCcgKyAobCAtIDEpXSArIHBhcmFtcy54LFxuXHRcdHBhdGhbJ3knICsgKGwgLSAxKV0gKyBwYXJhbXMueSxcblx0XHRwYXRoWyd4JyArIGxdICsgcGFyYW1zLngsXG5cdFx0cGF0aFsneScgKyBsXSArIHBhcmFtcy55XG5cdCk7XG59XG5cbi8vIERyYXdzIGxpbmVcbiQuZm4uZHJhd0xpbmUgPSBmdW5jdGlvbiBkcmF3TGluZShhcmdzKSB7XG5cdHZhciAkY2FudmFzZXMgPSB0aGlzLCBlLCBjdHgsXG5cdFx0cGFyYW1zO1xuXG5cdGZvciAoZSA9IDA7IGUgPCAkY2FudmFzZXMubGVuZ3RoOyBlICs9IDEpIHtcblx0XHRjdHggPSBfZ2V0Q29udGV4dCgkY2FudmFzZXNbZV0pO1xuXHRcdGlmIChjdHgpIHtcblxuXHRcdFx0cGFyYW1zID0gbmV3IGpDYW52YXNPYmplY3QoYXJncyk7XG5cdFx0XHRfYWRkTGF5ZXIoJGNhbnZhc2VzW2VdLCBwYXJhbXMsIGFyZ3MsIGRyYXdMaW5lKTtcblx0XHRcdGlmIChwYXJhbXMudmlzaWJsZSkge1xuXG5cdFx0XHRcdF90cmFuc2Zvcm1TaGFwZSgkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zKTtcblx0XHRcdFx0X3NldEdsb2JhbFByb3BzKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMpO1xuXG5cdFx0XHRcdC8vIERyYXcgZWFjaCBwb2ludFxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdF9kcmF3TGluZSgkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zLCBwYXJhbXMpO1xuXHRcdFx0XHQvLyBDaGVjayBmb3IgakNhbnZhcyBldmVudHNcblx0XHRcdFx0X2RldGVjdEV2ZW50cygkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zKTtcblx0XHRcdFx0Ly8gT3B0aW9uYWxseSBjbG9zZSBwYXRoXG5cdFx0XHRcdF9jbG9zZVBhdGgoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcyk7XG5cblx0XHRcdH1cblxuXHRcdH1cblx0fVxuXHRyZXR1cm4gJGNhbnZhc2VzO1xufTtcblxuLy8gRHJhd3MgcXVhZHJhdGljIGN1cnZlIChpbnRlcm5hbClcbmZ1bmN0aW9uIF9kcmF3UXVhZHJhdGljKGNhbnZhcywgY3R4LCBwYXJhbXMsIHBhdGgpIHtcblx0dmFyIGwsXG5cdFx0bHgsIGx5LFxuXHRcdGxjeCwgbGN5O1xuXG5cdGwgPSAyO1xuXG5cdF9hZGRTdGFydEFycm93KFxuXHRcdGNhbnZhcyxcblx0XHRjdHgsXG5cdFx0cGFyYW1zLFxuXHRcdHBhdGgsXG5cdFx0cGF0aC5jeDEgKyBwYXJhbXMueCxcblx0XHRwYXRoLmN5MSArIHBhcmFtcy55LFxuXHRcdHBhdGgueDEgKyBwYXJhbXMueCxcblx0XHRwYXRoLnkxICsgcGFyYW1zLnlcblx0KTtcblxuXHRpZiAocGF0aC54MSAhPT0gdW5kZWZpbmVkICYmIHBhdGgueTEgIT09IHVuZGVmaW5lZCkge1xuXHRcdGN0eC5tb3ZlVG8ocGF0aC54MSArIHBhcmFtcy54LCBwYXRoLnkxICsgcGFyYW1zLnkpO1xuXHR9XG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0Ly8gQ2FsY3VsYXRlIG5leHQgY29vcmRpbmF0ZXNcblx0XHRseCA9IHBhdGhbJ3gnICsgbF07XG5cdFx0bHkgPSBwYXRoWyd5JyArIGxdO1xuXHRcdGxjeCA9IHBhdGhbJ2N4JyArIChsIC0gMSldO1xuXHRcdGxjeSA9IHBhdGhbJ2N5JyArIChsIC0gMSldO1xuXHRcdC8vIElmIGNvb3JkaW5hdGVzIGFyZSBnaXZlblxuXHRcdGlmIChseCAhPT0gdW5kZWZpbmVkICYmIGx5ICE9PSB1bmRlZmluZWQgJiYgbGN4ICE9PSB1bmRlZmluZWQgJiYgbGN5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIERyYXcgbmV4dCBjdXJ2ZVxuXHRcdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8obGN4ICsgcGFyYW1zLngsIGxjeSArIHBhcmFtcy55LCBseCArIHBhcmFtcy54LCBseSArIHBhcmFtcy55KTtcblx0XHRcdGwgKz0gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBzdG9wIGRyYXdpbmdcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXHRsIC09IDE7XG5cdF9hZGRFbmRBcnJvdyhcblx0XHRjYW52YXMsXG5cdFx0Y3R4LFxuXHRcdHBhcmFtcyxcblx0XHRwYXRoLFxuXHRcdHBhdGhbJ2N4JyArIChsIC0gMSldICsgcGFyYW1zLngsXG5cdFx0cGF0aFsnY3knICsgKGwgLSAxKV0gKyBwYXJhbXMueSxcblx0XHRwYXRoWyd4JyArIGxdICsgcGFyYW1zLngsXG5cdFx0cGF0aFsneScgKyBsXSArIHBhcmFtcy55XG5cdCk7XG59XG5cbi8vIERyYXdzIHF1YWRyYXRpYyBjdXJ2ZVxuJC5mbi5kcmF3UXVhZHJhdGljID0gZnVuY3Rpb24gZHJhd1F1YWRyYXRpYyhhcmdzKSB7XG5cdHZhciAkY2FudmFzZXMgPSB0aGlzLCBlLCBjdHgsXG5cdFx0cGFyYW1zO1xuXG5cdGZvciAoZSA9IDA7IGUgPCAkY2FudmFzZXMubGVuZ3RoOyBlICs9IDEpIHtcblx0XHRjdHggPSBfZ2V0Q29udGV4dCgkY2FudmFzZXNbZV0pO1xuXHRcdGlmIChjdHgpIHtcblxuXHRcdFx0cGFyYW1zID0gbmV3IGpDYW52YXNPYmplY3QoYXJncyk7XG5cdFx0XHRfYWRkTGF5ZXIoJGNhbnZhc2VzW2VdLCBwYXJhbXMsIGFyZ3MsIGRyYXdRdWFkcmF0aWMpO1xuXHRcdFx0aWYgKHBhcmFtcy52aXNpYmxlKSB7XG5cblx0XHRcdFx0X3RyYW5zZm9ybVNoYXBlKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMpO1xuXHRcdFx0XHRfc2V0R2xvYmFsUHJvcHMoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcyk7XG5cblx0XHRcdFx0Ly8gRHJhdyBlYWNoIHBvaW50XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0X2RyYXdRdWFkcmF0aWMoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcywgcGFyYW1zKTtcblx0XHRcdFx0Ly8gQ2hlY2sgZm9yIGpDYW52YXMgZXZlbnRzXG5cdFx0XHRcdF9kZXRlY3RFdmVudHMoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcyk7XG5cdFx0XHRcdC8vIE9wdGlvbmFsbHkgY2xvc2UgcGF0aFxuXHRcdFx0XHRfY2xvc2VQYXRoKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMpO1xuXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiAkY2FudmFzZXM7XG59O1xuXG4vLyBEcmF3cyBCZXppZXIgY3VydmUgKGludGVybmFsKVxuZnVuY3Rpb24gX2RyYXdCZXppZXIoY2FudmFzLCBjdHgsIHBhcmFtcywgcGF0aCkge1xuXHR2YXIgbCwgbGMsXG5cdFx0bHgsIGx5LFxuXHRcdGxjeDEsIGxjeTEsXG5cdFx0bGN4MiwgbGN5MjtcblxuXHRsID0gMjtcblx0bGMgPSAxO1xuXG5cdF9hZGRTdGFydEFycm93KFxuXHRcdGNhbnZhcyxcblx0XHRjdHgsXG5cdFx0cGFyYW1zLFxuXHRcdHBhdGgsXG5cdFx0cGF0aC5jeDEgKyBwYXJhbXMueCxcblx0XHRwYXRoLmN5MSArIHBhcmFtcy55LFxuXHRcdHBhdGgueDEgKyBwYXJhbXMueCxcblx0XHRwYXRoLnkxICsgcGFyYW1zLnlcblx0KTtcblxuXHRpZiAocGF0aC54MSAhPT0gdW5kZWZpbmVkICYmIHBhdGgueTEgIT09IHVuZGVmaW5lZCkge1xuXHRcdGN0eC5tb3ZlVG8ocGF0aC54MSArIHBhcmFtcy54LCBwYXRoLnkxICsgcGFyYW1zLnkpO1xuXHR9XG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0Ly8gQ2FsY3VsYXRlIG5leHQgY29vcmRpbmF0ZXNcblx0XHRseCA9IHBhdGhbJ3gnICsgbF07XG5cdFx0bHkgPSBwYXRoWyd5JyArIGxdO1xuXHRcdGxjeDEgPSBwYXRoWydjeCcgKyBsY107XG5cdFx0bGN5MSA9IHBhdGhbJ2N5JyArIGxjXTtcblx0XHRsY3gyID0gcGF0aFsnY3gnICsgKGxjICsgMSldO1xuXHRcdGxjeTIgPSBwYXRoWydjeScgKyAobGMgKyAxKV07XG5cdFx0Ly8gSWYgbmV4dCBjb29yZGluYXRlcyBhcmUgZ2l2ZW5cblx0XHRpZiAobHggIT09IHVuZGVmaW5lZCAmJiBseSAhPT0gdW5kZWZpbmVkICYmIGxjeDEgIT09IHVuZGVmaW5lZCAmJiBsY3kxICE9PSB1bmRlZmluZWQgJiYgbGN4MiAhPT0gdW5kZWZpbmVkICYmIGxjeTIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gRHJhdyBuZXh0IGN1cnZlXG5cdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhsY3gxICsgcGFyYW1zLngsIGxjeTEgKyBwYXJhbXMueSwgbGN4MiArIHBhcmFtcy54LCBsY3kyICsgcGFyYW1zLnksIGx4ICsgcGFyYW1zLngsIGx5ICsgcGFyYW1zLnkpO1xuXHRcdFx0bCArPSAxO1xuXHRcdFx0bGMgKz0gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBzdG9wIGRyYXdpbmdcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXHRsIC09IDE7XG5cdGxjIC09IDI7XG5cdF9hZGRFbmRBcnJvdyhcblx0XHRjYW52YXMsXG5cdFx0Y3R4LFxuXHRcdHBhcmFtcyxcblx0XHRwYXRoLFxuXHRcdHBhdGhbJ2N4JyArIChsYyArIDEpXSArIHBhcmFtcy54LFxuXHRcdHBhdGhbJ2N5JyArIChsYyArIDEpXSArIHBhcmFtcy55LFxuXHRcdHBhdGhbJ3gnICsgbF0gKyBwYXJhbXMueCxcblx0XHRwYXRoWyd5JyArIGxdICsgcGFyYW1zLnlcblx0KTtcbn1cblxuLy8gRHJhd3MgQmV6aWVyIGN1cnZlXG4kLmZuLmRyYXdCZXppZXIgPSBmdW5jdGlvbiBkcmF3QmV6aWVyKGFyZ3MpIHtcblx0dmFyICRjYW52YXNlcyA9IHRoaXMsIGUsIGN0eCxcblx0XHRwYXJhbXM7XG5cblx0Zm9yIChlID0gMDsgZSA8ICRjYW52YXNlcy5sZW5ndGg7IGUgKz0gMSkge1xuXHRcdGN0eCA9IF9nZXRDb250ZXh0KCRjYW52YXNlc1tlXSk7XG5cdFx0aWYgKGN0eCkge1xuXG5cdFx0XHRwYXJhbXMgPSBuZXcgakNhbnZhc09iamVjdChhcmdzKTtcblx0XHRcdF9hZGRMYXllcigkY2FudmFzZXNbZV0sIHBhcmFtcywgYXJncywgZHJhd0Jlemllcik7XG5cdFx0XHRpZiAocGFyYW1zLnZpc2libGUpIHtcblxuXHRcdFx0XHRfdHJhbnNmb3JtU2hhcGUoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcyk7XG5cdFx0XHRcdF9zZXRHbG9iYWxQcm9wcygkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zKTtcblxuXHRcdFx0XHQvLyBEcmF3IGVhY2ggcG9pbnRcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRfZHJhd0JlemllcigkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zLCBwYXJhbXMpO1xuXHRcdFx0XHQvLyBDaGVjayBmb3IgakNhbnZhcyBldmVudHNcblx0XHRcdFx0X2RldGVjdEV2ZW50cygkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zKTtcblx0XHRcdFx0Ly8gT3B0aW9uYWxseSBjbG9zZSBwYXRoXG5cdFx0XHRcdF9jbG9zZVBhdGgoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcyk7XG5cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuICRjYW52YXNlcztcbn07XG5cbi8vIFJldHJpZXZlcyB0aGUgeC1jb29yZGluYXRlIGZvciB0aGUgZ2l2ZW4gdmVjdG9yIGFuZ2xlIGFuZCBsZW5ndGhcbmZ1bmN0aW9uIF9nZXRWZWN0b3JYKHBhcmFtcywgYW5nbGUsIGxlbmd0aCkge1xuXHRhbmdsZSAqPSBwYXJhbXMuX3RvUmFkO1xuXHRhbmdsZSAtPSAoUEkgLyAyKTtcblx0cmV0dXJuIChsZW5ndGggKiBjb3MoYW5nbGUpKTtcbn1cbi8vIFJldHJpZXZlcyB0aGUgeS1jb29yZGluYXRlIGZvciB0aGUgZ2l2ZW4gdmVjdG9yIGFuZ2xlIGFuZCBsZW5ndGhcbmZ1bmN0aW9uIF9nZXRWZWN0b3JZKHBhcmFtcywgYW5nbGUsIGxlbmd0aCkge1xuXHRhbmdsZSAqPSBwYXJhbXMuX3RvUmFkO1xuXHRhbmdsZSAtPSAoUEkgLyAyKTtcblx0cmV0dXJuIChsZW5ndGggKiBzaW4oYW5nbGUpKTtcbn1cblxuLy8gRHJhd3MgdmVjdG9yIChpbnRlcm5hbCkgIzJcbmZ1bmN0aW9uIF9kcmF3VmVjdG9yKGNhbnZhcywgY3R4LCBwYXJhbXMsIHBhdGgpIHtcblx0dmFyIGwsIGFuZ2xlLCBsZW5ndGgsXG5cdFx0b2Zmc2V0WCwgb2Zmc2V0WSxcblx0XHR4LCB5LFxuXHRcdHgzLCB5Myxcblx0XHR4NCwgeTQ7XG5cblx0Ly8gRGV0ZXJtaW5lIG9mZnNldCBmcm9tIGRyYWdnaW5nXG5cdGlmIChwYXJhbXMgPT09IHBhdGgpIHtcblx0XHRvZmZzZXRYID0gMDtcblx0XHRvZmZzZXRZID0gMDtcblx0fSBlbHNlIHtcblx0XHRvZmZzZXRYID0gcGFyYW1zLng7XG5cdFx0b2Zmc2V0WSA9IHBhcmFtcy55O1xuXHR9XG5cblx0bCA9IDE7XG5cdHggPSB4MyA9IHg0ID0gcGF0aC54ICsgb2Zmc2V0WDtcblx0eSA9IHkzID0geTQgPSBwYXRoLnkgKyBvZmZzZXRZO1xuXG5cdF9hZGRTdGFydEFycm93KFxuXHRcdGNhbnZhcywgY3R4LFxuXHRcdHBhcmFtcywgcGF0aCxcblx0XHR4ICsgX2dldFZlY3RvclgocGFyYW1zLCBwYXRoLmExLCBwYXRoLmwxKSxcblx0XHR5ICsgX2dldFZlY3RvclkocGFyYW1zLCBwYXRoLmExLCBwYXRoLmwxKSxcblx0XHR4LFxuXHRcdHlcblx0KTtcblxuXHQvLyBUaGUgdmVjdG9yIHN0YXJ0cyBhdCB0aGUgZ2l2ZW4gKHgsIHkpIGNvb3JkaW5hdGVzXG5cdGlmIChwYXRoLnggIT09IHVuZGVmaW5lZCAmJiBwYXRoLnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdGN0eC5tb3ZlVG8oeCwgeSk7XG5cdH1cblx0d2hpbGUgKHRydWUpIHtcblxuXHRcdGFuZ2xlID0gcGF0aFsnYScgKyBsXTtcblx0XHRsZW5ndGggPSBwYXRoWydsJyArIGxdO1xuXG5cdFx0aWYgKGFuZ2xlICE9PSB1bmRlZmluZWQgJiYgbGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIENvbnZlcnQgdGhlIGFuZ2xlIHRvIHJhZGlhbnMgd2l0aCAwIGRlZ3JlZXMgc3RhcnRpbmcgYXQgbm9ydGhcblx0XHRcdC8vIEtlZXAgdHJhY2sgb2YgbGFzdCB0d28gY29vcmRpbmF0ZXNcblx0XHRcdHgzID0geDQ7XG5cdFx0XHR5MyA9IHk0O1xuXHRcdFx0Ly8gQ29tcHV0ZSAoeCwgeSkgY29vcmRpbmF0ZXMgZnJvbSBhbmdsZSBhbmQgbGVuZ3RoXG5cdFx0XHR4NCArPSBfZ2V0VmVjdG9yWChwYXJhbXMsIGFuZ2xlLCBsZW5ndGgpO1xuXHRcdFx0eTQgKz0gX2dldFZlY3RvclkocGFyYW1zLCBhbmdsZSwgbGVuZ3RoKTtcblx0XHRcdGN0eC5saW5lVG8oeDQsIHk0KTtcblx0XHRcdGwgKz0gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBzdG9wIGRyYXdpbmdcblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHR9XG5cdF9hZGRFbmRBcnJvdyhcblx0XHRjYW52YXMsIGN0eCxcblx0XHRwYXJhbXMsIHBhdGgsXG5cdFx0eDMsIHkzLFxuXHRcdHg0LCB5NFxuXHQpO1xufVxuXG4vLyBEcmF3cyB2ZWN0b3JcbiQuZm4uZHJhd1ZlY3RvciA9IGZ1bmN0aW9uIGRyYXdWZWN0b3IoYXJncykge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgZSwgY3R4LFxuXHRcdHBhcmFtcztcblxuXHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0Y3R4ID0gX2dldENvbnRleHQoJGNhbnZhc2VzW2VdKTtcblx0XHRpZiAoY3R4KSB7XG5cblx0XHRcdHBhcmFtcyA9IG5ldyBqQ2FudmFzT2JqZWN0KGFyZ3MpO1xuXHRcdFx0X2FkZExheWVyKCRjYW52YXNlc1tlXSwgcGFyYW1zLCBhcmdzLCBkcmF3VmVjdG9yKTtcblx0XHRcdGlmIChwYXJhbXMudmlzaWJsZSkge1xuXG5cdFx0XHRcdF90cmFuc2Zvcm1TaGFwZSgkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zKTtcblx0XHRcdFx0X3NldEdsb2JhbFByb3BzKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMpO1xuXG5cdFx0XHRcdC8vIERyYXcgZWFjaCBwb2ludFxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdF9kcmF3VmVjdG9yKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMsIHBhcmFtcyk7XG5cdFx0XHRcdC8vIENoZWNrIGZvciBqQ2FudmFzIGV2ZW50c1xuXHRcdFx0XHRfZGV0ZWN0RXZlbnRzKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMpO1xuXHRcdFx0XHQvLyBPcHRpb25hbGx5IGNsb3NlIHBhdGhcblx0XHRcdFx0X2Nsb3NlUGF0aCgkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zKTtcblxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gJGNhbnZhc2VzO1xufTtcblxuLy8gRHJhd3MgYSBwYXRoIGNvbnNpc3Rpbmcgb2Ygb25lIG9yIG1vcmUgc3VicGF0aHNcbiQuZm4uZHJhd1BhdGggPSBmdW5jdGlvbiBkcmF3UGF0aChhcmdzKSB7XG5cdHZhciAkY2FudmFzZXMgPSB0aGlzLCBlLCBjdHgsXG5cdFx0cGFyYW1zLFxuXHRcdGwsIGxwO1xuXG5cdGZvciAoZSA9IDA7IGUgPCAkY2FudmFzZXMubGVuZ3RoOyBlICs9IDEpIHtcblx0XHRjdHggPSBfZ2V0Q29udGV4dCgkY2FudmFzZXNbZV0pO1xuXHRcdGlmIChjdHgpIHtcblxuXHRcdFx0cGFyYW1zID0gbmV3IGpDYW52YXNPYmplY3QoYXJncyk7XG5cdFx0XHRfYWRkTGF5ZXIoJGNhbnZhc2VzW2VdLCBwYXJhbXMsIGFyZ3MsIGRyYXdQYXRoKTtcblx0XHRcdGlmIChwYXJhbXMudmlzaWJsZSkge1xuXG5cdFx0XHRcdF90cmFuc2Zvcm1TaGFwZSgkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zKTtcblx0XHRcdFx0X3NldEdsb2JhbFByb3BzKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMpO1xuXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0bCA9IDE7XG5cdFx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdFx0bHAgPSBwYXJhbXNbJ3AnICsgbF07XG5cdFx0XHRcdFx0aWYgKGxwICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGxwID0gbmV3IGpDYW52YXNPYmplY3QobHApO1xuXHRcdFx0XHRcdFx0aWYgKGxwLnR5cGUgPT09ICdsaW5lJykge1xuXHRcdFx0XHRcdFx0XHRfZHJhd0xpbmUoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcywgbHApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChscC50eXBlID09PSAncXVhZHJhdGljJykge1xuXHRcdFx0XHRcdFx0XHRfZHJhd1F1YWRyYXRpYygkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zLCBscCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGxwLnR5cGUgPT09ICdiZXppZXInKSB7XG5cdFx0XHRcdFx0XHRcdF9kcmF3QmV6aWVyKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMsIGxwKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobHAudHlwZSA9PT0gJ3ZlY3RvcicpIHtcblx0XHRcdFx0XHRcdFx0X2RyYXdWZWN0b3IoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcywgbHApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChscC50eXBlID09PSAnYXJjJykge1xuXHRcdFx0XHRcdFx0XHRfZHJhd0FyYygkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zLCBscCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRsICs9IDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENoZWNrIGZvciBqQ2FudmFzIGV2ZW50c1xuXHRcdFx0XHRfZGV0ZWN0RXZlbnRzKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMpO1xuXHRcdFx0XHQvLyBPcHRpb25hbGx5IGNsb3NlIHBhdGhcblx0XHRcdFx0X2Nsb3NlUGF0aCgkY2FudmFzZXNbZV0sIGN0eCwgcGFyYW1zKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXHR9XG5cdHJldHVybiAkY2FudmFzZXM7XG59O1xuXG4vKiBUZXh0IEFQSSAqL1xuXG4vLyBDYWxjdWxhdGVzIGZvbnQgc3RyaW5nIGFuZCBzZXQgaXQgYXMgdGhlIGNhbnZhcyBmb250XG5mdW5jdGlvbiBfc2V0Q2FudmFzRm9udChjYW52YXMsIGN0eCwgcGFyYW1zKSB7XG5cdC8vIE90aGVyd2lzZSwgdXNlIHRoZSBnaXZlbiBmb250IGF0dHJpYnV0ZXNcblx0aWYgKCFpc05hTihOdW1iZXIocGFyYW1zLmZvbnRTaXplKSkpIHtcblx0XHQvLyBHaXZlIGZvbnQgc2l6ZSB1bml0cyBpZiBpdCBkb2Vzbid0IGhhdmUgYW55XG5cdFx0cGFyYW1zLmZvbnRTaXplICs9ICdweCc7XG5cdH1cblx0Ly8gU2V0IGZvbnQgdXNpbmcgZ2l2ZW4gZm9udCBwcm9wZXJ0aWVzXG5cdGN0eC5mb250ID0gcGFyYW1zLmZvbnRTdHlsZSArICcgJyArIHBhcmFtcy5mb250U2l6ZSArICcgJyArIHBhcmFtcy5mb250RmFtaWx5O1xufVxuXG4vLyBNZWFzdXJlcyBjYW52YXMgdGV4dFxuZnVuY3Rpb24gX21lYXN1cmVUZXh0KGNhbnZhcywgY3R4LCBwYXJhbXMsIGxpbmVzKSB7XG5cdHZhciBvcmlnaW5hbFNpemUsIGN1cldpZHRoLCBsLFxuXHRcdHByb3BDYWNoZSA9IGNhY2hlcy5wcm9wQ2FjaGU7XG5cblx0Ly8gVXNlZCBjYWNoZWQgd2lkdGgvaGVpZ2h0IGlmIHBvc3NpYmxlXG5cdGlmIChwcm9wQ2FjaGUudGV4dCA9PT0gcGFyYW1zLnRleHQgJiYgcHJvcENhY2hlLmZvbnRTdHlsZSA9PT0gcGFyYW1zLmZvbnRTdHlsZSAmJiBwcm9wQ2FjaGUuZm9udFNpemUgPT09IHBhcmFtcy5mb250U2l6ZSAmJiBwcm9wQ2FjaGUuZm9udEZhbWlseSA9PT0gcGFyYW1zLmZvbnRGYW1pbHkgJiYgcHJvcENhY2hlLm1heFdpZHRoID09PSBwYXJhbXMubWF4V2lkdGggJiYgcHJvcENhY2hlLmxpbmVIZWlnaHQgPT09IHBhcmFtcy5saW5lSGVpZ2h0KSB7XG5cblx0XHRwYXJhbXMud2lkdGggPSBwcm9wQ2FjaGUud2lkdGg7XG5cdFx0cGFyYW1zLmhlaWdodCA9IHByb3BDYWNoZS5oZWlnaHQ7XG5cblx0fSBlbHNlIHtcblx0XHQvLyBDYWxjdWxhdGUgdGV4dCBkaW1lbnNpb25zIG9ubHkgb25jZVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHdpZHRoIG9mIGZpcnN0IGxpbmUgKGZvciBjb21wYXJpc29uKVxuXHRcdHBhcmFtcy53aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsaW5lc1swXSkud2lkdGg7XG5cblx0XHQvLyBHZXQgd2lkdGggb2YgbG9uZ2VzdCBsaW5lXG5cdFx0Zm9yIChsID0gMTsgbCA8IGxpbmVzLmxlbmd0aDsgbCArPSAxKSB7XG5cblx0XHRcdGN1cldpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmVzW2xdKS53aWR0aDtcblx0XHRcdC8vIEVuc3VyZSB0ZXh0J3Mgd2lkdGggaXMgdGhlIHdpZHRoIG9mIGl0cyBsb25nZXN0IGxpbmVcblx0XHRcdGlmIChjdXJXaWR0aCA+IHBhcmFtcy53aWR0aCkge1xuXHRcdFx0XHRwYXJhbXMud2lkdGggPSBjdXJXaWR0aDtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIFNhdmUgb3JpZ2luYWwgZm9udCBzaXplXG5cdFx0b3JpZ2luYWxTaXplID0gY2FudmFzLnN0eWxlLmZvbnRTaXplO1xuXHRcdC8vIFRlbXBvcmFyaWx5IHNldCBjYW52YXMgZm9udCBzaXplIHRvIHJldHJpZXZlIHNpemUgaW4gcGl4ZWxzXG5cdFx0Y2FudmFzLnN0eWxlLmZvbnRTaXplID0gcGFyYW1zLmZvbnRTaXplO1xuXHRcdC8vIFNhdmUgdGV4dCB3aWR0aCBhbmQgaGVpZ2h0IGluIHBhcmFtZXRlcnMgb2JqZWN0XG5cdFx0cGFyYW1zLmhlaWdodCA9IHBhcnNlRmxvYXQoJC5jc3MoY2FudmFzLCAnZm9udFNpemUnKSkgKiBsaW5lcy5sZW5ndGggKiBwYXJhbXMubGluZUhlaWdodDtcblx0XHQvLyBSZXNldCBmb250IHNpemUgdG8gb3JpZ2luYWwgc2l6ZVxuXHRcdGNhbnZhcy5zdHlsZS5mb250U2l6ZSA9IG9yaWdpbmFsU2l6ZTtcblx0fVxufVxuXG4vLyBXcmFwcyBhIHN0cmluZyBvZiB0ZXh0IHdpdGhpbiBhIGRlZmluZWQgd2lkdGhcbmZ1bmN0aW9uIF93cmFwVGV4dChjdHgsIHBhcmFtcykge1xuXHR2YXIgYWxsVGV4dCA9IFN0cmluZyhwYXJhbXMudGV4dCksXG5cdFx0Ly8gTWF4aW11bSBsaW5lIHdpZHRoIChvcHRpb25hbClcblx0XHRtYXhXaWR0aCA9IHBhcmFtcy5tYXhXaWR0aCxcblx0XHQvLyBMaW5lcyBjcmVhdGVkIGJ5IG1hbnVhbCBsaW5lIGJyZWFrcyAoXFxuKVxuXHRcdG1hbnVhbExpbmVzID0gYWxsVGV4dC5zcGxpdCgnXFxuJyksXG5cdFx0Ly8gQWxsIGxpbmVzIGNyZWF0ZWQgbWFudWFsbHkgYW5kIGJ5IHdyYXBwaW5nXG5cdFx0YWxsTGluZXMgPSBbXSxcblx0XHQvLyBPdGhlciB2YXJpYWJsZXNcblx0XHRsaW5lcywgbGluZSwgbCxcblx0XHR0ZXh0LCB3b3JkcywgdztcblxuXHQvLyBMb29wIHRocm91Z2ggbWFudWFsbHktYnJva2VuIGxpbmVzXG5cdGZvciAobCA9IDA7IGwgPCBtYW51YWxMaW5lcy5sZW5ndGg7IGwgKz0gMSkge1xuXG5cdFx0dGV4dCA9IG1hbnVhbExpbmVzW2xdO1xuXHRcdC8vIFNwbGl0IGxpbmUgaW50byBsaXN0IG9mIHdvcmRzXG5cdFx0d29yZHMgPSB0ZXh0LnNwbGl0KCcgJyk7XG5cdFx0bGluZXMgPSBbXTtcblx0XHRsaW5lID0gJyc7XG5cblx0XHQvLyBJZiB0ZXh0IGlzIHNob3J0IGVub3VnaCBpbml0aWFsbHlcblx0XHQvLyBPciwgaWYgdGhlIHRleHQgY29uc2lzdHMgb2Ygb25seSBvbmUgd29yZFxuXHRcdGlmICh3b3Jkcy5sZW5ndGggPT09IDEgfHwgY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoIDwgbWF4V2lkdGgpIHtcblxuXHRcdFx0Ly8gTm8gbmVlZCB0byB3cmFwIHRleHRcblx0XHRcdGxpbmVzID0gW3RleHRdO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gV3JhcCBsaW5lc1xuXHRcdFx0Zm9yICh3ID0gMDsgdyA8IHdvcmRzLmxlbmd0aDsgdyArPSAxKSB7XG5cblx0XHRcdFx0Ly8gT25jZSBsaW5lIGdldHMgdG9vIHdpZGUsIHB1c2ggd29yZCB0byBuZXh0IGxpbmVcblx0XHRcdFx0aWYgKGN0eC5tZWFzdXJlVGV4dChsaW5lICsgd29yZHNbd10pLndpZHRoID4gbWF4V2lkdGgpIHtcblx0XHRcdFx0XHQvLyBUaGlzIGNoZWNrIHByZXZlbnRzIGVtcHR5IGxpbmVzIGZyb20gYmVpbmcgY3JlYXRlZFxuXHRcdFx0XHRcdGlmIChsaW5lICE9PSAnJykge1xuXHRcdFx0XHRcdFx0bGluZXMucHVzaChsaW5lKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gU3RhcnQgbmV3IGxpbmUgYW5kIHJlcGVhdCBwcm9jZXNzXG5cdFx0XHRcdFx0bGluZSA9ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIEFkZCB3b3JkcyB0byBsaW5lIHVudGlsIHRoZSBsaW5lIGlzIHRvbyB3aWRlXG5cdFx0XHRcdGxpbmUgKz0gd29yZHNbd107XG5cdFx0XHRcdC8vIERvIG5vdCBhZGQgYSBzcGFjZSBhZnRlciB0aGUgbGFzdCB3b3JkXG5cdFx0XHRcdGlmICh3ICE9PSAod29yZHMubGVuZ3RoIC0gMSkpIHtcblx0XHRcdFx0XHRsaW5lICs9ICcgJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gVGhlIGxhc3Qgd29yZCBzaG91bGQgYWx3YXlzIGJlIHB1c2hlZFxuXHRcdFx0bGluZXMucHVzaChsaW5lKTtcblxuXHRcdH1cblx0XHQvLyBSZW1vdmUgZXh0cmEgc3BhY2UgYXQgdGhlIGVuZCBvZiBlYWNoIGxpbmVcblx0XHRhbGxMaW5lcyA9IGFsbExpbmVzLmNvbmNhdChcblx0XHRcdGxpbmVzXG5cdFx0XHQuam9pbignXFxuJylcblx0XHRcdC5yZXBsYWNlKC8oKFxcbikpfCgkKS9naSwgJyQyJylcblx0XHRcdC5zcGxpdCgnXFxuJylcblx0XHQpO1xuXG5cdH1cblxuXHRyZXR1cm4gYWxsTGluZXM7XG59XG5cbi8vIERyYXdzIHRleHQgb24gY2FudmFzXG4kLmZuLmRyYXdUZXh0ID0gZnVuY3Rpb24gZHJhd1RleHQoYXJncykge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgZSwgY3R4LFxuXHRcdHBhcmFtcywgbGF5ZXIsXG5cdFx0bGluZXMsIGxpbmUsIGwsXG5cdFx0Zm9udFNpemUsIGNvbnN0YW50Q2xvc2VuZXNzID0gNTAwLFxuXHRcdG5jaGFycywgY2hhcnMsIGNoLCBjLFxuXHRcdHgsIHk7XG5cblx0Zm9yIChlID0gMDsgZSA8ICRjYW52YXNlcy5sZW5ndGg7IGUgKz0gMSkge1xuXHRcdGN0eCA9IF9nZXRDb250ZXh0KCRjYW52YXNlc1tlXSk7XG5cdFx0aWYgKGN0eCkge1xuXG5cdFx0XHRwYXJhbXMgPSBuZXcgakNhbnZhc09iamVjdChhcmdzKTtcblx0XHRcdF9hZGRMYXllcigkY2FudmFzZXNbZV0sIHBhcmFtcywgYXJncywgZHJhd1RleHQpO1xuXHRcdFx0aWYgKHBhcmFtcy52aXNpYmxlKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRleHQtc3BlY2lmaWMgcHJvcGVydGllc1xuXHRcdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gcGFyYW1zLmJhc2VsaW5lO1xuXHRcdFx0XHRjdHgudGV4dEFsaWduID0gcGFyYW1zLmFsaWduO1xuXG5cdFx0XHRcdC8vIFNldCBjYW52YXMgZm9udCB1c2luZyBnaXZlbiBwcm9wZXJ0aWVzXG5cdFx0XHRcdF9zZXRDYW52YXNGb250KCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMpO1xuXG5cdFx0XHRcdGlmIChwYXJhbXMubWF4V2lkdGggIT09IG51bGwpIHtcblx0XHRcdFx0XHQvLyBXcmFwIHRleHQgdXNpbmcgYW4gaW50ZXJuYWwgZnVuY3Rpb25cblx0XHRcdFx0XHRsaW5lcyA9IF93cmFwVGV4dChjdHgsIHBhcmFtcyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQ29udmVydCBzdHJpbmcgb2YgdGV4dCB0byBsaXN0IG9mIGxpbmVzXG5cdFx0XHRcdFx0bGluZXMgPSBwYXJhbXMudGV4dFxuXHRcdFx0XHRcdC50b1N0cmluZygpXG5cdFx0XHRcdFx0LnNwbGl0KCdcXG4nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGN1bGF0ZSB0ZXh0J3Mgd2lkdGggYW5kIGhlaWdodFxuXHRcdFx0XHRfbWVhc3VyZVRleHQoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcywgbGluZXMpO1xuXG5cdFx0XHRcdC8vIElmIHRleHQgaXMgYSBsYXllclxuXHRcdFx0XHRpZiAobGF5ZXIpIHtcblx0XHRcdFx0XHQvLyBDb3B5IGNhbGN1bGF0ZWQgd2lkdGgvaGVpZ2h0IHRvIGxheWVyIG9iamVjdFxuXHRcdFx0XHRcdGxheWVyLndpZHRoID0gcGFyYW1zLndpZHRoO1xuXHRcdFx0XHRcdGxheWVyLmhlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfdHJhbnNmb3JtU2hhcGUoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcywgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcblx0XHRcdFx0X3NldEdsb2JhbFByb3BzKCRjYW52YXNlc1tlXSwgY3R4LCBwYXJhbXMpO1xuXG5cdFx0XHRcdC8vIEFkanVzdCB0ZXh0IHBvc2l0aW9uIHRvIGFjY29tb2RhdGUgZGlmZmVyZW50IGhvcml6b250YWwgYWxpZ25tZW50c1xuXHRcdFx0XHR4ID0gcGFyYW1zLng7XG5cdFx0XHRcdGlmIChwYXJhbXMuYWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0XHRcdGlmIChwYXJhbXMucmVzcGVjdEFsaWduKSB7XG5cdFx0XHRcdFx0XHQvLyBSZWFsaWduIHRleHQgdG8gdGhlIGxlZnQgaWYgY2hvc2VuXG5cdFx0XHRcdFx0XHRwYXJhbXMueCArPSBwYXJhbXMud2lkdGggLyAyO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBDZW50ZXIgdGV4dCBibG9jayBieSBkZWZhdWx0XG5cdFx0XHRcdFx0XHR4IC09IHBhcmFtcy53aWR0aCAvIDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHBhcmFtcy5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0XHRcdGlmIChwYXJhbXMucmVzcGVjdEFsaWduKSB7XG5cdFx0XHRcdFx0XHQvLyBSZWFsaWduIHRleHQgdG8gdGhlIHJpZ2h0IGlmIGNob3NlblxuXHRcdFx0XHRcdFx0cGFyYW1zLnggLT0gcGFyYW1zLndpZHRoIC8gMjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gQ2VudGVyIHRleHQgYmxvY2sgYnkgZGVmYXVsdFxuXHRcdFx0XHRcdFx0eCArPSBwYXJhbXMud2lkdGggLyAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChwYXJhbXMucmFkaXVzKSB7XG5cblx0XHRcdFx0XHRmb250U2l6ZSA9IHBhcnNlRmxvYXQocGFyYW1zLmZvbnRTaXplKTtcblxuXHRcdFx0XHRcdC8vIEdyZWF0ZXIgdmFsdWVzIG1vdmUgY2xvY2t3aXNlXG5cdFx0XHRcdFx0aWYgKHBhcmFtcy5sZXR0ZXJTcGFjaW5nID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRwYXJhbXMubGV0dGVyU3BhY2luZyA9IGZvbnRTaXplIC8gY29uc3RhbnRDbG9zZW5lc3M7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGVhY2ggbGluZSBvZiB0ZXh0XG5cdFx0XHRcdFx0Zm9yIChsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCArPSAxKSB7XG5cdFx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZShwYXJhbXMueCwgcGFyYW1zLnkpO1xuXHRcdFx0XHRcdFx0bGluZSA9IGxpbmVzW2xdO1xuXHRcdFx0XHRcdFx0aWYgKHBhcmFtcy5mbGlwQXJjVGV4dCkge1xuXHRcdFx0XHRcdFx0XHRjaGFycyA9IGxpbmUuc3BsaXQoJycpO1xuXHRcdFx0XHRcdFx0XHRjaGFycy5yZXZlcnNlKCk7XG5cdFx0XHRcdFx0XHRcdGxpbmUgPSBjaGFycy5qb2luKCcnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG5jaGFycyA9IGxpbmUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0Y3R4LnJvdGF0ZSgtKFBJICogcGFyYW1zLmxldHRlclNwYWNpbmcgKiAobmNoYXJzIC0gMSkpIC8gMik7XG5cdFx0XHRcdFx0XHQvLyBMb29wIHRocm91Z2ggY2hhcmFjdGVycyBvbiBlYWNoIGxpbmVcblx0XHRcdFx0XHRcdGZvciAoYyA9IDA7IGMgPCBuY2hhcnM7IGMgKz0gMSkge1xuXHRcdFx0XHRcdFx0XHRjaCA9IGxpbmVbY107XG5cdFx0XHRcdFx0XHRcdC8vIElmIGNoYXJhY3RlciBpcyBub3QgdGhlIGZpcnN0IGNoYXJhY3RlclxuXHRcdFx0XHRcdFx0XHRpZiAoYyAhPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFJvdGF0ZSBjaGFyYWN0ZXIgb250byBhcmNcblx0XHRcdFx0XHRcdFx0XHRjdHgucm90YXRlKFBJICogcGFyYW1zLmxldHRlclNwYWNpbmcpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdFx0XHRcdGN0eC50cmFuc2xhdGUoMCwgLXBhcmFtcy5yYWRpdXMpO1xuXHRcdFx0XHRcdFx0XHRpZiAocGFyYW1zLmZsaXBBcmNUZXh0KSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnNjYWxlKC0xLCAtMSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KGNoLCAwLCAwKTtcblx0XHRcdFx0XHRcdFx0Ly8gUHJldmVudCBleHRyYSBzaGFkb3cgY3JlYXRlZCBieSBzdHJva2UgKGJ1dCBvbmx5IHdoZW4gZmlsbCBpcyBwcmVzZW50KVxuXHRcdFx0XHRcdFx0XHRpZiAocGFyYW1zLmZpbGxTdHlsZSAhPT0gJ3RyYW5zcGFyZW50Jykge1xuXHRcdFx0XHRcdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICd0cmFuc3BhcmVudCc7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKHBhcmFtcy5zdHJva2VXaWR0aCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Ryb2tlIGlmIHRoZSBzdHJva2UgaXMgbm90IDBcblx0XHRcdFx0XHRcdFx0XHRjdHguc3Ryb2tlVGV4dChjaCwgMCwgMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBhcmFtcy5yYWRpdXMgLT0gZm9udFNpemU7XG5cdFx0XHRcdFx0XHRwYXJhbXMubGV0dGVyU3BhY2luZyArPSBmb250U2l6ZSAvIChjb25zdGFudENsb3NlbmVzcyAqIDIgKiBQSSk7XG5cdFx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gRHJhdyBlYWNoIGxpbmUgb2YgdGV4dCBzZXBhcmF0ZWx5XG5cdFx0XHRcdFx0Zm9yIChsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCArPSAxKSB7XG5cdFx0XHRcdFx0XHRsaW5lID0gbGluZXNbbF07XG5cdFx0XHRcdFx0XHQvLyBBZGQgbGluZSBvZmZzZXQgdG8gY2VudGVyIHBvaW50LCBidXQgc3VidHJhY3Qgc29tZSB0byBjZW50ZXIgZXZlcnl0aGluZ1xuXHRcdFx0XHRcdFx0eSA9IHBhcmFtcy55ICsgKGwgKiBwYXJhbXMuaGVpZ2h0IC8gbGluZXMubGVuZ3RoKSAtICgoKGxpbmVzLmxlbmd0aCAtIDEpICogcGFyYW1zLmhlaWdodCAvIGxpbmVzLmxlbmd0aCkgLyAyKTtcblxuXHRcdFx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gcGFyYW1zLnNoYWRvd0NvbG9yO1xuXG5cdFx0XHRcdFx0XHQvLyBGaWxsICYgc3Ryb2tlIHRleHRcblx0XHRcdFx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCB4LCB5KTtcblx0XHRcdFx0XHRcdC8vIFByZXZlbnQgZXh0cmEgc2hhZG93IGNyZWF0ZWQgYnkgc3Ryb2tlIChidXQgb25seSB3aGVuIGZpbGwgaXMgcHJlc2VudClcblx0XHRcdFx0XHRcdGlmIChwYXJhbXMuZmlsbFN0eWxlICE9PSAndHJhbnNwYXJlbnQnKSB7XG5cdFx0XHRcdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICd0cmFuc3BhcmVudCc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAocGFyYW1zLnN0cm9rZVdpZHRoICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Ryb2tlIGlmIHRoZSBzdHJva2UgaXMgbm90IDBcblx0XHRcdFx0XHRcdFx0Y3R4LnN0cm9rZVRleHQobGluZSwgeCwgeSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkanVzdCBib3VuZGluZyBib3ggYWNjb3JkaW5nIHRvIHRleHQgYmFzZWxpbmVcblx0XHRcdFx0eSA9IDA7XG5cdFx0XHRcdGlmIChwYXJhbXMuYmFzZWxpbmUgPT09ICd0b3AnKSB7XG5cdFx0XHRcdFx0eSArPSBwYXJhbXMuaGVpZ2h0IC8gMjtcblx0XHRcdFx0fSBlbHNlIGlmIChwYXJhbXMuYmFzZWxpbmUgPT09ICdib3R0b20nKSB7XG5cdFx0XHRcdFx0eSAtPSBwYXJhbXMuaGVpZ2h0IC8gMjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIERldGVjdCBqQ2FudmFzIGV2ZW50c1xuXHRcdFx0XHRpZiAocGFyYW1zLl9ldmVudCkge1xuXHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRjdHgucmVjdChcblx0XHRcdFx0XHRcdHBhcmFtcy54IC0gKHBhcmFtcy53aWR0aCAvIDIpLFxuXHRcdFx0XHRcdFx0cGFyYW1zLnkgLSAocGFyYW1zLmhlaWdodCAvIDIpICsgeSxcblx0XHRcdFx0XHRcdHBhcmFtcy53aWR0aCxcblx0XHRcdFx0XHRcdHBhcmFtcy5oZWlnaHRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdF9kZXRlY3RFdmVudHMoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcyk7XG5cdFx0XHRcdFx0Ly8gQ2xvc2UgcGF0aCBhbmQgY29uZmlndXJlIG1hc2tpbmdcblx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3Jlc3RvcmVUcmFuc2Zvcm0oY3R4LCBwYXJhbXMpO1xuXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vIENhY2hlIGpDYW52YXMgcGFyYW1ldGVycyBvYmplY3QgZm9yIGVmZmljaWVuY3lcblx0Y2FjaGVzLnByb3BDYWNoZSA9IHBhcmFtcztcblx0cmV0dXJuICRjYW52YXNlcztcbn07XG5cbi8vIE1lYXN1cmVzIHRleHQgd2lkdGgvaGVpZ2h0IHVzaW5nIHRoZSBnaXZlbiBwYXJhbWV0ZXJzXG4kLmZuLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24gbWVhc3VyZVRleHQoYXJncykge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgY3R4LFxuXHRcdHBhcmFtcywgbGluZXM7XG5cblx0Ly8gQXR0ZW1wdCB0byByZXRyaWV2ZSBsYXllclxuXHRwYXJhbXMgPSAkY2FudmFzZXMuZ2V0TGF5ZXIoYXJncyk7XG5cdC8vIElmIGxheWVyIGRvZXMgbm90IGV4aXN0IG9yIGlmIHJldHVybmVkIG9iamVjdCBpcyBub3QgYSBqQ2FudmFzIGxheWVyXG5cdGlmICghcGFyYW1zIHx8IChwYXJhbXMgJiYgIXBhcmFtcy5fbGF5ZXIpKSB7XG5cdFx0cGFyYW1zID0gbmV3IGpDYW52YXNPYmplY3QoYXJncyk7XG5cdH1cblxuXHRjdHggPSBfZ2V0Q29udGV4dCgkY2FudmFzZXNbMF0pO1xuXHRpZiAoY3R4KSB7XG5cblx0XHQvLyBTZXQgY2FudmFzIGZvbnQgdXNpbmcgZ2l2ZW4gcHJvcGVydGllc1xuXHRcdF9zZXRDYW52YXNGb250KCRjYW52YXNlc1swXSwgY3R4LCBwYXJhbXMpO1xuXHRcdC8vIENhbGN1bGF0ZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRleHRcblx0XHRpZiAocGFyYW1zLm1heFdpZHRoICE9PSBudWxsKSB7XG5cdFx0XHRsaW5lcyA9IF93cmFwVGV4dChjdHgsIHBhcmFtcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxpbmVzID0gcGFyYW1zLnRleHQuc3BsaXQoJ1xcbicpO1xuXHRcdH1cblx0XHRfbWVhc3VyZVRleHQoJGNhbnZhc2VzWzBdLCBjdHgsIHBhcmFtcywgbGluZXMpO1xuXG5cblx0fVxuXG5cdHJldHVybiBwYXJhbXM7XG59O1xuXG4vKiBJbWFnZSBBUEkgKi9cblxuLy8gRHJhd3MgaW1hZ2Ugb24gY2FudmFzXG4kLmZuLmRyYXdJbWFnZSA9IGZ1bmN0aW9uIGRyYXdJbWFnZShhcmdzKSB7XG5cdHZhciAkY2FudmFzZXMgPSB0aGlzLCBjYW52YXMsIGUsIGN0eCwgZGF0YSxcblx0XHRwYXJhbXMsIGxheWVyLFxuXHRcdGltZywgaW1nQ3R4LCBzb3VyY2UsXG5cdFx0aW1hZ2VDYWNoZSA9IGNhY2hlcy5pbWFnZUNhY2hlO1xuXG5cdC8vIERyYXcgaW1hZ2UgZnVuY3Rpb25cblx0ZnVuY3Rpb24gZHJhdyhjYW52YXMsIGN0eCwgZGF0YSwgcGFyYW1zLCBsYXllcikge1xuXG5cdFx0Ly8gSWYgd2lkdGggYW5kIHNXaWR0aCBhcmUgbm90IGRlZmluZWQsIHVzZSBpbWFnZSB3aWR0aFxuXHRcdGlmIChwYXJhbXMud2lkdGggPT09IG51bGwgJiYgcGFyYW1zLnNXaWR0aCA9PT0gbnVsbCkge1xuXHRcdFx0cGFyYW1zLndpZHRoID0gcGFyYW1zLnNXaWR0aCA9IGltZy53aWR0aDtcblx0XHR9XG5cdFx0Ly8gSWYgd2lkdGggYW5kIHNIZWlnaHQgYXJlIG5vdCBkZWZpbmVkLCB1c2UgaW1hZ2UgaGVpZ2h0XG5cdFx0aWYgKHBhcmFtcy5oZWlnaHQgPT09IG51bGwgJiYgcGFyYW1zLnNIZWlnaHQgPT09IG51bGwpIHtcblx0XHRcdHBhcmFtcy5oZWlnaHQgPSBwYXJhbXMuc0hlaWdodCA9IGltZy5oZWlnaHQ7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIGltYWdlIGxheWVyJ3Mgd2lkdGggYW5kIGhlaWdodCBhcmUgYWNjdXJhdGVcblx0XHRpZiAobGF5ZXIpIHtcblx0XHRcdGxheWVyLndpZHRoID0gcGFyYW1zLndpZHRoO1xuXHRcdFx0bGF5ZXIuaGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcblx0XHR9XG5cblx0XHQvLyBPbmx5IGNyb3AgaW1hZ2UgaWYgYWxsIGNyb3BwaW5nIHByb3BlcnRpZXMgYXJlIGdpdmVuXG5cdFx0aWYgKHBhcmFtcy5zV2lkdGggIT09IG51bGwgJiYgcGFyYW1zLnNIZWlnaHQgIT09IG51bGwgJiYgcGFyYW1zLnN4ICE9PSBudWxsICYmIHBhcmFtcy5zeSAhPT0gbnVsbCkge1xuXG5cdFx0XHQvLyBJZiB3aWR0aCBpcyBub3QgZGVmaW5lZCwgdXNlIHRoZSBnaXZlbiBzV2lkdGhcblx0XHRcdGlmIChwYXJhbXMud2lkdGggPT09IG51bGwpIHtcblx0XHRcdFx0cGFyYW1zLndpZHRoID0gcGFyYW1zLnNXaWR0aDtcblx0XHRcdH1cblx0XHRcdC8vIElmIGhlaWdodCBpcyBub3QgZGVmaW5lZCwgdXNlIHRoZSBnaXZlbiBzSGVpZ2h0XG5cdFx0XHRpZiAocGFyYW1zLmhlaWdodCA9PT0gbnVsbCkge1xuXHRcdFx0XHRwYXJhbXMuaGVpZ2h0ID0gcGFyYW1zLnNIZWlnaHQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wdGlvbmFsbHkgY3JvcCBmcm9tIHRvcC1sZWZ0IGNvcm5lciBvZiByZWdpb25cblx0XHRcdGlmIChwYXJhbXMuY3JvcEZyb21DZW50ZXIpIHtcblx0XHRcdFx0cGFyYW1zLnN4ICs9IHBhcmFtcy5zV2lkdGggLyAyO1xuXHRcdFx0XHRwYXJhbXMuc3kgKz0gcGFyYW1zLnNIZWlnaHQgLyAyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBFbnN1cmUgY3JvcHBlZCByZWdpb24gZG9lcyBub3QgZXNjYXBlIGltYWdlIGJvdW5kYXJpZXNcblxuXHRcdFx0Ly8gVG9wXG5cdFx0XHRpZiAoKHBhcmFtcy5zeSAtIChwYXJhbXMuc0hlaWdodCAvIDIpKSA8IDApIHtcblx0XHRcdFx0cGFyYW1zLnN5ID0gKHBhcmFtcy5zSGVpZ2h0IC8gMik7XG5cdFx0XHR9XG5cdFx0XHQvLyBCb3R0b21cblx0XHRcdGlmICgocGFyYW1zLnN5ICsgKHBhcmFtcy5zSGVpZ2h0IC8gMikpID4gaW1nLmhlaWdodCkge1xuXHRcdFx0XHRwYXJhbXMuc3kgPSBpbWcuaGVpZ2h0IC0gKHBhcmFtcy5zSGVpZ2h0IC8gMik7XG5cdFx0XHR9XG5cdFx0XHQvLyBMZWZ0XG5cdFx0XHRpZiAoKHBhcmFtcy5zeCAtIChwYXJhbXMuc1dpZHRoIC8gMikpIDwgMCkge1xuXHRcdFx0XHRwYXJhbXMuc3ggPSAocGFyYW1zLnNXaWR0aCAvIDIpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmlnaHRcblx0XHRcdGlmICgocGFyYW1zLnN4ICsgKHBhcmFtcy5zV2lkdGggLyAyKSkgPiBpbWcud2lkdGgpIHtcblx0XHRcdFx0cGFyYW1zLnN4ID0gaW1nLndpZHRoIC0gKHBhcmFtcy5zV2lkdGggLyAyKTtcblx0XHRcdH1cblxuXHRcdFx0X3RyYW5zZm9ybVNoYXBlKGNhbnZhcywgY3R4LCBwYXJhbXMsIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XG5cdFx0XHRfc2V0R2xvYmFsUHJvcHMoY2FudmFzLCBjdHgsIHBhcmFtcyk7XG5cblx0XHRcdC8vIERyYXcgaW1hZ2Vcblx0XHRcdGN0eC5kcmF3SW1hZ2UoXG5cdFx0XHRcdGltZyxcblx0XHRcdFx0cGFyYW1zLnN4IC0gKHBhcmFtcy5zV2lkdGggLyAyKSxcblx0XHRcdFx0cGFyYW1zLnN5IC0gKHBhcmFtcy5zSGVpZ2h0IC8gMiksXG5cdFx0XHRcdHBhcmFtcy5zV2lkdGgsXG5cdFx0XHRcdHBhcmFtcy5zSGVpZ2h0LFxuXHRcdFx0XHRwYXJhbXMueCAtIChwYXJhbXMud2lkdGggLyAyKSxcblx0XHRcdFx0cGFyYW1zLnkgLSAocGFyYW1zLmhlaWdodCAvIDIpLFxuXHRcdFx0XHRwYXJhbXMud2lkdGgsXG5cdFx0XHRcdHBhcmFtcy5oZWlnaHRcblx0XHRcdCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gU2hvdyBlbnRpcmUgaW1hZ2UgaWYgbm8gY3JvcCByZWdpb24gaXMgZGVmaW5lZFxuXG5cdFx0XHRfdHJhbnNmb3JtU2hhcGUoY2FudmFzLCBjdHgsIHBhcmFtcywgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcblx0XHRcdF9zZXRHbG9iYWxQcm9wcyhjYW52YXMsIGN0eCwgcGFyYW1zKTtcblxuXHRcdFx0Ly8gRHJhdyBpbWFnZSBvbiBjYW52YXNcblx0XHRcdGN0eC5kcmF3SW1hZ2UoXG5cdFx0XHRcdGltZyxcblx0XHRcdFx0cGFyYW1zLnggLSAocGFyYW1zLndpZHRoIC8gMiksXG5cdFx0XHRcdHBhcmFtcy55IC0gKHBhcmFtcy5oZWlnaHQgLyAyKSxcblx0XHRcdFx0cGFyYW1zLndpZHRoLFxuXHRcdFx0XHRwYXJhbXMuaGVpZ2h0XG5cdFx0XHQpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gRHJhdyBpbnZpc2libGUgcmVjdGFuZ2xlIHRvIGFsbG93IGZvciBldmVudHMgYW5kIG1hc2tpbmdcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LnJlY3QoXG5cdFx0XHRwYXJhbXMueCAtIChwYXJhbXMud2lkdGggLyAyKSxcblx0XHRcdHBhcmFtcy55IC0gKHBhcmFtcy5oZWlnaHQgLyAyKSxcblx0XHRcdHBhcmFtcy53aWR0aCxcblx0XHRcdHBhcmFtcy5oZWlnaHRcblx0XHQpO1xuXHRcdC8vIENoZWNrIGZvciBqQ2FudmFzIGV2ZW50c1xuXHRcdF9kZXRlY3RFdmVudHMoY2FudmFzLCBjdHgsIHBhcmFtcyk7XG5cdFx0Ly8gQ2xvc2UgcGF0aCBhbmQgY29uZmlndXJlIG1hc2tpbmdcblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0X3Jlc3RvcmVUcmFuc2Zvcm0oY3R4LCBwYXJhbXMpO1xuXHRcdF9lbmFibGVNYXNraW5nKGN0eCwgZGF0YSwgcGFyYW1zKTtcblx0fVxuXHQvLyBPbiBsb2FkIGZ1bmN0aW9uXG5cdGZ1bmN0aW9uIG9ubG9hZChjYW52YXMsIGN0eCwgZGF0YSwgcGFyYW1zLCBsYXllcikge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgJGNhbnZhcyA9ICQoY2FudmFzKTtcblx0XHRcdGRyYXcoY2FudmFzLCBjdHgsIGRhdGEsIHBhcmFtcywgbGF5ZXIpO1xuXHRcdFx0aWYgKHBhcmFtcy5sYXllcikge1xuXHRcdFx0XHQvLyBUcmlnZ2VyICdsb2FkJyBldmVudCBmb3IgbGF5ZXJzXG5cdFx0XHRcdF90cmlnZ2VyTGF5ZXJFdmVudCgkY2FudmFzLCBkYXRhLCBsYXllciwgJ2xvYWQnKTtcblx0XHRcdH0gZWxzZSBpZiAocGFyYW1zLmxvYWQpIHtcblx0XHRcdFx0Ly8gUnVuICdsb2FkJyBjYWxsYmFjayBmb3Igbm9uLWxheWVyc1xuXHRcdFx0XHRwYXJhbXMubG9hZC5jYWxsKCRjYW52YXNbMF0sIGxheWVyKTtcblx0XHRcdH1cblx0XHRcdC8vIENvbnRpbnVlIGRyYXdpbmcgc3VjY2Vzc2l2ZSBsYXllcnMgYWZ0ZXIgdGhpcyBpbWFnZSBsYXllciBoYXMgbG9hZGVkXG5cdFx0XHRpZiAocGFyYW1zLmxheWVyKSB7XG5cdFx0XHRcdC8vIFN0b3JlIGxpc3Qgb2YgcHJldmlvdXMgbWFza3MgZm9yIGVhY2ggbGF5ZXJcblx0XHRcdFx0bGF5ZXIuX21hc2tzID0gZGF0YS50cmFuc2Zvcm1zLm1hc2tzLnNsaWNlKDApO1xuXHRcdFx0XHRpZiAocGFyYW1zLl9uZXh0KSB7XG5cdFx0XHRcdFx0Ly8gRHJhdyBzdWNjZXNzaXZlIGxheWVyc1xuXHRcdFx0XHRcdHZhciBjb21wbGV0ZSA9IGRhdGEuZHJhd0xheWVyc0NvbXBsZXRlO1xuXHRcdFx0XHRcdGRlbGV0ZSBkYXRhLmRyYXdMYXllcnNDb21wbGV0ZTtcblx0XHRcdFx0XHQkY2FudmFzLmRyYXdMYXllcnMoe1xuXHRcdFx0XHRcdFx0Y2xlYXI6IGZhbHNlLFxuXHRcdFx0XHRcdFx0cmVzZXRGaXJlOiB0cnVlLFxuXHRcdFx0XHRcdFx0aW5kZXg6IHBhcmFtcy5fbmV4dCxcblx0XHRcdFx0XHRcdGNvbXBsZXRlOiBjb21wbGV0ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0Y2FudmFzID0gJGNhbnZhc2VzW2VdO1xuXHRcdGN0eCA9IF9nZXRDb250ZXh0KCRjYW52YXNlc1tlXSk7XG5cdFx0aWYgKGN0eCkge1xuXG5cdFx0XHRkYXRhID0gX2dldENhbnZhc0RhdGEoJGNhbnZhc2VzW2VdKTtcblx0XHRcdHBhcmFtcyA9IG5ldyBqQ2FudmFzT2JqZWN0KGFyZ3MpO1xuXHRcdFx0bGF5ZXIgPSBfYWRkTGF5ZXIoJGNhbnZhc2VzW2VdLCBwYXJhbXMsIGFyZ3MsIGRyYXdJbWFnZSk7XG5cdFx0XHRpZiAocGFyYW1zLnZpc2libGUpIHtcblxuXHRcdFx0XHQvLyBDYWNoZSB0aGUgZ2l2ZW4gc291cmNlXG5cdFx0XHRcdHNvdXJjZSA9IHBhcmFtcy5zb3VyY2U7XG5cblx0XHRcdFx0aW1nQ3R4ID0gc291cmNlLmdldENvbnRleHQ7XG5cdFx0XHRcdGlmIChzb3VyY2Uuc3JjIHx8IGltZ0N0eCkge1xuXHRcdFx0XHRcdC8vIFVzZSBpbWFnZSBvciBjYW52YXMgZWxlbWVudCBpZiBnaXZlblxuXHRcdFx0XHRcdGltZyA9IHNvdXJjZTtcblx0XHRcdFx0fSBlbHNlIGlmIChzb3VyY2UpIHtcblx0XHRcdFx0XHRpZiAoaW1hZ2VDYWNoZVtzb3VyY2VdICYmIGltYWdlQ2FjaGVbc291cmNlXS5jb21wbGV0ZSkge1xuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBpbWFnZSBlbGVtZW50IGZyb20gdGhlIGNhY2hlIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRpbWcgPSBpbWFnZUNhY2hlW3NvdXJjZV07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgZ2V0IHRoZSBpbWFnZSBmcm9tIHRoZSBnaXZlbiBzb3VyY2UgVVJMXG5cdFx0XHRcdFx0XHRpbWcgPSBuZXcgSW1hZ2UoKTtcblx0XHRcdFx0XHRcdC8vIElmIHNvdXJjZSBVUkwgaXMgbm90IGEgZGF0YSBVUkxcblx0XHRcdFx0XHRcdGlmICghc291cmNlLm1hdGNoKC9eZGF0YTovaSkpIHtcblx0XHRcdFx0XHRcdFx0Ly8gU2V0IGNyb3NzT3JpZ2luIGZvciB0aGlzIGltYWdlXG5cdFx0XHRcdFx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHBhcmFtcy5jcm9zc09yaWdpbjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGltZy5zcmMgPSBzb3VyY2U7XG5cdFx0XHRcdFx0XHQvLyBTYXZlIGltYWdlIGluIGNhY2hlIGZvciBpbXByb3ZlZCBwZXJmb3JtYW5jZVxuXHRcdFx0XHRcdFx0aW1hZ2VDYWNoZVtzb3VyY2VdID0gaW1nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpbWcpIHtcblx0XHRcdFx0XHRpZiAoaW1nLmNvbXBsZXRlIHx8IGltZ0N0eCkge1xuXHRcdFx0XHRcdFx0Ly8gRHJhdyBpbWFnZSBpZiBhbHJlYWR5IGxvYWRlZFxuXHRcdFx0XHRcdFx0b25sb2FkKGNhbnZhcywgY3R4LCBkYXRhLCBwYXJhbXMsIGxheWVyKSgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGRyYXcgaW1hZ2Ugd2hlbiBpdCBsb2Fkc1xuXHRcdFx0XHRcdFx0aW1nLm9ubG9hZCA9IG9ubG9hZChjYW52YXMsIGN0eCwgZGF0YSwgcGFyYW1zLCBsYXllcik7XG5cdFx0XHRcdFx0XHQvLyBGaXggb25sb2FkKCkgYnVnIGluIElFOVxuXHRcdFx0XHRcdFx0aW1nLnNyYyA9IGltZy5zcmM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuICRjYW52YXNlcztcbn07XG5cbi8vIENyZWF0ZXMgYSBjYW52YXMgcGF0dGVybiBvYmplY3RcbiQuZm4uY3JlYXRlUGF0dGVybiA9IGZ1bmN0aW9uIGNyZWF0ZVBhdHRlcm4oYXJncykge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcywgY3R4LFxuXHRcdHBhcmFtcyxcblx0XHRpbWcsIGltZ0N0eCxcblx0XHRwYXR0ZXJuLCBzb3VyY2U7XG5cblx0Ly8gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gcGF0dGVybiBsb2Fkc1xuXHRmdW5jdGlvbiBvbmxvYWQoKSB7XG5cdFx0Ly8gQ3JlYXRlIHBhdHRlcm5cblx0XHRwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4oaW1nLCBwYXJhbXMucmVwZWF0KTtcblx0XHQvLyBSdW4gY2FsbGJhY2sgZnVuY3Rpb24gaWYgZGVmaW5lZFxuXHRcdGlmIChwYXJhbXMubG9hZCkge1xuXHRcdFx0cGFyYW1zLmxvYWQuY2FsbCgkY2FudmFzZXNbMF0sIHBhdHRlcm4pO1xuXHRcdH1cblx0fVxuXG5cdGN0eCA9IF9nZXRDb250ZXh0KCRjYW52YXNlc1swXSk7XG5cdGlmIChjdHgpIHtcblxuXHRcdHBhcmFtcyA9IG5ldyBqQ2FudmFzT2JqZWN0KGFyZ3MpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGdpdmVuIHNvdXJjZVxuXHRcdHNvdXJjZSA9IHBhcmFtcy5zb3VyY2U7XG5cblx0XHQvLyBEcmF3IHdoZW4gaW1hZ2UgaXMgbG9hZGVkIChpZiBsb2FkKCkgY2FsbGJhY2sgZnVuY3Rpb24gaXMgZGVmaW5lZClcblxuXHRcdGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcblx0XHRcdC8vIERyYXcgcGF0dGVybiB1c2luZyBmdW5jdGlvbiBpZiBnaXZlblxuXG5cdFx0XHRpbWcgPSAkKCc8Y2FudmFzIC8+JylbMF07XG5cdFx0XHRpbWcud2lkdGggPSBwYXJhbXMud2lkdGg7XG5cdFx0XHRpbWcuaGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcblx0XHRcdGltZ0N0eCA9IF9nZXRDb250ZXh0KGltZyk7XG5cdFx0XHRzb3VyY2UuY2FsbChpbWcsIGltZ0N0eCk7XG5cdFx0XHRvbmxvYWQoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBPdGhlcndpc2UsIGRyYXcgcGF0dGVybiB1c2luZyBzb3VyY2UgaW1hZ2VcblxuXHRcdFx0aW1nQ3R4ID0gc291cmNlLmdldENvbnRleHQ7XG5cdFx0XHRpZiAoc291cmNlLnNyYyB8fCBpbWdDdHgpIHtcblx0XHRcdFx0Ly8gVXNlIGltYWdlIGVsZW1lbnQgaWYgZ2l2ZW5cblx0XHRcdFx0aW1nID0gc291cmNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gVXNlIFVSTCBpZiBnaXZlbiB0byBnZXQgdGhlIGltYWdlXG5cdFx0XHRcdGltZyA9IG5ldyBJbWFnZSgpO1xuXHRcdFx0XHQvLyBJZiBzb3VyY2UgVVJMIGlzIG5vdCBhIGRhdGEgVVJMXG5cdFx0XHRcdGlmICghc291cmNlLm1hdGNoKC9eZGF0YTovaSkpIHtcblx0XHRcdFx0XHQvLyBTZXQgY3Jvc3NPcmlnaW4gZm9yIHRoaXMgaW1hZ2Vcblx0XHRcdFx0XHRpbWcuY3Jvc3NPcmlnaW4gPSBwYXJhbXMuY3Jvc3NPcmlnaW47XG5cdFx0XHRcdH1cblx0XHRcdFx0aW1nLnNyYyA9IHNvdXJjZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ3JlYXRlIHBhdHRlcm4gaWYgYWxyZWFkeSBsb2FkZWRcblx0XHRcdGlmIChpbWcuY29tcGxldGUgfHwgaW1nQ3R4KSB7XG5cdFx0XHRcdG9ubG9hZCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW1nLm9ubG9hZCA9IG9ubG9hZDtcblx0XHRcdFx0Ly8gRml4IG9ubG9hZCgpIGJ1ZyBpbiBJRTlcblx0XHRcdFx0aW1nLnNyYyA9IGltZy5zcmM7XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdHBhdHRlcm4gPSBudWxsO1xuXG5cdH1cblx0cmV0dXJuIHBhdHRlcm47XG59O1xuXG4vLyBDcmVhdGVzIGEgY2FudmFzIGdyYWRpZW50IG9iamVjdFxuJC5mbi5jcmVhdGVHcmFkaWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUdyYWRpZW50KGFyZ3MpIHtcblx0dmFyICRjYW52YXNlcyA9IHRoaXMsIGN0eCxcblx0XHRwYXJhbXMsXG5cdFx0Z3JhZGllbnQsXG5cdFx0c3RvcHMgPSBbXSwgbnN0b3BzLFxuXHRcdHN0YXJ0LCBlbmQsXG5cdFx0aSwgYSwgbiwgcDtcblxuXHRwYXJhbXMgPSBuZXcgakNhbnZhc09iamVjdChhcmdzKTtcblx0Y3R4ID0gX2dldENvbnRleHQoJGNhbnZhc2VzWzBdKTtcblx0aWYgKGN0eCkge1xuXG5cdFx0Ly8gR3JhZGllbnQgY29vcmRpbmF0ZXMgbXVzdCBiZSBkZWZpbmVkXG5cdFx0cGFyYW1zLngxID0gcGFyYW1zLngxIHx8IDA7XG5cdFx0cGFyYW1zLnkxID0gcGFyYW1zLnkxIHx8IDA7XG5cdFx0cGFyYW1zLngyID0gcGFyYW1zLngyIHx8IDA7XG5cdFx0cGFyYW1zLnkyID0gcGFyYW1zLnkyIHx8IDA7XG5cblx0XHRpZiAocGFyYW1zLnIxICE9PSBudWxsICYmIHBhcmFtcy5yMiAhPT0gbnVsbCkge1xuXHRcdFx0Ly8gQ3JlYXRlIHJhZGlhbCBncmFkaWVudCBpZiBjaG9zZW5cblx0XHRcdGdyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHBhcmFtcy54MSwgcGFyYW1zLnkxLCBwYXJhbXMucjEsIHBhcmFtcy54MiwgcGFyYW1zLnkyLCBwYXJhbXMucjIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhIGxpbmVhciBncmFkaWVudCBieSBkZWZhdWx0XG5cdFx0XHRncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChwYXJhbXMueDEsIHBhcmFtcy55MSwgcGFyYW1zLngyLCBwYXJhbXMueTIpO1xuXHRcdH1cblxuXHRcdC8vIENvdW50IG51bWJlciBvZiBjb2xvciBzdG9wc1xuXHRcdGZvciAoaSA9IDE7IHBhcmFtc1snYycgKyBpXSAhPT0gdW5kZWZpbmVkOyBpICs9IDEpIHtcblx0XHRcdGlmIChwYXJhbXNbJ3MnICsgaV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRzdG9wcy5wdXNoKHBhcmFtc1sncycgKyBpXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdG9wcy5wdXNoKG51bGwpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRuc3RvcHMgPSBzdG9wcy5sZW5ndGg7XG5cblx0XHQvLyBEZWZpbmUgc3RhcnQgc3RvcCBpZiBub3QgYWxyZWFkeSBkZWZpbmVkXG5cdFx0aWYgKHN0b3BzWzBdID09PSBudWxsKSB7XG5cdFx0XHRzdG9wc1swXSA9IDA7XG5cdFx0fVxuXHRcdC8vIERlZmluZSBlbmQgc3RvcCBpZiBub3QgYWxyZWFkeSBkZWZpbmVkXG5cdFx0aWYgKHN0b3BzW25zdG9wcyAtIDFdID09PSBudWxsKSB7XG5cdFx0XHRzdG9wc1tuc3RvcHMgLSAxXSA9IDE7XG5cdFx0fVxuXG5cdFx0Ly8gTG9vcCB0aHJvdWdoIGNvbG9yIHN0b3BzIHRvIGZpbGwgaW4gdGhlIGJsYW5rc1xuXHRcdGZvciAoaSA9IDA7IGkgPCBuc3RvcHM7IGkgKz0gMSkge1xuXHRcdFx0Ly8gQSBwcm9ncmVzc2lvbiwgaW4gdGhpcyBjb250ZXh0LCBpcyBkZWZpbmVkIGFzIGFsbCBvZiB0aGUgY29sb3Igc3RvcHMgYmV0d2VlbiBhbmQgaW5jbHVkaW5nIHR3byBrbm93biBjb2xvciBzdG9wc1xuXG5cdFx0XHRpZiAoc3RvcHNbaV0gIT09IG51bGwpIHtcblx0XHRcdFx0Ly8gU3RhcnQgYSBuZXcgcHJvZ3Jlc3Npb24gaWYgc3RvcCBpcyBhIG51bWJlclxuXG5cdFx0XHRcdC8vIE51bWJlciBvZiBzdG9wcyBpbiBjdXJyZW50IHByb2dyZXNzaW9uXG5cdFx0XHRcdG4gPSAxO1xuXHRcdFx0XHQvLyBDdXJyZW50IGl0ZXJhdGlvbiBpbiBjdXJyZW50IHByb2dyZXNzaW9uXG5cdFx0XHRcdHAgPSAwO1xuXHRcdFx0XHRzdGFydCA9IHN0b3BzW2ldO1xuXG5cdFx0XHRcdC8vIExvb2sgYWhlYWQgdG8gZmluZCBlbmQgc3RvcFxuXHRcdFx0XHRmb3IgKGEgPSAoaSArIDEpOyBhIDwgbnN0b3BzOyBhICs9IDEpIHtcblx0XHRcdFx0XHRpZiAoc3RvcHNbYV0gIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdC8vIElmIHRoaXMgZnV0dXJlIHN0b3AgaXMgYSBudW1iZXIsIG1ha2UgaXQgdGhlIGVuZCBzdG9wIGZvciB0aGlzIHByb2dyZXNzaW9uXG5cdFx0XHRcdFx0XHRlbmQgPSBzdG9wc1thXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGtlZXAgbG9va2luZyBhaGVhZFxuXHRcdFx0XHRcdFx0biArPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEVuc3VyZSBzdGFydCBzdG9wIGlzIG5vdCBncmVhdGVyIHRoYW4gZW5kIHN0b3Bcblx0XHRcdFx0aWYgKHN0YXJ0ID4gZW5kKSB7XG5cdFx0XHRcdFx0c3RvcHNbYV0gPSBzdG9wc1tpXTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKHN0b3BzW2ldID09PSBudWxsKSB7XG5cdFx0XHRcdC8vIENhbGN1bGF0ZSBzdG9wIGlmIG5vdCBpbml0aWFsbHkgZ2l2ZW5cblx0XHRcdFx0cCArPSAxO1xuXHRcdFx0XHRzdG9wc1tpXSA9IHN0YXJ0ICsgKHAgKiAoKGVuZCAtIHN0YXJ0KSAvIG4pKTtcblx0XHRcdH1cblx0XHRcdC8vIEFkZCBjb2xvciBzdG9wIHRvIGdyYWRpZW50IG9iamVjdFxuXHRcdFx0Z3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3BzW2ldLCBwYXJhbXNbJ2MnICsgKGkgKyAxKV0pO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXHRcdGdyYWRpZW50ID0gbnVsbDtcblx0fVxuXHRyZXR1cm4gZ3JhZGllbnQ7XG59O1xuXG4vLyBNYW5pcHVsYXRlcyBwaXhlbHMgb24gdGhlIGNhbnZhc1xuJC5mbi5zZXRQaXhlbHMgPSBmdW5jdGlvbiBzZXRQaXhlbHMoYXJncykge1xuXHR2YXIgJGNhbnZhc2VzID0gdGhpcyxcblx0XHRjYW52YXMsIGUsIGN0eCwgY2FudmFzRGF0YSxcblx0XHRwYXJhbXMsXG5cdFx0cHgsXG5cdFx0aW1nRGF0YSwgcGl4ZWxEYXRhLCBpLCBsZW47XG5cblx0Zm9yIChlID0gMDsgZSA8ICRjYW52YXNlcy5sZW5ndGg7IGUgKz0gMSkge1xuXHRcdGNhbnZhcyA9ICRjYW52YXNlc1tlXTtcblx0XHRjdHggPSBfZ2V0Q29udGV4dChjYW52YXMpO1xuXHRcdGNhbnZhc0RhdGEgPSBfZ2V0Q2FudmFzRGF0YSgkY2FudmFzZXNbZV0pO1xuXHRcdGlmIChjdHgpIHtcblxuXHRcdFx0cGFyYW1zID0gbmV3IGpDYW52YXNPYmplY3QoYXJncyk7XG5cdFx0XHRfYWRkTGF5ZXIoY2FudmFzLCBwYXJhbXMsIGFyZ3MsIHNldFBpeGVscyk7XG5cdFx0XHRfdHJhbnNmb3JtU2hhcGUoJGNhbnZhc2VzW2VdLCBjdHgsIHBhcmFtcywgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcblxuXHRcdFx0Ly8gVXNlIGVudGlyZSBjYW52YXMgb2YgeCwgeSwgd2lkdGgsIG9yIGhlaWdodCBpcyBub3QgZGVmaW5lZFxuXHRcdFx0aWYgKHBhcmFtcy53aWR0aCA9PT0gbnVsbCB8fCBwYXJhbXMuaGVpZ2h0ID09PSBudWxsKSB7XG5cdFx0XHRcdHBhcmFtcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcblx0XHRcdFx0cGFyYW1zLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG5cdFx0XHRcdHBhcmFtcy54ID0gcGFyYW1zLndpZHRoIC8gMjtcblx0XHRcdFx0cGFyYW1zLnkgPSBwYXJhbXMuaGVpZ2h0IC8gMjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHBhcmFtcy53aWR0aCAhPT0gMCAmJiBwYXJhbXMuaGVpZ2h0ICE9PSAwKSB7XG5cdFx0XHRcdC8vIE9ubHkgc2V0IHBpeGVscyBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBub3QgemVyb1xuXG5cdFx0XHRcdGltZ0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKFxuXHRcdFx0XHRcdChwYXJhbXMueCAtIChwYXJhbXMud2lkdGggLyAyKSkgKiBjYW52YXNEYXRhLnBpeGVsUmF0aW8sXG5cdFx0XHRcdFx0KHBhcmFtcy55IC0gKHBhcmFtcy5oZWlnaHQgLyAyKSkgKiBjYW52YXNEYXRhLnBpeGVsUmF0aW8sXG5cdFx0XHRcdFx0cGFyYW1zLndpZHRoICogY2FudmFzRGF0YS5waXhlbFJhdGlvLFxuXHRcdFx0XHRcdHBhcmFtcy5oZWlnaHQgKiBjYW52YXNEYXRhLnBpeGVsUmF0aW9cblx0XHRcdFx0KTtcblx0XHRcdFx0cGl4ZWxEYXRhID0gaW1nRGF0YS5kYXRhO1xuXHRcdFx0XHRsZW4gPSBwaXhlbERhdGEubGVuZ3RoO1xuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBwaXhlbHMgd2l0aCB0aGUgXCJlYWNoXCIgY2FsbGJhY2sgZnVuY3Rpb25cblx0XHRcdFx0aWYgKHBhcmFtcy5lYWNoKSB7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG5cdFx0XHRcdFx0XHRweCA9IHtcblx0XHRcdFx0XHRcdFx0cjogcGl4ZWxEYXRhW2ldLFxuXHRcdFx0XHRcdFx0XHRnOiBwaXhlbERhdGFbaSArIDFdLFxuXHRcdFx0XHRcdFx0XHRiOiBwaXhlbERhdGFbaSArIDJdLFxuXHRcdFx0XHRcdFx0XHRhOiBwaXhlbERhdGFbaSArIDNdXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cGFyYW1zLmVhY2guY2FsbChjYW52YXMsIHB4LCBwYXJhbXMpO1xuXHRcdFx0XHRcdFx0cGl4ZWxEYXRhW2ldID0gcHgucjtcblx0XHRcdFx0XHRcdHBpeGVsRGF0YVtpICsgMV0gPSBweC5nO1xuXHRcdFx0XHRcdFx0cGl4ZWxEYXRhW2kgKyAyXSA9IHB4LmI7XG5cdFx0XHRcdFx0XHRwaXhlbERhdGFbaSArIDNdID0gcHguYTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gUHV0IHBpeGVscyBvbiBjYW52YXNcblx0XHRcdFx0Y3R4LnB1dEltYWdlRGF0YShcblx0XHRcdFx0XHRpbWdEYXRhLFxuXHRcdFx0XHRcdChwYXJhbXMueCAtIChwYXJhbXMud2lkdGggLyAyKSkgKiBjYW52YXNEYXRhLnBpeGVsUmF0aW8sXG5cdFx0XHRcdFx0KHBhcmFtcy55IC0gKHBhcmFtcy5oZWlnaHQgLyAyKSkgKiBjYW52YXNEYXRhLnBpeGVsUmF0aW9cblx0XHRcdFx0KTtcblx0XHRcdFx0Ly8gUmVzdG9yZSB0cmFuc2Zvcm1hdGlvblxuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cdH1cblx0cmV0dXJuICRjYW52YXNlcztcbn07XG5cbi8vIFJldHJpZXZlcyBjYW52YXMgaW1hZ2UgYXMgZGF0YSBVUkxcbiQuZm4uZ2V0Q2FudmFzSW1hZ2UgPSBmdW5jdGlvbiBnZXRDYW52YXNJbWFnZSh0eXBlLCBxdWFsaXR5KSB7XG5cdHZhciAkY2FudmFzZXMgPSB0aGlzLCBjYW52YXMsXG5cdFx0ZGF0YVVSTCA9IG51bGw7XG5cdGlmICgkY2FudmFzZXMubGVuZ3RoICE9PSAwKSB7XG5cdFx0Y2FudmFzID0gJGNhbnZhc2VzWzBdO1xuXHRcdGlmIChjYW52YXMudG9EYXRhVVJMKSB7XG5cdFx0XHQvLyBKUEVHIHF1YWxpdHkgZGVmYXVsdHMgdG8gMVxuXHRcdFx0aWYgKHF1YWxpdHkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRxdWFsaXR5ID0gMTtcblx0XHRcdH1cblx0XHRcdGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS8nICsgdHlwZSwgcXVhbGl0eSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhVVJMO1xufTtcblxuLy8gU2NhbGVzIGNhbnZhcyBiYXNlZCBvbiB0aGUgZGV2aWNlJ3MgcGl4ZWwgcmF0aW9cbiQuZm4uZGV0ZWN0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uIGRldGVjdFBpeGVsUmF0aW8oY2FsbGJhY2spIHtcblx0dmFyICRjYW52YXNlcyA9IHRoaXMsXG5cdFx0Y2FudmFzLCBlLCBjdHgsXG5cdFx0ZGV2aWNlUGl4ZWxSYXRpbywgYmFja2luZ1N0b3JlUmF0aW8sIHJhdGlvLFxuXHRcdG9sZFdpZHRoLCBvbGRIZWlnaHQsXG5cdFx0ZGF0YTtcblxuXHRmb3IgKGUgPSAwOyBlIDwgJGNhbnZhc2VzLmxlbmd0aDsgZSArPSAxKSB7XG5cdFx0Ly8gR2V0IGNhbnZhcyBhbmQgaXRzIGFzc29jaWF0ZWQgZGF0YVxuXHRcdGNhbnZhcyA9ICRjYW52YXNlc1tlXTtcblx0XHRjdHggPSBfZ2V0Q29udGV4dChjYW52YXMpO1xuXHRcdGRhdGEgPSBfZ2V0Q2FudmFzRGF0YSgkY2FudmFzZXNbZV0pO1xuXG5cdFx0Ly8gSWYgY2FudmFzIGhhcyBub3QgYWxyZWFkeSBiZWVuIHNjYWxlZCB3aXRoIHRoaXMgbWV0aG9kXG5cdFx0aWYgKCFkYXRhLnNjYWxlZCkge1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgZGV2aWNlIHBpeGVsIHJhdGlvc1xuXHRcdFx0ZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cdFx0XHRiYWNraW5nU3RvcmVSYXRpbyA9IGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG5cdFx0XHRcdGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG5cdFx0XHRcdGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcblx0XHRcdFx0Y3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG5cdFx0XHRcdGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBnZW5lcmFsIHJhdGlvIGJhc2VkIG9uIHRoZSB0d28gZ2l2ZW4gcmF0aW9zXG5cdFx0XHRyYXRpbyA9IGRldmljZVBpeGVsUmF0aW8gLyBiYWNraW5nU3RvcmVSYXRpbztcblxuXHRcdFx0aWYgKHJhdGlvICE9PSAxKSB7XG5cdFx0XHRcdC8vIFNjYWxlIGNhbnZhcyByZWxhdGl2ZSB0byByYXRpb1xuXG5cdFx0XHRcdC8vIEdldCB0aGUgY3VycmVudCBjYW52YXMgZGltZW5zaW9ucyBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRXaWR0aCA9IGNhbnZhcy53aWR0aDtcblx0XHRcdFx0b2xkSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcblxuXHRcdFx0XHQvLyBSZXNpemUgY2FudmFzIHJlbGF0aXZlIHRvIHRoZSBkZXRlcm1pbmVkIHJhdGlvXG5cdFx0XHRcdGNhbnZhcy53aWR0aCA9IG9sZFdpZHRoICogcmF0aW87XG5cdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSBvbGRIZWlnaHQgKiByYXRpbztcblxuXHRcdFx0XHQvLyBTY2FsZSBjYW52YXMgYmFjayB0byBvcmlnaW5hbCBkaW1lbnNpb25zIHZpYSBDU1Ncblx0XHRcdFx0Y2FudmFzLnN0eWxlLndpZHRoID0gb2xkV2lkdGggKyAncHgnO1xuXHRcdFx0XHRjYW52YXMuc3R5bGUuaGVpZ2h0ID0gb2xkSGVpZ2h0ICsgJ3B4JztcblxuXHRcdFx0XHQvLyBTY2FsZSBjb250ZXh0IHRvIGNvdW50ZXIgdGhlIG1hbnVhbCBzY2FsaW5nIG9mIGNhbnZhc1xuXHRcdFx0XHRjdHguc2NhbGUocmF0aW8sIHJhdGlvKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgcGl4ZWwgcmF0aW8gb24gY2FudmFzIGRhdGEgb2JqZWN0XG5cdFx0XHRkYXRhLnBpeGVsUmF0aW8gPSByYXRpbztcblx0XHRcdC8vIEVuc3VyZSB0aGF0IHRoaXMgbWV0aG9kIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlIGZvciBhbnkgZ2l2ZW4gY2FudmFzXG5cdFx0XHRkYXRhLnNjYWxlZCA9IHRydWU7XG5cblx0XHRcdC8vIENhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggdGhlIHJhdGlvIGFzIGl0cyBvbmx5IGFyZ3VtZW50XG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0Y2FsbGJhY2suY2FsbChjYW52YXMsIHJhdGlvKTtcblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cdHJldHVybiAkY2FudmFzZXM7XG59O1xuXG4vLyBDbGVhcnMgdGhlIGpDYW52YXMgY2FjaGVcbmpDYW52YXMuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XG5cdHZhciBjYWNoZU5hbWU7XG5cdGZvciAoY2FjaGVOYW1lIGluIGNhY2hlcykge1xuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2FjaGVzLCBjYWNoZU5hbWUpKSB7XG5cdFx0XHRjYWNoZXNbY2FjaGVOYW1lXSA9IHt9O1xuXHRcdH1cblx0fVxufTtcblxuLy8gRW5hYmxlIGNhbnZhcyBmZWF0dXJlIGRldGVjdGlvbiB3aXRoICQuc3VwcG9ydFxuJC5zdXBwb3J0LmNhbnZhcyA9ICgkKCc8Y2FudmFzIC8+JylbMF0uZ2V0Q29udGV4dCAhPT0gdW5kZWZpbmVkKTtcblxuLy8gRXhwb3J0IGpDYW52YXMgZnVuY3Rpb25zXG5leHRlbmRPYmplY3QoakNhbnZhcywge1xuXHRkZWZhdWx0czogZGVmYXVsdHMsXG5cdHNldEdsb2JhbFByb3BzOiBfc2V0R2xvYmFsUHJvcHMsXG5cdHRyYW5zZm9ybVNoYXBlOiBfdHJhbnNmb3JtU2hhcGUsXG5cdGRldGVjdEV2ZW50czogX2RldGVjdEV2ZW50cyxcblx0Y2xvc2VQYXRoOiBfY2xvc2VQYXRoLFxuXHRzZXRDYW52YXNGb250OiBfc2V0Q2FudmFzRm9udCxcblx0bWVhc3VyZVRleHQ6IF9tZWFzdXJlVGV4dFxufSk7XG4kLmpDYW52YXMgPSBqQ2FudmFzO1xuJC5qQ2FudmFzT2JqZWN0ID0gakNhbnZhc09iamVjdDtcblxufSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/vue/node_modules/jcanvas/dist/jcanvas.js\n");

/***/ })

}]);